import * as Se from "react";
import dn, { forwardRef as Wc, createElement as qc, createContext as Xc, useCallback as qr, useMemo as Jr, useState as Jt, useRef as un, useEffect as Gn, useContext as Yn, useLayoutEffect as Kc, PureComponent as Uy, memo as Hy } from "react";
import { createPortal as jy } from "react-dom";
var zy = function(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, a = t.length, i; r < a; r++)
      (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
  return e.concat(i || Array.prototype.slice.call(t));
};
function Gy(e, t, n) {
  var r = e.length - t.length, a = Array.from(t);
  if (r === 0)
    return e.apply(void 0, a);
  if (r === 1) {
    var i = function(s) {
      return e.apply(void 0, zy([s], a, !1));
    };
    return (n || e.lazy) && (i.lazy = n || e.lazy, i.lazyArgs = t), i;
  }
  throw new Error("Wrong number of arguments");
}
function Yy(e) {
  return !!e && !Array.isArray(e) && typeof e == "object";
}
function Do() {
  return Gy(Wy, arguments);
}
function Wy(e, t) {
  var n = new Set(t);
  return Object.entries(e).reduce(function(r, a) {
    var i = a[0], s = a[1];
    return n.has(i) || (r[i] = s), r;
  }, {});
}
var bt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function pn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Zc(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var a = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, a.get ? a : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var QV = { exports: {} }, ss = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mh;
function qy() {
  if (mh)
    return ss;
  mh = 1;
  var e = dn, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, a = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(o, u, V) {
    var c, f = {}, p = null, h = null;
    V !== void 0 && (p = "" + V), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (h = u.ref);
    for (c in u)
      r.call(u, c) && !i.hasOwnProperty(c) && (f[c] = u[c]);
    if (o && o.defaultProps)
      for (c in u = o.defaultProps, u)
        f[c] === void 0 && (f[c] = u[c]);
    return { $$typeof: t, type: o, key: p, ref: h, props: f, _owner: a.current };
  }
  return ss.Fragment = n, ss.jsx = s, ss.jsxs = s, ss;
}
var os = {}, ph;
function Xy() {
  if (ph)
    return os;
  ph = 1;
  var e = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return e.NODE_ENV !== "production" && function() {
    var t = dn, n = Symbol.for("react.element"), r = Symbol.for("react.portal"), a = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), u = Symbol.for("react.context"), V = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), b = Symbol.iterator, v = "@@iterator";
    function x(L) {
      if (L === null || typeof L != "object")
        return null;
      var oe = b && L[b] || L[v];
      return typeof oe == "function" ? oe : null;
    }
    var E = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function S(L) {
      {
        for (var oe = arguments.length, be = new Array(oe > 1 ? oe - 1 : 0), Pe = 1; Pe < oe; Pe++)
          be[Pe - 1] = arguments[Pe];
        $("error", L, be);
      }
    }
    function $(L, oe, be) {
      {
        var Pe = E.ReactDebugCurrentFrame, Vt = Pe.getStackAddendum();
        Vt !== "" && (oe += "%s", be = be.concat([Vt]));
        var dt = be.map(function(nt) {
          return String(nt);
        });
        dt.unshift("Warning: " + oe), Function.prototype.apply.call(console[L], console, dt);
      }
    }
    var U = !1, y = !1, j = !1, q = !1, Q = !1, I;
    I = Symbol.for("react.module.reference");
    function ie(L) {
      return !!(typeof L == "string" || typeof L == "function" || L === a || L === s || Q || L === i || L === c || L === f || q || L === g || U || y || j || typeof L == "object" && L !== null && (L.$$typeof === h || L.$$typeof === p || L.$$typeof === o || L.$$typeof === u || L.$$typeof === V || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      L.$$typeof === I || L.getModuleId !== void 0));
    }
    function z(L, oe, be) {
      var Pe = L.displayName;
      if (Pe)
        return Pe;
      var Vt = oe.displayName || oe.name || "";
      return Vt !== "" ? be + "(" + Vt + ")" : be;
    }
    function H(L) {
      return L.displayName || "Context";
    }
    function P(L) {
      if (L == null)
        return null;
      if (typeof L.tag == "number" && S("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof L == "function")
        return L.displayName || L.name || null;
      if (typeof L == "string")
        return L;
      switch (L) {
        case a:
          return "Fragment";
        case r:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case c:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof L == "object")
        switch (L.$$typeof) {
          case u:
            var oe = L;
            return H(oe) + ".Consumer";
          case o:
            var be = L;
            return H(be._context) + ".Provider";
          case V:
            return z(L, L.render, "ForwardRef");
          case p:
            var Pe = L.displayName || null;
            return Pe !== null ? Pe : P(L.type) || "Memo";
          case h: {
            var Vt = L, dt = Vt._payload, nt = Vt._init;
            try {
              return P(nt(dt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, K = 0, D, J, ee, C, ge, pe, w;
    function De() {
    }
    De.__reactDisabledLog = !0;
    function $e() {
      {
        if (K === 0) {
          D = console.log, J = console.info, ee = console.warn, C = console.error, ge = console.group, pe = console.groupCollapsed, w = console.groupEnd;
          var L = {
            configurable: !0,
            enumerable: !0,
            value: De,
            writable: !0
          };
          Object.defineProperties(console, {
            info: L,
            log: L,
            warn: L,
            error: L,
            group: L,
            groupCollapsed: L,
            groupEnd: L
          });
        }
        K++;
      }
    }
    function Me() {
      {
        if (K--, K === 0) {
          var L = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, L, {
              value: D
            }),
            info: N({}, L, {
              value: J
            }),
            warn: N({}, L, {
              value: ee
            }),
            error: N({}, L, {
              value: C
            }),
            group: N({}, L, {
              value: ge
            }),
            groupCollapsed: N({}, L, {
              value: pe
            }),
            groupEnd: N({}, L, {
              value: w
            })
          });
        }
        K < 0 && S("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ct = E.ReactCurrentDispatcher, Ye;
    function Oe(L, oe, be) {
      {
        if (Ye === void 0)
          try {
            throw Error();
          } catch (Vt) {
            var Pe = Vt.stack.trim().match(/\n( *(at )?)/);
            Ye = Pe && Pe[1] || "";
          }
        return `
` + Ye + L;
      }
    }
    var We = !1, At;
    {
      var xt = typeof WeakMap == "function" ? WeakMap : Map;
      At = new xt();
    }
    function en(L, oe) {
      if (!L || We)
        return "";
      {
        var be = At.get(L);
        if (be !== void 0)
          return be;
      }
      var Pe;
      We = !0;
      var Vt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var dt;
      dt = ct.current, ct.current = null, $e();
      try {
        if (oe) {
          var nt = function() {
            throw Error();
          };
          if (Object.defineProperty(nt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(nt, []);
            } catch (or) {
              Pe = or;
            }
            Reflect.construct(L, [], nt);
          } else {
            try {
              nt.call();
            } catch (or) {
              Pe = or;
            }
            L.call(nt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (or) {
            Pe = or;
          }
          L();
        }
      } catch (or) {
        if (or && Pe && typeof or.stack == "string") {
          for (var qe = or.stack.split(`
`), rn = Pe.stack.split(`
`), kt = qe.length - 1, Ht = rn.length - 1; kt >= 1 && Ht >= 0 && qe[kt] !== rn[Ht]; )
            Ht--;
          for (; kt >= 1 && Ht >= 0; kt--, Ht--)
            if (qe[kt] !== rn[Ht]) {
              if (kt !== 1 || Ht !== 1)
                do
                  if (kt--, Ht--, Ht < 0 || qe[kt] !== rn[Ht]) {
                    var Rn = `
` + qe[kt].replace(" at new ", " at ");
                    return L.displayName && Rn.includes("<anonymous>") && (Rn = Rn.replace("<anonymous>", L.displayName)), typeof L == "function" && At.set(L, Rn), Rn;
                  }
                while (kt >= 1 && Ht >= 0);
              break;
            }
        }
      } finally {
        We = !1, ct.current = dt, Me(), Error.prepareStackTrace = Vt;
      }
      var $r = L ? L.displayName || L.name : "", Vo = $r ? Oe($r) : "";
      return typeof L == "function" && At.set(L, Vo), Vo;
    }
    function tn(L, oe, be) {
      return en(L, !1);
    }
    function An(L) {
      var oe = L.prototype;
      return !!(oe && oe.isReactComponent);
    }
    function En(L, oe, be) {
      if (L == null)
        return "";
      if (typeof L == "function")
        return en(L, An(L));
      if (typeof L == "string")
        return Oe(L);
      switch (L) {
        case c:
          return Oe("Suspense");
        case f:
          return Oe("SuspenseList");
      }
      if (typeof L == "object")
        switch (L.$$typeof) {
          case V:
            return tn(L.render);
          case p:
            return En(L.type, oe, be);
          case h: {
            var Pe = L, Vt = Pe._payload, dt = Pe._init;
            try {
              return En(dt(Vt), oe, be);
            } catch {
            }
          }
        }
      return "";
    }
    var Xn = Object.prototype.hasOwnProperty, vn = {}, rr = E.ReactDebugCurrentFrame;
    function Tn(L) {
      if (L) {
        var oe = L._owner, be = En(L.type, L._source, oe ? oe.type : null);
        rr.setExtraStackFrame(be);
      } else
        rr.setExtraStackFrame(null);
    }
    function Kn(L, oe, be, Pe, Vt) {
      {
        var dt = Function.call.bind(Xn);
        for (var nt in L)
          if (dt(L, nt)) {
            var qe = void 0;
            try {
              if (typeof L[nt] != "function") {
                var rn = Error((Pe || "React class") + ": " + be + " type `" + nt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof L[nt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw rn.name = "Invariant Violation", rn;
              }
              qe = L[nt](oe, nt, Pe, be, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (kt) {
              qe = kt;
            }
            qe && !(qe instanceof Error) && (Tn(Vt), S("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Pe || "React class", be, nt, typeof qe), Tn(null)), qe instanceof Error && !(qe.message in vn) && (vn[qe.message] = !0, Tn(Vt), S("Failed %s type: %s", be, qe.message), Tn(null));
          }
      }
    }
    var ln = Array.isArray;
    function Mn(L) {
      return ln(L);
    }
    function ar(L) {
      {
        var oe = typeof Symbol == "function" && Symbol.toStringTag, be = oe && L[Symbol.toStringTag] || L.constructor.name || "Object";
        return be;
      }
    }
    function te(L) {
      try {
        return de(L), !1;
      } catch {
        return !0;
      }
    }
    function de(L) {
      return "" + L;
    }
    function xe(L) {
      if (te(L))
        return S("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ar(L)), de(L);
    }
    var Ie = E.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Dt, Mt, Yt;
    Yt = {};
    function In(L) {
      if (Xn.call(L, "ref")) {
        var oe = Object.getOwnPropertyDescriptor(L, "ref").get;
        if (oe && oe.isReactWarning)
          return !1;
      }
      return L.ref !== void 0;
    }
    function Ot(L) {
      if (Xn.call(L, "key")) {
        var oe = Object.getOwnPropertyDescriptor(L, "key").get;
        if (oe && oe.isReactWarning)
          return !1;
      }
      return L.key !== void 0;
    }
    function rt(L, oe) {
      if (typeof L.ref == "string" && Ie.current && oe && Ie.current.stateNode !== oe) {
        var be = P(Ie.current.type);
        Yt[be] || (S('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', P(Ie.current.type), L.ref), Yt[be] = !0);
      }
    }
    function Ft(L, oe) {
      {
        var be = function() {
          Dt || (Dt = !0, S("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", oe));
        };
        be.isReactWarning = !0, Object.defineProperty(L, "key", {
          get: be,
          configurable: !0
        });
      }
    }
    function Nt(L, oe) {
      {
        var be = function() {
          Mt || (Mt = !0, S("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", oe));
        };
        be.isReactWarning = !0, Object.defineProperty(L, "ref", {
          get: be,
          configurable: !0
        });
      }
    }
    var yn = function(L, oe, be, Pe, Vt, dt, nt) {
      var qe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: L,
        key: oe,
        ref: be,
        props: nt,
        // Record the component responsible for creating this element.
        _owner: dt
      };
      return qe._store = {}, Object.defineProperty(qe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(qe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Pe
      }), Object.defineProperty(qe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Vt
      }), Object.freeze && (Object.freeze(qe.props), Object.freeze(qe)), qe;
    };
    function ir(L, oe, be, Pe, Vt) {
      {
        var dt, nt = {}, qe = null, rn = null;
        be !== void 0 && (xe(be), qe = "" + be), Ot(oe) && (xe(oe.key), qe = "" + oe.key), In(oe) && (rn = oe.ref, rt(oe, Vt));
        for (dt in oe)
          Xn.call(oe, dt) && !He.hasOwnProperty(dt) && (nt[dt] = oe[dt]);
        if (L && L.defaultProps) {
          var kt = L.defaultProps;
          for (dt in kt)
            nt[dt] === void 0 && (nt[dt] = kt[dt]);
        }
        if (qe || rn) {
          var Ht = typeof L == "function" ? L.displayName || L.name || "Unknown" : L;
          qe && Ft(nt, Ht), rn && Nt(nt, Ht);
        }
        return yn(L, qe, rn, Vt, Pe, Ie.current, nt);
      }
    }
    var Zn = E.ReactCurrentOwner, _a = E.ReactDebugCurrentFrame;
    function sr(L) {
      if (L) {
        var oe = L._owner, be = En(L.type, L._source, oe ? oe.type : null);
        _a.setExtraStackFrame(be);
      } else
        _a.setExtraStackFrame(null);
    }
    var na;
    na = !1;
    function Ca(L) {
      return typeof L == "object" && L !== null && L.$$typeof === n;
    }
    function Sa() {
      {
        if (Zn.current) {
          var L = P(Zn.current.type);
          if (L)
            return `

Check the render method of \`` + L + "`.";
        }
        return "";
      }
    }
    function Ji(L) {
      {
        if (L !== void 0) {
          var oe = L.fileName.replace(/^.*[\\\/]/, ""), be = L.lineNumber;
          return `

Check your code at ` + oe + ":" + be + ".";
        }
        return "";
      }
    }
    var Fr = {};
    function es(L) {
      {
        var oe = Sa();
        if (!oe) {
          var be = typeof L == "string" ? L : L.displayName || L.name;
          be && (oe = `

Check the top-level render call using <` + be + ">.");
        }
        return oe;
      }
    }
    function Br(L, oe) {
      {
        if (!L._store || L._store.validated || L.key != null)
          return;
        L._store.validated = !0;
        var be = es(oe);
        if (Fr[be])
          return;
        Fr[be] = !0;
        var Pe = "";
        L && L._owner && L._owner !== Zn.current && (Pe = " It was passed a child from " + P(L._owner.type) + "."), sr(L), S('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', be, Pe), sr(null);
      }
    }
    function ra(L, oe) {
      {
        if (typeof L != "object")
          return;
        if (Mn(L))
          for (var be = 0; be < L.length; be++) {
            var Pe = L[be];
            Ca(Pe) && Br(Pe, oe);
          }
        else if (Ca(L))
          L._store && (L._store.validated = !0);
        else if (L) {
          var Vt = x(L);
          if (typeof Vt == "function" && Vt !== L.entries)
            for (var dt = Vt.call(L), nt; !(nt = dt.next()).done; )
              Ca(nt.value) && Br(nt.value, oe);
        }
      }
    }
    function ts(L) {
      {
        var oe = L.type;
        if (oe == null || typeof oe == "string")
          return;
        var be;
        if (typeof oe == "function")
          be = oe.propTypes;
        else if (typeof oe == "object" && (oe.$$typeof === V || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        oe.$$typeof === p))
          be = oe.propTypes;
        else
          return;
        if (be) {
          var Pe = P(oe);
          Kn(be, L.props, "prop", Pe, L);
        } else if (oe.PropTypes !== void 0 && !na) {
          na = !0;
          var Vt = P(oe);
          S("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Vt || "Unknown");
        }
        typeof oe.getDefaultProps == "function" && !oe.getDefaultProps.isReactClassApproved && S("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ui(L) {
      {
        for (var oe = Object.keys(L.props), be = 0; be < oe.length; be++) {
          var Pe = oe[be];
          if (Pe !== "children" && Pe !== "key") {
            sr(L), S("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Pe), sr(null);
            break;
          }
        }
        L.ref !== null && (sr(L), S("Invalid attribute `ref` supplied to `React.Fragment`."), sr(null));
      }
    }
    function xa(L, oe, be, Pe, Vt, dt) {
      {
        var nt = ie(L);
        if (!nt) {
          var qe = "";
          (L === void 0 || typeof L == "object" && L !== null && Object.keys(L).length === 0) && (qe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var rn = Ji(Vt);
          rn ? qe += rn : qe += Sa();
          var kt;
          L === null ? kt = "null" : Mn(L) ? kt = "array" : L !== void 0 && L.$$typeof === n ? (kt = "<" + (P(L.type) || "Unknown") + " />", qe = " Did you accidentally export a JSX literal instead of a component?") : kt = typeof L, S("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", kt, qe);
        }
        var Ht = ir(L, oe, be, Vt, dt);
        if (Ht == null)
          return Ht;
        if (nt) {
          var Rn = oe.children;
          if (Rn !== void 0)
            if (Pe)
              if (Mn(Rn)) {
                for (var $r = 0; $r < Rn.length; $r++)
                  ra(Rn[$r], L);
                Object.freeze && Object.freeze(Rn);
              } else
                S("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ra(Rn, L);
        }
        return L === a ? ui(Ht) : ts(Ht), Ht;
      }
    }
    function nn(L, oe, be) {
      return xa(L, oe, be, !0);
    }
    function Oa(L, oe, be) {
      return xa(L, oe, be, !1);
    }
    var ns = Oa, aa = nn;
    os.Fragment = a, os.jsx = ns, os.jsxs = aa;
  }(), os;
}
var Ky = {};
Ky.NODE_ENV === "production" ? QV.exports = qy() : QV.exports = Xy();
var X = QV.exports;
const Zy = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, Ip = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, jt = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, Sn = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, la = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class se {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(t, n) {
    const r = n.match(t);
    return r && r.length > 0 && r[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(t, n) {
    const r = n.match(t);
    return r && r.length > 1 && r[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(t, n, r) {
    if (t.test(n))
      return r;
  }
  static getWindowsVersionName(t) {
    switch (t) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(t) {
    const n = t.split(".").splice(0, 2).map((r) => parseInt(r, 10) || 0);
    if (n.push(0), n[0] === 10)
      switch (n[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(t) {
    const n = t.split(".").splice(0, 2).map((r) => parseInt(r, 10) || 0);
    if (n.push(0), !(n[0] === 1 && n[1] < 5)) {
      if (n[0] === 1 && n[1] < 6)
        return "Cupcake";
      if (n[0] === 1 && n[1] >= 6)
        return "Donut";
      if (n[0] === 2 && n[1] < 2)
        return "Eclair";
      if (n[0] === 2 && n[1] === 2)
        return "Froyo";
      if (n[0] === 2 && n[1] > 2)
        return "Gingerbread";
      if (n[0] === 3)
        return "Honeycomb";
      if (n[0] === 4 && n[1] < 1)
        return "Ice Cream Sandwich";
      if (n[0] === 4 && n[1] < 4)
        return "Jelly Bean";
      if (n[0] === 4 && n[1] >= 4)
        return "KitKat";
      if (n[0] === 5)
        return "Lollipop";
      if (n[0] === 6)
        return "Marshmallow";
      if (n[0] === 7)
        return "Nougat";
      if (n[0] === 8)
        return "Oreo";
      if (n[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(t) {
    return t.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(t, n, r = !1) {
    const a = se.getVersionPrecision(t), i = se.getVersionPrecision(n);
    let s = Math.max(a, i), o = 0;
    const u = se.map([t, n], (V) => {
      const c = s - se.getVersionPrecision(V), f = V + new Array(c + 1).join(".0");
      return se.map(f.split("."), (p) => new Array(20 - p.length).join("0") + p).reverse();
    });
    for (r && (o = s - Math.min(a, i)), s -= 1; s >= o; ) {
      if (u[0][s] > u[1][s])
        return 1;
      if (u[0][s] === u[1][s]) {
        if (s === o)
          return 0;
        s -= 1;
      } else if (u[0][s] < u[1][s])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(t, n) {
    const r = [];
    let a;
    if (Array.prototype.map)
      return Array.prototype.map.call(t, n);
    for (a = 0; a < t.length; a += 1)
      r.push(n(t[a]));
    return r;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(t, n) {
    let r, a;
    if (Array.prototype.find)
      return Array.prototype.find.call(t, n);
    for (r = 0, a = t.length; r < a; r += 1) {
      const i = t[r];
      if (n(i, r))
        return i;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(t, ...n) {
    const r = t;
    let a, i;
    if (Object.assign)
      return Object.assign(t, ...n);
    for (a = 0, i = n.length; a < i; a += 1) {
      const s = n[a];
      typeof s == "object" && s !== null && Object.keys(s).forEach((u) => {
        r[u] = s[u];
      });
    }
    return t;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(t) {
    return Zy[t];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(t) {
    return Ip[t] || "";
  }
}
const Tt = /version\/(\d+(\.?_?\d+)+)/i, Qy = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(e) {
      const t = {
        name: "Googlebot"
      }, n = se.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(e) {
      const t = {
        name: "Opera"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(e) {
      const t = {
        name: "Opera"
      }, n = se.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(e) {
      const t = {
        name: "Samsung Internet for Android"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/Whale/i],
    describe(e) {
      const t = {
        name: "NAVER Whale Browser"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(e) {
      const t = {
        name: "MZ Browser"
      }, n = se.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/focus/i],
    describe(e) {
      const t = {
        name: "Focus"
      }, n = se.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/swing/i],
    describe(e) {
      const t = {
        name: "Swing"
      }, n = se.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/coast/i],
    describe(e) {
      const t = {
        name: "Opera Coast"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(e) {
      const t = {
        name: "Opera Touch"
      }, n = se.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/yabrowser/i],
    describe(e) {
      const t = {
        name: "Yandex Browser"
      }, n = se.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(e) {
      const t = {
        name: "UC Browser"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(e) {
      const t = {
        name: "Maxthon"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/epiphany/i],
    describe(e) {
      const t = {
        name: "Epiphany"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/puffin/i],
    describe(e) {
      const t = {
        name: "Puffin"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/sleipnir/i],
    describe(e) {
      const t = {
        name: "Sleipnir"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/k-meleon/i],
    describe(e) {
      const t = {
        name: "K-Meleon"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/micromessenger/i],
    describe(e) {
      const t = {
        name: "WeChat"
      }, n = se.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(e) {
      const t = {
        name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
      }, n = se.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/msie|trident/i],
    describe(e) {
      const t = {
        name: "Internet Explorer"
      }, n = se.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/\sedg\//i],
    describe(e) {
      const t = {
        name: "Microsoft Edge"
      }, n = se.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(e) {
      const t = {
        name: "Microsoft Edge"
      }, n = se.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/vivaldi/i],
    describe(e) {
      const t = {
        name: "Vivaldi"
      }, n = se.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/seamonkey/i],
    describe(e) {
      const t = {
        name: "SeaMonkey"
      }, n = se.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/sailfish/i],
    describe(e) {
      const t = {
        name: "Sailfish"
      }, n = se.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/silk/i],
    describe(e) {
      const t = {
        name: "Amazon Silk"
      }, n = se.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/phantom/i],
    describe(e) {
      const t = {
        name: "PhantomJS"
      }, n = se.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/slimerjs/i],
    describe(e) {
      const t = {
        name: "SlimerJS"
      }, n = se.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(e) {
      const t = {
        name: "BlackBerry"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(e) {
      const t = {
        name: "WebOS Browser"
      }, n = se.getFirstMatch(Tt, e) || se.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/bada/i],
    describe(e) {
      const t = {
        name: "Bada"
      }, n = se.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/tizen/i],
    describe(e) {
      const t = {
        name: "Tizen"
      }, n = se.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/qupzilla/i],
    describe(e) {
      const t = {
        name: "QupZilla"
      }, n = se.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(e) {
      const t = {
        name: "Firefox"
      }, n = se.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/electron/i],
    describe(e) {
      const t = {
        name: "Electron"
      }, n = se.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(e) {
      const t = {
        name: "Miui"
      }, n = se.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/chromium/i],
    describe(e) {
      const t = {
        name: "Chromium"
      }, n = se.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(e) {
      const t = {
        name: "Chrome"
      }, n = se.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  {
    test: [/GSA/i],
    describe(e) {
      const t = {
        name: "Google Search"
      }, n = se.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  /* Android Browser */
  {
    test(e) {
      const t = !e.test(/like android/i), n = e.test(/android/i);
      return t && n;
    },
    describe(e) {
      const t = {
        name: "Android Browser"
      }, n = se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(e) {
      const t = {
        name: "PlayStation 4"
      }, n = se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(e) {
      const t = {
        name: "Safari"
      }, n = se.getFirstMatch(Tt, e);
      return n && (t.version = n), t;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(e) {
      const t = /^(.*)\/(.*) /, n = /^(.*)\/(.*)[ \t]\((.*)/, a = e.search("\\(") !== -1 ? n : t;
      return {
        name: se.getFirstMatch(a, e),
        version: se.getSecondMatch(a, e)
      };
    }
  }
], Jy = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(e) {
      const t = se.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
      return {
        name: Sn.Roku,
        version: t
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(e) {
      const t = se.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
      return {
        name: Sn.WindowsPhone,
        version: t
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(e) {
      const t = se.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e), n = se.getWindowsVersionName(t);
      return {
        name: Sn.Windows,
        version: t,
        versionName: n
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(e) {
      const t = {
        name: Sn.iOS
      }, n = se.getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
      return n && (t.version = n), t;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(e) {
      const t = se.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."), n = se.getMacOSVersionName(t), r = {
        name: Sn.MacOS,
        version: t
      };
      return n && (r.versionName = n), r;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(e) {
      const t = se.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
      return {
        name: Sn.iOS,
        version: t
      };
    }
  },
  /* Android */
  {
    test(e) {
      const t = !e.test(/like android/i), n = e.test(/android/i);
      return t && n;
    },
    describe(e) {
      const t = se.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e), n = se.getAndroidVersionName(t), r = {
        name: Sn.Android,
        version: t
      };
      return n && (r.versionName = n), r;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(e) {
      const t = se.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e), n = {
        name: Sn.WebOS
      };
      return t && t.length && (n.version = t), n;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(e) {
      const t = se.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || se.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || se.getFirstMatch(/\bbb(\d+)/i, e);
      return {
        name: Sn.BlackBerry,
        version: t
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(e) {
      const t = se.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
      return {
        name: Sn.Bada,
        version: t
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(e) {
      const t = se.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
      return {
        name: Sn.Tizen,
        version: t
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: Sn.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: Sn.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(e) {
      const t = se.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
      return {
        name: Sn.PlayStation4,
        version: t
      };
    }
  }
], e2 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(e) {
      const t = se.getFirstMatch(/(can-l01)/i, e) && "Nova", n = {
        type: jt.mobile,
        vendor: "Huawei"
      };
      return t && (n.model = t), n;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: jt.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: jt.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: jt.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: jt.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: jt.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: jt.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(e) {
      const t = e.test(/ipod|iphone/i), n = e.test(/like (ipod|iphone)/i);
      return t && !n;
    },
    describe(e) {
      const t = se.getFirstMatch(/(ipod|iphone)/i, e);
      return {
        type: jt.mobile,
        vendor: "Apple",
        model: t
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: jt.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: jt.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(e) {
      return e.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: jt.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(e) {
      return e.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: jt.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(e) {
      return e.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: jt.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(e) {
      const t = Number(String(e.getOSVersion()).split(".")[0]);
      return e.getOSName(!0) === "android" && t >= 3;
    },
    describe() {
      return {
        type: jt.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(e) {
      return e.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: jt.mobile
      };
    }
  },
  /* desktop */
  {
    test(e) {
      return e.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: jt.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(e) {
      return e.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: jt.desktop
      };
    }
  },
  /* Linux */
  {
    test(e) {
      return e.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: jt.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(e) {
      return e.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: jt.tv
      };
    }
  },
  /* Roku */
  {
    test(e) {
      return e.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: jt.tv
      };
    }
  }
], t2 = [
  /* EdgeHTML */
  {
    test(e) {
      return e.getBrowserName(!0) === "microsoft edge";
    },
    describe(e) {
      if (/\sedg\//i.test(e))
        return {
          name: la.Blink
        };
      const n = se.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
      return {
        name: la.EdgeHTML,
        version: n
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(e) {
      const t = {
        name: la.Trident
      }, n = se.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  /* Presto */
  {
    test(e) {
      return e.test(/presto/i);
    },
    describe(e) {
      const t = {
        name: la.Presto
      }, n = se.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  /* Gecko */
  {
    test(e) {
      const t = e.test(/gecko/i), n = e.test(/like gecko/i);
      return t && !n;
    },
    describe(e) {
      const t = {
        name: la.Gecko
      }, n = se.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: la.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(e) {
      const t = {
        name: la.WebKit
      }, n = se.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
      return n && (t.version = n), t;
    }
  }
];
let gh = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(t, n = !1) {
    if (t == null || t === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = t, this.parsedResult = {}, n !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(t) {
    return t.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const t = se.find(Qy, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(t) {
    return t ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const t = se.find(Jy, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(t) {
    const { name: n } = this.getOS();
    return t ? String(n).toLowerCase() || "" : n || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(t = !1) {
    const { type: n } = this.getPlatform();
    return t ? String(n).toLowerCase() || "" : n || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const t = se.find(e2, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(t) {
    return t ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const t = se.find(t2, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return se.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(t) {
    const n = {};
    let r = 0;
    const a = {};
    let i = 0;
    if (Object.keys(t).forEach((o) => {
      const u = t[o];
      typeof u == "string" ? (a[o] = u, i += 1) : typeof u == "object" && (n[o] = u, r += 1);
    }), r > 0) {
      const o = Object.keys(n), u = se.find(o, (c) => this.isOS(c));
      if (u) {
        const c = this.satisfies(n[u]);
        if (c !== void 0)
          return c;
      }
      const V = se.find(
        o,
        (c) => this.isPlatform(c)
      );
      if (V) {
        const c = this.satisfies(n[V]);
        if (c !== void 0)
          return c;
      }
    }
    if (i > 0) {
      const o = Object.keys(a), u = se.find(o, (V) => this.isBrowser(V, !0));
      if (u !== void 0)
        return this.compareVersion(a[u]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(t, n = !1) {
    const r = this.getBrowserName().toLowerCase();
    let a = t.toLowerCase();
    const i = se.getBrowserTypeByAlias(a);
    return n && i && (a = i.toLowerCase()), a === r;
  }
  compareVersion(t) {
    let n = [0], r = t, a = !1;
    const i = this.getBrowserVersion();
    if (typeof i == "string")
      return t[0] === ">" || t[0] === "<" ? (r = t.substr(1), t[1] === "=" ? (a = !0, r = t.substr(2)) : n = [], t[0] === ">" ? n.push(1) : n.push(-1)) : t[0] === "=" ? r = t.substr(1) : t[0] === "~" && (a = !0, r = t.substr(1)), n.indexOf(
        se.compareVersions(i, r, a)
      ) > -1;
  }
  isOS(t) {
    return this.getOSName(!0) === String(t).toLowerCase();
  }
  isPlatform(t) {
    return this.getPlatformType(!0) === String(t).toLowerCase();
  }
  isEngine(t) {
    return this.getEngineName(!0) === String(t).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(t, n = !1) {
    return this.isBrowser(t, n) || this.isOS(t) || this.isPlatform(t);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(t = []) {
    return t.some((n) => this.is(n));
  }
};
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class n2 {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(t, n = !1) {
    if (typeof t != "string")
      throw new Error("UserAgent should be a string");
    return new gh(t, n);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(t) {
    return new gh(t).getResult();
  }
  static get BROWSER_MAP() {
    return Ip;
  }
  static get ENGINE_MAP() {
    return la;
  }
  static get OS_MAP() {
    return Sn;
  }
  static get PLATFORMS_MAP() {
    return jt;
  }
}
var vt = /* @__PURE__ */ ((e) => (e.ASSISTANT_INFO = "vfrc-assistant-info", e.AVATAR = "vfrc-avatar", e.BUBBLE = "vfrc-bubble", e.BUTTON = "vfrc-button", e.CARD = "vfrc-card", e.CAROUSEL = "vfrc-carousel", e.CHAT = "vfrc-chat", e.CHAT_INPUT = "vfrc-chat-input", e.FEEDBACK = "vfrc-feedback", e.FOOTER = "vfrc-footer", e.HEADER = "vfrc-header", e.ICON = "vfrc-icon", e.IMAGE = "vfrc-image", e.INPUT = "vfrc-input", e.LAUNCHER = "vfrc-launcher", e.LOADER = "vfrc-loader", e.MESSAGE = "vfrc-message", e.PROMPT = "vfrc-prompt", e.SYSTEM_RESPONSE = "vfrc-system-response", e.TIMESTAMP = "vfrc-timestamp", e.TOOLTIP = "vfrc-tooltip", e.TYPING_INDICATOR = "vfrc-typing-indicator", e.USER_RESPONSE = "vfrc-user-response", e.WIDGET = "vfrc-widget", e.PROACTIVE_CLOSE = "vfrc-proactive-close", e.PROACTIVE_MESSAGE = "vfrc-proactive-message", e.PROACTIVE = "vfrc-proactive", e))(vt || {});
const Qc = n2.parse(window.navigator.userAgent);
function Rp(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number")
    r += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = Rp(e[t])) && (r && (r += " "), r += n);
    else
      for (t in e)
        e[t] && (r && (r += " "), r += t);
  return r;
}
function r2() {
  for (var e, t, n = 0, r = ""; n < arguments.length; )
    (e = arguments[n++]) && (t = Rp(e)) && (r && (r += " "), r += t);
  return r;
}
const _t = (e) => (t, n) => Wc(
  (r, a) => qc(t, {
    ...r,
    ref: a,
    className: r2(n ? `${e}--${n}` : e, r.className)
  })
);
var Et = "colors", _n = "sizes", Ce = "space", a2 = { gap: Ce, gridGap: Ce, columnGap: Ce, gridColumnGap: Ce, rowGap: Ce, gridRowGap: Ce, inset: Ce, insetBlock: Ce, insetBlockEnd: Ce, insetBlockStart: Ce, insetInline: Ce, insetInlineEnd: Ce, insetInlineStart: Ce, margin: Ce, marginTop: Ce, marginRight: Ce, marginBottom: Ce, marginLeft: Ce, marginBlock: Ce, marginBlockEnd: Ce, marginBlockStart: Ce, marginInline: Ce, marginInlineEnd: Ce, marginInlineStart: Ce, padding: Ce, paddingTop: Ce, paddingRight: Ce, paddingBottom: Ce, paddingLeft: Ce, paddingBlock: Ce, paddingBlockEnd: Ce, paddingBlockStart: Ce, paddingInline: Ce, paddingInlineEnd: Ce, paddingInlineStart: Ce, top: Ce, right: Ce, bottom: Ce, left: Ce, scrollMargin: Ce, scrollMarginTop: Ce, scrollMarginRight: Ce, scrollMarginBottom: Ce, scrollMarginLeft: Ce, scrollMarginX: Ce, scrollMarginY: Ce, scrollMarginBlock: Ce, scrollMarginBlockEnd: Ce, scrollMarginBlockStart: Ce, scrollMarginInline: Ce, scrollMarginInlineEnd: Ce, scrollMarginInlineStart: Ce, scrollPadding: Ce, scrollPaddingTop: Ce, scrollPaddingRight: Ce, scrollPaddingBottom: Ce, scrollPaddingLeft: Ce, scrollPaddingX: Ce, scrollPaddingY: Ce, scrollPaddingBlock: Ce, scrollPaddingBlockEnd: Ce, scrollPaddingBlockStart: Ce, scrollPaddingInline: Ce, scrollPaddingInlineEnd: Ce, scrollPaddingInlineStart: Ce, fontSize: "fontSizes", background: Et, backgroundColor: Et, backgroundImage: Et, borderImage: Et, border: Et, borderBlock: Et, borderBlockEnd: Et, borderBlockStart: Et, borderBottom: Et, borderBottomColor: Et, borderColor: Et, borderInline: Et, borderInlineEnd: Et, borderInlineStart: Et, borderLeft: Et, borderLeftColor: Et, borderRight: Et, borderRightColor: Et, borderTop: Et, borderTopColor: Et, caretColor: Et, color: Et, columnRuleColor: Et, fill: Et, outline: Et, outlineColor: Et, stroke: Et, textDecorationColor: Et, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: _n, minBlockSize: _n, maxBlockSize: _n, inlineSize: _n, minInlineSize: _n, maxInlineSize: _n, width: _n, minWidth: _n, maxWidth: _n, height: _n, minHeight: _n, maxHeight: _n, flexBasis: _n, gridTemplateColumns: _n, gridTemplateRows: _n, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" }, { parse: AU, stringify: i2 } = JSON, s2 = String, o2 = (e, t) => t, bh = (e, t, n) => {
  const r = s2(t.push(n) - 1);
  return e.set(n, r), r;
}, u2 = (e, t, n) => {
  const r = t && typeof t == "object" ? (c, f) => c === "" || -1 < t.indexOf(c) ? f : void 0 : t || o2, a = /* @__PURE__ */ new Map(), i = [], s = [];
  let o = +bh(a, i, r.call({ "": e }, "", e)), u = !o;
  for (; o < i.length; )
    u = !0, s[o] = i2(i[o++], V, n);
  return "[" + s.join(",") + "]";
  function V(c, f) {
    if (u)
      return u = !u, f;
    const p = r.call(this, c, f);
    switch (typeof p) {
      case "object":
        if (p === null)
          return p;
      case "string":
        return a.get(p) || bh(a, i, p);
    }
    return p;
  }
}, Bi = () => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t, n, ...r) => {
    const a = ((i) => u2(i))(t);
    return a in e ? e[a] : e[a] = n(t, ...r);
  };
}, $a = Symbol.for("sxs.internal"), Jc = (e, t) => Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)), Ah = (e) => {
  for (const t in e)
    return !0;
  return !1;
}, { hasOwnProperty: V2 } = Object.prototype, JV = (e) => e.includes("-") ? e : e.replace(/[A-Z]/g, (t) => "-" + t.toLowerCase()), l2 = /\s+(?![^()]*\))/, Ai = (e) => (t) => e(...typeof t == "string" ? String(t).split(l2) : [t]), Eh = { appearance: (e) => ({ WebkitAppearance: e, appearance: e }), backfaceVisibility: (e) => ({ WebkitBackfaceVisibility: e, backfaceVisibility: e }), backdropFilter: (e) => ({ WebkitBackdropFilter: e, backdropFilter: e }), backgroundClip: (e) => ({ WebkitBackgroundClip: e, backgroundClip: e }), boxDecorationBreak: (e) => ({ WebkitBoxDecorationBreak: e, boxDecorationBreak: e }), clipPath: (e) => ({ WebkitClipPath: e, clipPath: e }), content: (e) => ({ content: e.includes('"') || e.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e) ? e : `"${e}"` }), hyphens: (e) => ({ WebkitHyphens: e, hyphens: e }), maskImage: (e) => ({ WebkitMaskImage: e, maskImage: e }), maskSize: (e) => ({ WebkitMaskSize: e, maskSize: e }), textSizeAdjust: (e) => ({ WebkitTextSizeAdjust: e, textSizeAdjust: e }), userSelect: (e) => ({ WebkitUserSelect: e, userSelect: e }), marginBlock: Ai((e, t) => ({ marginBlockStart: e, marginBlockEnd: t || e })), marginInline: Ai((e, t) => ({ marginInlineStart: e, marginInlineEnd: t || e })), maxSize: Ai((e, t) => ({ maxBlockSize: e, maxInlineSize: t || e })), minSize: Ai((e, t) => ({ minBlockSize: e, minInlineSize: t || e })), paddingBlock: Ai((e, t) => ({ paddingBlockStart: e, paddingBlockEnd: t || e })), paddingInline: Ai((e, t) => ({ paddingInlineStart: e, paddingInlineEnd: t || e })) }, EV = /([\d.]+)([^]*)/, c2 = (e, t) => e.length ? e.reduce((n, r) => (n.push(...t.map((a) => a.includes("&") ? a.replace(/&/g, /[ +>|~]/.test(r) && /&.*&/.test(a) ? `:is(${r})` : r) : r + " " + a)), n), []) : t, f2 = (e, t) => e in d2 && typeof t == "string" ? t.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (n, r, a, i) => r + (a === "stretch" ? `-moz-available${i};${JV(e)}:${r}-webkit-fill-available` : `-moz-fit-content${i};${JV(e)}:${r}fit-content`) + i) : String(t), d2 = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 }, Xr = (e) => e ? e + "-" : "", Np = (e, t, n) => e.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (r, a, i, s, o) => s == "$" == !!i ? r : (a || s == "--" ? "calc(" : "") + "var(--" + (s === "$" ? Xr(t) + (o.includes("$") ? "" : Xr(n)) + o.replace(/\$/g, "-") : o) + ")" + (a || s == "--" ? "*" + (a || "") + (i || "1") + ")" : "")), h2 = /\s*,\s*(?![^()]*\))/, m2 = Object.prototype.toString, Ci = (e, t, n, r, a) => {
  let i, s, o;
  const u = (V, c, f) => {
    let p, h;
    const g = (b) => {
      for (p in b) {
        const E = p.charCodeAt(0) === 64, S = E && Array.isArray(b[p]) ? b[p] : [b[p]];
        for (h of S) {
          const $ = /[A-Z]/.test(x = p) ? x : x.replace(/-[^]/g, (y) => y[1].toUpperCase()), U = typeof h == "object" && h && h.toString === m2 && (!r.utils[$] || !c.length);
          if ($ in r.utils && !U) {
            const y = r.utils[$];
            if (y !== s) {
              s = y, g(y(h)), s = null;
              continue;
            }
          } else if ($ in Eh) {
            const y = Eh[$];
            if (y !== o) {
              o = y, g(y(h)), o = null;
              continue;
            }
          }
          if (E && (v = p.slice(1) in r.media ? "@media " + r.media[p.slice(1)] : p, p = v.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (y, j, q, Q, I, ie) => {
            const z = EV.test(j), H = 0.0625 * (z ? -1 : 1), [P, N] = z ? [Q, j] : [j, Q];
            return "(" + (q[0] === "=" ? "" : q[0] === ">" === z ? "max-" : "min-") + P + ":" + (q[0] !== "=" && q.length === 1 ? N.replace(EV, (K, D, J) => Number(D) + H * (q === ">" ? 1 : -1) + J) : N) + (I ? ") and (" + (I[0] === ">" ? "min-" : "max-") + P + ":" + (I.length === 1 ? ie.replace(EV, (K, D, J) => Number(D) + H * (I === ">" ? -1 : 1) + J) : ie) : "") + ")";
          })), U) {
            const y = E ? f.concat(p) : [...f], j = E ? [...c] : c2(c, p.split(h2));
            i !== void 0 && a(vh(...i)), i = void 0, u(h, j, y);
          } else
            i === void 0 && (i = [[], c, f]), p = E || p.charCodeAt(0) !== 36 ? p : `--${Xr(r.prefix)}${p.slice(1).replace(/\$/g, "-")}`, h = U ? h : typeof h == "number" ? h && !($ in p2) && p.charCodeAt(0) !== 45 ? String(h) + "px" : String(h) : Np(f2($, h ?? ""), r.prefix, r.themeMap[$]), i[0].push(`${E ? `${p} ` : `${JV(p)}:`}${h}`);
        }
      }
      var v, x;
    };
    g(V), i !== void 0 && a(vh(...i)), i = void 0;
  };
  u(e, t, n);
}, vh = (e, t, n) => `${n.map((r) => `${r}{`).join("")}${t.length ? `${t.join(",")}{` : ""}${e.join(";")}${t.length ? "}" : ""}${Array(n.length ? n.length + 1 : 0).join("}")}`, p2 = { animationIterationCount: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }, Th = (e) => String.fromCharCode(e + (e > 25 ? 39 : 97)), Ua = (e) => ((t) => {
  let n, r = "";
  for (n = Math.abs(t); n > 52; n = n / 52 | 0)
    r = Th(n % 52) + r;
  return Th(n % 52) + r;
})(((t, n) => {
  let r = n.length;
  for (; r; )
    t = 33 * t ^ n.charCodeAt(--r);
  return t;
})(5381, JSON.stringify(e)) >>> 0), Si = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"], g2 = (e) => {
  if (e.href && !e.href.startsWith(location.origin))
    return !1;
  try {
    return !!e.cssRules;
  } catch {
    return !1;
  }
}, b2 = (e) => {
  let t;
  const n = () => {
    const { cssRules: a } = t.sheet;
    return [].map.call(a, (i, s) => {
      const { cssText: o } = i;
      let u = "";
      if (o.startsWith("--sxs"))
        return "";
      if (a[s - 1] && (u = a[s - 1].cssText).startsWith("--sxs")) {
        if (!i.cssRules.length)
          return "";
        for (const V in t.rules)
          if (t.rules[V].group === i)
            return `--sxs{--sxs:${[...t.rules[V].cache].join(" ")}}${o}`;
        return i.cssRules.length ? `${u}${o}` : "";
      }
      return o;
    }).join("");
  }, r = () => {
    if (t) {
      const { rules: o, sheet: u } = t;
      if (!u.deleteRule) {
        for (; Object(Object(u.cssRules)[0]).type === 3; )
          u.cssRules.splice(0, 1);
        u.cssRules = [];
      }
      for (const V in o)
        delete o[V];
    }
    const a = Object(e).styleSheets || [];
    for (const o of a)
      if (g2(o)) {
        for (let u = 0, V = o.cssRules; V[u]; ++u) {
          const c = Object(V[u]);
          if (c.type !== 1)
            continue;
          const f = Object(V[u + 1]);
          if (f.type !== 4)
            continue;
          ++u;
          const { cssText: p } = c;
          if (!p.startsWith("--sxs"))
            continue;
          const h = p.slice(14, -3).trim().split(/\s+/), g = Si[h[0]];
          g && (t || (t = { sheet: o, reset: r, rules: {}, toString: n }), t.rules[g] = { group: f, index: u, cache: new Set(h) });
        }
        if (t)
          break;
      }
    if (!t) {
      const o = (u, V) => ({ type: V, cssRules: [], insertRule(c, f) {
        this.cssRules.splice(f, 0, o(c, { import: 3, undefined: 1 }[(c.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return u === "@media{}" ? `@media{${[].map.call(this.cssRules, (c) => c.cssText).join("")}}` : u;
      } });
      t = { sheet: (() => {
        if (!e)
          return o("", "text/css");
        const u = document.createElement("style"), V = window.__webpack_nonce__ !== void 0 ? window.__webpack_nonce__ : window.nonce !== void 0 ? window.nonce : null;
        return V && u.setAttribute("nonce", V), (e.head || e).appendChild(u).sheet;
      })(), rules: {}, reset: r, toString: n };
    }
    const { sheet: i, rules: s } = t;
    for (let o = Si.length - 1; o >= 0; --o) {
      const u = Si[o];
      if (!s[u]) {
        const V = Si[o + 1], c = s[V] ? s[V].index : i.cssRules.length;
        i.insertRule("@media{}", c), i.insertRule(`--sxs{--sxs:${o}}`, c), s[u] = { group: i.cssRules[c + 1], index: c, cache: /* @__PURE__ */ new Set([o]) };
      }
      A2(s[u]);
    }
  };
  return r(), t;
}, A2 = (e) => {
  let t = e.group.cssRules.length;
  e.apply = (n) => {
    try {
      e.group.insertRule(n, t), ++t;
    } catch {
    }
  };
}, us = Symbol(), E2 = Bi(), yh = (e, t) => E2(e, () => {
  const n = (a, i = {}) => {
    let s = { type: null, composers: /* @__PURE__ */ new Set() };
    for (const o of a)
      if (o != null)
        if (o[$a]) {
          s.type == null && (s.type = o[$a].type);
          for (const u of o[$a].composers)
            s.composers.add(u);
        } else
          o.constructor !== Object || o.$$typeof ? s.type == null && (s.type = o) : s.composers.add(v2(o, e, i));
    return s.type == null && (s.type = "span"), s.composers.size || s.composers.add(["PJLV", {}, [], [], {}, []]), T2(e, s, t, i);
  }, r = (...a) => n(a);
  return r.withConfig = (a) => (...i) => n(i, a), r;
}), v2 = ({ variants: e, compoundVariants: t, defaultVariants: n, ...r }, a, { componentId: i, displayName: s }) => {
  const o = i || Ua(r), u = s ? "c-" + s : "c", V = `${Xr(a.prefix)}${u}-${o}`, c = [], f = [], p = /* @__PURE__ */ Object.create(null), h = [];
  for (const v in n)
    p[v] = String(n[v]);
  if (typeof e == "object" && e)
    for (const v in e) {
      g = p, b = v, V2.call(g, b) || (p[v] = "undefined");
      const x = e[v];
      for (const E in x) {
        const S = { [v]: String(E) };
        String(E) === "undefined" && h.push(v);
        const $ = x[E], U = [S, $, !Ah($)];
        c.push(U);
      }
    }
  var g, b;
  if (typeof t == "object" && t)
    for (const v of t) {
      let { css: x, ...E } = v;
      x = typeof x == "object" && x || {};
      for (const $ in E)
        E[$] = String(E[$]);
      const S = [E, x, !Ah(x)];
      f.push(S);
    }
  return [V, r, c, f, p, h];
}, T2 = (e, t, n, { shouldForwardStitchesProp: r }) => {
  const [a, i, s, o] = y2(t.composers), u = typeof t.type == "function" || t.type.$$typeof ? ((p) => {
    function h() {
      for (let g = 0; g < h[us].length; g++) {
        const [b, v] = h[us][g];
        p.rules[b].apply(v);
      }
      return h[us] = [], null;
    }
    return h[us] = [], h.rules = {}, Si.forEach((g) => h.rules[g] = { apply: (b) => h[us].push([g, b]) }), h;
  })(n) : null, V = (u || n).rules, c = `.${a}${i.length > 1 ? `:where(.${i.slice(1).join(".")})` : ""}`, f = (p) => {
    p = typeof p == "object" && p || _2;
    const { ...h } = p, g = {};
    for (const E in s)
      if (E in p) {
        r != null && r(E) || delete h[E];
        let S = p[E];
        typeof S == "object" && S ? g[E] = { "@initial": s[E], ...S } : (S = String(S), g[E] = S !== "undefined" || o.has(E) ? S : s[E]);
      } else
        g[E] = s[E];
    const b = /* @__PURE__ */ new Set([...i]);
    for (const [E, S, $, U] of t.composers) {
      n.rules.styled.cache.has(E) || (n.rules.styled.cache.add(E), Ci(S, [`.${E}`], [], e, (q) => {
        V.styled.apply(q);
      }));
      const y = _h($, g, e.media), j = _h(U, g, e.media, !0);
      for (const q of y)
        if (q !== void 0)
          for (const [Q, I, ie] of q) {
            const z = `${E}-${Ua(I)}-${Q}`;
            b.add(z);
            const H = (ie ? n.rules.resonevar : n.rules.onevar).cache, P = ie ? V.resonevar : V.onevar;
            H.has(z) || (H.add(z), Ci(I, [`.${z}`], [], e, (N) => {
              P.apply(N);
            }));
          }
      for (const q of j)
        if (q !== void 0)
          for (const [Q, I] of q) {
            const ie = `${E}-${Ua(I)}-${Q}`;
            b.add(ie), n.rules.allvar.cache.has(ie) || (n.rules.allvar.cache.add(ie), Ci(I, [`.${ie}`], [], e, (z) => {
              V.allvar.apply(z);
            }));
          }
    }
    const v = h.css;
    if (typeof v == "object" && v) {
      r != null && r("css") || delete h.css;
      const E = `${a}-i${Ua(v)}-css`;
      b.add(E), n.rules.inline.cache.has(E) || (n.rules.inline.cache.add(E), Ci(v, [`.${E}`], [], e, (S) => {
        V.inline.apply(S);
      }));
    }
    for (const E of String(p.className || "").trim().split(/\s+/))
      E && b.add(E);
    const x = h.className = [...b].join(" ");
    return { type: t.type, className: x, selector: c, props: h, toString: () => x, deferredInjector: u };
  };
  return Jc(f, { className: a, selector: c, [$a]: t, toString: () => (n.rules.styled.cache.has(a) || f(), a) });
}, y2 = (e) => {
  let t = "";
  const n = [], r = {}, a = [];
  for (const [i, , , , s, o] of e) {
    t === "" && (t = i), n.push(i), a.push(...o);
    for (const u in s) {
      const V = s[u];
      (r[u] === void 0 || V !== "undefined" || o.includes(V)) && (r[u] = V);
    }
  }
  return [t, n, r, new Set(a)];
}, _h = (e, t, n, r) => {
  const a = [];
  e:
    for (let [i, s, o] of e) {
      if (o)
        continue;
      let u, V = 0, c = !1;
      for (u in i) {
        const f = i[u];
        let p = t[u];
        if (p !== f) {
          if (typeof p != "object" || !p)
            continue e;
          {
            let h, g, b = 0;
            for (const v in p) {
              if (f === String(p[v])) {
                if (v !== "@initial") {
                  const x = v.slice(1);
                  (g = g || []).push(x in n ? n[x] : v.replace(/^@media ?/, "")), c = !0;
                }
                V += b, h = !0;
              }
              ++b;
            }
            if (g && g.length && (s = { ["@media " + g.join(", ")]: s }), !h)
              continue e;
          }
        }
      }
      (a[V] = a[V] || []).push([r ? "cv" : `${u}-${i[u]}`, s, c]);
    }
  return a;
}, _2 = {}, C2 = Bi(), S2 = (e, t) => C2(e, () => (...n) => {
  const r = () => {
    for (let a of n) {
      a = typeof a == "object" && a || {};
      let i = Ua(a);
      if (!t.rules.global.cache.has(i)) {
        if (t.rules.global.cache.add(i), "@import" in a) {
          let s = [].indexOf.call(t.sheet.cssRules, t.rules.themed.group) - 1;
          for (let o of [].concat(a["@import"]))
            o = o.includes('"') || o.includes("'") ? o : `"${o}"`, t.sheet.insertRule(`@import ${o};`, s++);
          delete a["@import"];
        }
        Ci(a, [], [], e, (s) => {
          t.rules.global.apply(s);
        });
      }
    }
    return "";
  };
  return Jc(r, { toString: r });
}), x2 = Bi(), O2 = (e, t) => x2(e, () => (n) => {
  const r = `${Xr(e.prefix)}k-${Ua(n)}`, a = () => {
    if (!t.rules.global.cache.has(r)) {
      t.rules.global.cache.add(r);
      const i = [];
      Ci(n, [], [], e, (o) => i.push(o));
      const s = `@keyframes ${r}{${i.join("")}}`;
      t.rules.global.apply(s);
    }
    return r;
  };
  return Jc(a, { get name() {
    return a();
  }, toString: a });
}), w2 = class {
  constructor(t, n, r, a) {
    this.token = t == null ? "" : String(t), this.value = n == null ? "" : String(n), this.scale = r == null ? "" : String(r), this.prefix = a == null ? "" : String(a);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + Xr(this.prefix) + Xr(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
}, I2 = Bi(), R2 = (e, t, n) => I2(e, () => (r, a) => {
  a = typeof r == "object" && r || Object(a);
  const i = `.${r = (r = typeof r == "string" ? r : "") || `${Xr(e.prefix)}t-${Ua(a)}`}`, s = {}, o = [];
  for (const V in a) {
    s[V] = {};
    for (const c in a[V]) {
      const f = `--${Xr(e.prefix)}${V}-${c}`, p = Np(String(a[V][c]), e.prefix, V);
      s[V][c] = new w2(c, p, V, e.prefix), o.push(`${f}:${p}`);
    }
  }
  const u = () => {
    if (o.length && !t.rules.themed.cache.has(r)) {
      t.rules.themed.cache.add(r);
      const V = () => n ? ":host," : ":root,", c = `${a === e.theme ? V() : ""}.${r}{${o.join(";")}}`;
      t.rules.themed.apply(c);
    }
    return r;
  };
  return { ...s, get className() {
    return u();
  }, selector: i, toString: u };
}), N2 = Bi(), k2 = Bi(), L2 = (e, t = !0) => {
  const n = ((r, a = !0) => {
    let i = !1;
    const s = N2(r, (o) => {
      i = !0;
      const u = "prefix" in (o = typeof o == "object" && o || {}) ? String(o.prefix) : "", V = typeof o.media == "object" && o.media || {}, c = typeof o.root == "object" ? o.root || null : globalThis.document || null, f = typeof o.theme == "object" && o.theme || {}, p = { prefix: u, media: V, theme: f, themeMap: typeof o.themeMap == "object" && o.themeMap || { ...a2 }, utils: typeof o.utils == "object" && o.utils || {} }, h = b2(c), g = { css: yh(p, h), globalCss: S2(p, h), keyframes: O2(p, h), createTheme: R2(p, h, a), reset() {
        h.reset(), g.theme.toString();
      }, transplant(b) {
        const { cssRules: v, ownerNode: x } = h.sheet, E = b.appendChild(x);
        Array.from(v).forEach((S, $) => {
          E.sheet.insertRule(S.cssText, $);
        }), Si.forEach((S, $) => {
          h.rules[S].group = E.sheet.cssRules[2 * $ + 1];
        });
      }, theme: {}, sheet: h, config: p, prefix: u, getCssText: h.toString, toString: h.toString };
      return String(g.theme = g.createTheme(f)), g;
    });
    return i || s.reset(), s;
  })(e, t);
  return n.styled = (({ config: r, sheet: a }) => k2(r, () => {
    const i = yh(r, a), s = (u, V = i, { displayName: c, shouldForwardStitchesProp: f } = {}) => {
      const p = V(...u), h = p[$a].type, g = f == null ? void 0 : f("as"), b = dn.forwardRef((v, x) => {
        const E = v != null && v.as && !g ? v == null ? void 0 : v.as : h, { props: S, deferredInjector: $ } = p(v);
        return g || delete S.as, S.ref = x, $ ? dn.createElement(dn.Fragment, null, dn.createElement(E, S), dn.createElement($, null)) : dn.createElement(E, S);
      });
      return b.className = p.className, b.displayName = c || `Styled.${h.displayName || h.name || h}`, b.selector = p.selector, b.toString = () => p.selector, b[$a] = p[$a], b;
    }, o = (...u) => s(u);
    return o.withConfig = (u) => (...V) => {
      const c = i.withConfig(u);
      return s(V, c, u);
    }, o;
  }))(n), n;
};
/*! (c) 2020 Andrea Giammarchi */
var kp = { exports: {} };
/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    for (var n = function(d, m, A) {
      return m === void 0 && (m = 0), A === void 0 && (A = 1), d < m ? m : d > A ? A : d;
    }, r = n, a = function(d) {
      d._clipped = !1, d._unclipped = d.slice(0);
      for (var m = 0; m <= 3; m++)
        m < 3 ? ((d[m] < 0 || d[m] > 255) && (d._clipped = !0), d[m] = r(d[m], 0, 255)) : m === 3 && (d[m] = r(d[m], 0, 1));
      return d;
    }, i = {}, s = 0, o = ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"]; s < o.length; s += 1) {
      var u = o[s];
      i["[object " + u + "]"] = u.toLowerCase();
    }
    var V = function(d) {
      return i[Object.prototype.toString.call(d)] || "object";
    }, c = V, f = function(d, m) {
      return m === void 0 && (m = null), d.length >= 3 ? Array.prototype.slice.call(d) : c(d[0]) == "object" && m ? m.split("").filter(function(A) {
        return d[0][A] !== void 0;
      }).map(function(A) {
        return d[0][A];
      }) : d[0];
    }, p = V, h = function(d) {
      if (d.length < 2)
        return null;
      var m = d.length - 1;
      return p(d[m]) == "string" ? d[m].toLowerCase() : null;
    }, g = Math.PI, b = {
      clip_rgb: a,
      limit: n,
      type: V,
      unpack: f,
      last: h,
      PI: g,
      TWOPI: g * 2,
      PITHIRD: g / 3,
      DEG2RAD: g / 180,
      RAD2DEG: 180 / g
    }, v = {
      format: {},
      autodetect: []
    }, x = b.last, E = b.clip_rgb, S = b.type, $ = v, U = function() {
      for (var m = [], A = arguments.length; A--; )
        m[A] = arguments[A];
      var O = this;
      if (S(m[0]) === "object" && m[0].constructor && m[0].constructor === this.constructor)
        return m[0];
      var M = x(m), B = !1;
      if (!M) {
        B = !0, $.sorted || ($.autodetect = $.autodetect.sort(function(ue, Ae) {
          return Ae.p - ue.p;
        }), $.sorted = !0);
        for (var k = 0, G = $.autodetect; k < G.length; k += 1) {
          var W = G[k];
          if (M = W.test.apply(W, m), M)
            break;
        }
      }
      if ($.format[M]) {
        var ae = $.format[M].apply(null, B ? m : m.slice(0, -1));
        O._rgb = E(ae);
      } else
        throw new Error("unknown format: " + m);
      O._rgb.length === 3 && O._rgb.push(1);
    };
    U.prototype.toString = function() {
      return S(this.hex) == "function" ? this.hex() : "[" + this._rgb.join(",") + "]";
    };
    var y = U, j = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(j.Color, [null].concat(d)))();
    };
    j.Color = y, j.version = "2.4.2";
    var q = j, Q = b.unpack, I = Math.max, ie = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = Q(d, "rgb"), O = A[0], M = A[1], B = A[2];
      O = O / 255, M = M / 255, B = B / 255;
      var k = 1 - I(O, I(M, B)), G = k < 1 ? 1 / (1 - k) : 0, W = (1 - O - k) * G, ae = (1 - M - k) * G, ue = (1 - B - k) * G;
      return [W, ae, ue, k];
    }, z = ie, H = b.unpack, P = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      d = H(d, "cmyk");
      var A = d[0], O = d[1], M = d[2], B = d[3], k = d.length > 4 ? d[4] : 1;
      return B === 1 ? [0, 0, 0, k] : [
        A >= 1 ? 0 : 255 * (1 - A) * (1 - B),
        // r
        O >= 1 ? 0 : 255 * (1 - O) * (1 - B),
        // g
        M >= 1 ? 0 : 255 * (1 - M) * (1 - B),
        // b
        k
      ];
    }, N = P, K = q, D = y, J = v, ee = b.unpack, C = b.type, ge = z;
    D.prototype.cmyk = function() {
      return ge(this._rgb);
    }, K.cmyk = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(D, [null].concat(d, ["cmyk"])))();
    }, J.format.cmyk = N, J.autodetect.push({
      p: 2,
      test: function() {
        for (var d = [], m = arguments.length; m--; )
          d[m] = arguments[m];
        if (d = ee(d, "cmyk"), C(d) === "array" && d.length === 4)
          return "cmyk";
      }
    });
    var pe = b.unpack, w = b.last, De = function(d) {
      return Math.round(d * 100) / 100;
    }, $e = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = pe(d, "hsla"), O = w(d) || "lsa";
      return A[0] = De(A[0] || 0), A[1] = De(A[1] * 100) + "%", A[2] = De(A[2] * 100) + "%", O === "hsla" || A.length > 3 && A[3] < 1 ? (A[3] = A.length > 3 ? A[3] : 1, O = "hsla") : A.length = 3, O + "(" + A.join(",") + ")";
    }, Me = $e, ct = b.unpack, Ye = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      d = ct(d, "rgba");
      var A = d[0], O = d[1], M = d[2];
      A /= 255, O /= 255, M /= 255;
      var B = Math.min(A, O, M), k = Math.max(A, O, M), G = (k + B) / 2, W, ae;
      return k === B ? (W = 0, ae = Number.NaN) : W = G < 0.5 ? (k - B) / (k + B) : (k - B) / (2 - k - B), A == k ? ae = (O - M) / (k - B) : O == k ? ae = 2 + (M - A) / (k - B) : M == k && (ae = 4 + (A - O) / (k - B)), ae *= 60, ae < 0 && (ae += 360), d.length > 3 && d[3] !== void 0 ? [ae, W, G, d[3]] : [ae, W, G];
    }, Oe = Ye, We = b.unpack, At = b.last, xt = Me, en = Oe, tn = Math.round, An = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = We(d, "rgba"), O = At(d) || "rgb";
      return O.substr(0, 3) == "hsl" ? xt(en(A), O) : (A[0] = tn(A[0]), A[1] = tn(A[1]), A[2] = tn(A[2]), (O === "rgba" || A.length > 3 && A[3] < 1) && (A[3] = A.length > 3 ? A[3] : 1, O = "rgba"), O + "(" + A.slice(0, O === "rgb" ? 3 : 4).join(",") + ")");
    }, En = An, Xn = b.unpack, vn = Math.round, rr = function() {
      for (var d, m = [], A = arguments.length; A--; )
        m[A] = arguments[A];
      m = Xn(m, "hsl");
      var O = m[0], M = m[1], B = m[2], k, G, W;
      if (M === 0)
        k = G = W = B * 255;
      else {
        var ae = [0, 0, 0], ue = [0, 0, 0], Ae = B < 0.5 ? B * (1 + M) : B + M - B * M, le = 2 * B - Ae, _e = O / 360;
        ae[0] = _e + 1 / 3, ae[1] = _e, ae[2] = _e - 1 / 3;
        for (var ye = 0; ye < 3; ye++)
          ae[ye] < 0 && (ae[ye] += 1), ae[ye] > 1 && (ae[ye] -= 1), 6 * ae[ye] < 1 ? ue[ye] = le + (Ae - le) * 6 * ae[ye] : 2 * ae[ye] < 1 ? ue[ye] = Ae : 3 * ae[ye] < 2 ? ue[ye] = le + (Ae - le) * (2 / 3 - ae[ye]) * 6 : ue[ye] = le;
        d = [vn(ue[0] * 255), vn(ue[1] * 255), vn(ue[2] * 255)], k = d[0], G = d[1], W = d[2];
      }
      return m.length > 3 ? [k, G, W, m[3]] : [k, G, W, 1];
    }, Tn = rr, Kn = Tn, ln = v, Mn = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/, ar = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/, te = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/, de = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, xe = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/, Ie = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, He = Math.round, Dt = function(d) {
      d = d.toLowerCase().trim();
      var m;
      if (ln.format.named)
        try {
          return ln.format.named(d);
        } catch {
        }
      if (m = d.match(Mn)) {
        for (var A = m.slice(1, 4), O = 0; O < 3; O++)
          A[O] = +A[O];
        return A[3] = 1, A;
      }
      if (m = d.match(ar)) {
        for (var M = m.slice(1, 5), B = 0; B < 4; B++)
          M[B] = +M[B];
        return M;
      }
      if (m = d.match(te)) {
        for (var k = m.slice(1, 4), G = 0; G < 3; G++)
          k[G] = He(k[G] * 2.55);
        return k[3] = 1, k;
      }
      if (m = d.match(de)) {
        for (var W = m.slice(1, 5), ae = 0; ae < 3; ae++)
          W[ae] = He(W[ae] * 2.55);
        return W[3] = +W[3], W;
      }
      if (m = d.match(xe)) {
        var ue = m.slice(1, 4);
        ue[1] *= 0.01, ue[2] *= 0.01;
        var Ae = Kn(ue);
        return Ae[3] = 1, Ae;
      }
      if (m = d.match(Ie)) {
        var le = m.slice(1, 4);
        le[1] *= 0.01, le[2] *= 0.01;
        var _e = Kn(le);
        return _e[3] = +m[4], _e;
      }
    };
    Dt.test = function(d) {
      return Mn.test(d) || ar.test(d) || te.test(d) || de.test(d) || xe.test(d) || Ie.test(d);
    };
    var Mt = Dt, Yt = q, In = y, Ot = v, rt = b.type, Ft = En, Nt = Mt;
    In.prototype.css = function(d) {
      return Ft(this._rgb, d);
    }, Yt.css = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(In, [null].concat(d, ["css"])))();
    }, Ot.format.css = Nt, Ot.autodetect.push({
      p: 5,
      test: function(d) {
        for (var m = [], A = arguments.length - 1; A-- > 0; )
          m[A] = arguments[A + 1];
        if (!m.length && rt(d) === "string" && Nt.test(d))
          return "css";
      }
    });
    var yn = y, ir = q, Zn = v, _a = b.unpack;
    Zn.format.gl = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = _a(d, "rgba");
      return A[0] *= 255, A[1] *= 255, A[2] *= 255, A;
    }, ir.gl = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(yn, [null].concat(d, ["gl"])))();
    }, yn.prototype.gl = function() {
      var d = this._rgb;
      return [d[0] / 255, d[1] / 255, d[2] / 255, d[3]];
    };
    var sr = b.unpack, na = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = sr(d, "rgb"), O = A[0], M = A[1], B = A[2], k = Math.min(O, M, B), G = Math.max(O, M, B), W = G - k, ae = W * 100 / 255, ue = k / (255 - W) * 100, Ae;
      return W === 0 ? Ae = Number.NaN : (O === G && (Ae = (M - B) / W), M === G && (Ae = 2 + (B - O) / W), B === G && (Ae = 4 + (O - M) / W), Ae *= 60, Ae < 0 && (Ae += 360)), [Ae, ae, ue];
    }, Ca = na, Sa = b.unpack, Ji = Math.floor, Fr = function() {
      for (var d, m, A, O, M, B, k = [], G = arguments.length; G--; )
        k[G] = arguments[G];
      k = Sa(k, "hcg");
      var W = k[0], ae = k[1], ue = k[2], Ae, le, _e;
      ue = ue * 255;
      var ye = ae * 255;
      if (ae === 0)
        Ae = le = _e = ue;
      else {
        W === 360 && (W = 0), W > 360 && (W -= 360), W < 0 && (W += 360), W /= 60;
        var Xe = Ji(W), Je = W - Xe, st = ue * (1 - ae), ft = st + ye * (1 - Je), an = st + ye * Je, Kt = st + ye;
        switch (Xe) {
          case 0:
            d = [Kt, an, st], Ae = d[0], le = d[1], _e = d[2];
            break;
          case 1:
            m = [ft, Kt, st], Ae = m[0], le = m[1], _e = m[2];
            break;
          case 2:
            A = [st, Kt, an], Ae = A[0], le = A[1], _e = A[2];
            break;
          case 3:
            O = [st, ft, Kt], Ae = O[0], le = O[1], _e = O[2];
            break;
          case 4:
            M = [an, st, Kt], Ae = M[0], le = M[1], _e = M[2];
            break;
          case 5:
            B = [Kt, st, ft], Ae = B[0], le = B[1], _e = B[2];
            break;
        }
      }
      return [Ae, le, _e, k.length > 3 ? k[3] : 1];
    }, es = Fr, Br = b.unpack, ra = b.type, ts = q, ui = y, xa = v, nn = Ca;
    ui.prototype.hcg = function() {
      return nn(this._rgb);
    }, ts.hcg = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(ui, [null].concat(d, ["hcg"])))();
    }, xa.format.hcg = es, xa.autodetect.push({
      p: 1,
      test: function() {
        for (var d = [], m = arguments.length; m--; )
          d[m] = arguments[m];
        if (d = Br(d, "hcg"), ra(d) === "array" && d.length === 3)
          return "hcg";
      }
    });
    var Oa = b.unpack, ns = b.last, aa = Math.round, L = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = Oa(d, "rgba"), O = A[0], M = A[1], B = A[2], k = A[3], G = ns(d) || "auto";
      k === void 0 && (k = 1), G === "auto" && (G = k < 1 ? "rgba" : "rgb"), O = aa(O), M = aa(M), B = aa(B);
      var W = O << 16 | M << 8 | B, ae = "000000" + W.toString(16);
      ae = ae.substr(ae.length - 6);
      var ue = "0" + aa(k * 255).toString(16);
      switch (ue = ue.substr(ue.length - 2), G.toLowerCase()) {
        case "rgba":
          return "#" + ae + ue;
        case "argb":
          return "#" + ue + ae;
        default:
          return "#" + ae;
      }
    }, oe = L, be = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, Pe = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/, Vt = function(d) {
      if (d.match(be)) {
        (d.length === 4 || d.length === 7) && (d = d.substr(1)), d.length === 3 && (d = d.split(""), d = d[0] + d[0] + d[1] + d[1] + d[2] + d[2]);
        var m = parseInt(d, 16), A = m >> 16, O = m >> 8 & 255, M = m & 255;
        return [A, O, M, 1];
      }
      if (d.match(Pe)) {
        (d.length === 5 || d.length === 9) && (d = d.substr(1)), d.length === 4 && (d = d.split(""), d = d[0] + d[0] + d[1] + d[1] + d[2] + d[2] + d[3] + d[3]);
        var B = parseInt(d, 16), k = B >> 24 & 255, G = B >> 16 & 255, W = B >> 8 & 255, ae = Math.round((B & 255) / 255 * 100) / 100;
        return [k, G, W, ae];
      }
      throw new Error("unknown hex color: " + d);
    }, dt = Vt, nt = q, qe = y, rn = b.type, kt = v, Ht = oe;
    qe.prototype.hex = function(d) {
      return Ht(this._rgb, d);
    }, nt.hex = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(qe, [null].concat(d, ["hex"])))();
    }, kt.format.hex = dt, kt.autodetect.push({
      p: 4,
      test: function(d) {
        for (var m = [], A = arguments.length - 1; A-- > 0; )
          m[A] = arguments[A + 1];
        if (!m.length && rn(d) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(d.length) >= 0)
          return "hex";
      }
    });
    var Rn = b.unpack, $r = b.TWOPI, Vo = Math.min, or = Math.sqrt, gE = Math.acos, bE = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = Rn(d, "rgb"), O = A[0], M = A[1], B = A[2];
      O /= 255, M /= 255, B /= 255;
      var k, G = Vo(O, M, B), W = (O + M + B) / 3, ae = W > 0 ? 1 - G / W : 0;
      return ae === 0 ? k = NaN : (k = (O - M + (O - B)) / 2, k /= or((O - M) * (O - M) + (O - B) * (M - B)), k = gE(k), B > M && (k = $r - k), k /= $r), [k * 360, ae, W];
    }, AE = bE, EE = b.unpack, Wu = b.limit, Vi = b.TWOPI, qu = b.PITHIRD, li = Math.cos, vE = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      d = EE(d, "hsi");
      var A = d[0], O = d[1], M = d[2], B, k, G;
      return isNaN(A) && (A = 0), isNaN(O) && (O = 0), A > 360 && (A -= 360), A < 0 && (A += 360), A /= 360, A < 1 / 3 ? (G = (1 - O) / 3, B = (1 + O * li(Vi * A) / li(qu - Vi * A)) / 3, k = 1 - (G + B)) : A < 2 / 3 ? (A -= 1 / 3, B = (1 - O) / 3, k = (1 + O * li(Vi * A) / li(qu - Vi * A)) / 3, G = 1 - (B + k)) : (A -= 2 / 3, k = (1 - O) / 3, G = (1 + O * li(Vi * A) / li(qu - Vi * A)) / 3, B = 1 - (k + G)), B = Wu(M * B * 3), k = Wu(M * k * 3), G = Wu(M * G * 3), [B * 255, k * 255, G * 255, d.length > 3 ? d[3] : 1];
    }, TE = vE, yE = b.unpack, _E = b.type, CE = q, ld = y, cd = v, SE = AE;
    ld.prototype.hsi = function() {
      return SE(this._rgb);
    }, CE.hsi = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(ld, [null].concat(d, ["hsi"])))();
    }, cd.format.hsi = TE, cd.autodetect.push({
      p: 2,
      test: function() {
        for (var d = [], m = arguments.length; m--; )
          d[m] = arguments[m];
        if (d = yE(d, "hsi"), _E(d) === "array" && d.length === 3)
          return "hsi";
      }
    });
    var xE = b.unpack, OE = b.type, wE = q, fd = y, dd = v, IE = Oe;
    fd.prototype.hsl = function() {
      return IE(this._rgb);
    }, wE.hsl = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(fd, [null].concat(d, ["hsl"])))();
    }, dd.format.hsl = Tn, dd.autodetect.push({
      p: 2,
      test: function() {
        for (var d = [], m = arguments.length; m--; )
          d[m] = arguments[m];
        if (d = xE(d, "hsl"), OE(d) === "array" && d.length === 3)
          return "hsl";
      }
    });
    var RE = b.unpack, NE = Math.min, kE = Math.max, LE = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      d = RE(d, "rgb");
      var A = d[0], O = d[1], M = d[2], B = NE(A, O, M), k = kE(A, O, M), G = k - B, W, ae, ue;
      return ue = k / 255, k === 0 ? (W = Number.NaN, ae = 0) : (ae = G / k, A === k && (W = (O - M) / G), O === k && (W = 2 + (M - A) / G), M === k && (W = 4 + (A - O) / G), W *= 60, W < 0 && (W += 360)), [W, ae, ue];
    }, PE = LE, DE = b.unpack, ME = Math.floor, FE = function() {
      for (var d, m, A, O, M, B, k = [], G = arguments.length; G--; )
        k[G] = arguments[G];
      k = DE(k, "hsv");
      var W = k[0], ae = k[1], ue = k[2], Ae, le, _e;
      if (ue *= 255, ae === 0)
        Ae = le = _e = ue;
      else {
        W === 360 && (W = 0), W > 360 && (W -= 360), W < 0 && (W += 360), W /= 60;
        var ye = ME(W), Xe = W - ye, Je = ue * (1 - ae), st = ue * (1 - ae * Xe), ft = ue * (1 - ae * (1 - Xe));
        switch (ye) {
          case 0:
            d = [ue, ft, Je], Ae = d[0], le = d[1], _e = d[2];
            break;
          case 1:
            m = [st, ue, Je], Ae = m[0], le = m[1], _e = m[2];
            break;
          case 2:
            A = [Je, ue, ft], Ae = A[0], le = A[1], _e = A[2];
            break;
          case 3:
            O = [Je, st, ue], Ae = O[0], le = O[1], _e = O[2];
            break;
          case 4:
            M = [ft, Je, ue], Ae = M[0], le = M[1], _e = M[2];
            break;
          case 5:
            B = [ue, Je, st], Ae = B[0], le = B[1], _e = B[2];
            break;
        }
      }
      return [Ae, le, _e, k.length > 3 ? k[3] : 1];
    }, BE = FE, $E = b.unpack, UE = b.type, HE = q, hd = y, md = v, jE = PE;
    hd.prototype.hsv = function() {
      return jE(this._rgb);
    }, HE.hsv = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(hd, [null].concat(d, ["hsv"])))();
    }, md.format.hsv = BE, md.autodetect.push({
      p: 2,
      test: function() {
        for (var d = [], m = arguments.length; m--; )
          d[m] = arguments[m];
        if (d = $E(d, "hsv"), UE(d) === "array" && d.length === 3)
          return "hsv";
      }
    });
    var lo = {
      // Corresponds roughly to RGB brighter/darker
      Kn: 18,
      // D65 standard referent
      Xn: 0.95047,
      Yn: 1,
      Zn: 1.08883,
      t0: 0.137931034,
      // 4 / 29
      t1: 0.206896552,
      // 6 / 29
      t2: 0.12841855,
      // 3 * t1 * t1
      t3: 8856452e-9
      // t1 * t1 * t1
    }, ci = lo, zE = b.unpack, pd = Math.pow, GE = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = zE(d, "rgb"), O = A[0], M = A[1], B = A[2], k = YE(O, M, B), G = k[0], W = k[1], ae = k[2], ue = 116 * W - 16;
      return [ue < 0 ? 0 : ue, 500 * (G - W), 200 * (W - ae)];
    }, Xu = function(d) {
      return (d /= 255) <= 0.04045 ? d / 12.92 : pd((d + 0.055) / 1.055, 2.4);
    }, Ku = function(d) {
      return d > ci.t3 ? pd(d, 1 / 3) : d / ci.t2 + ci.t0;
    }, YE = function(d, m, A) {
      d = Xu(d), m = Xu(m), A = Xu(A);
      var O = Ku((0.4124564 * d + 0.3575761 * m + 0.1804375 * A) / ci.Xn), M = Ku((0.2126729 * d + 0.7151522 * m + 0.072175 * A) / ci.Yn), B = Ku((0.0193339 * d + 0.119192 * m + 0.9503041 * A) / ci.Zn);
      return [O, M, B];
    }, gd = GE, fi = lo, WE = b.unpack, qE = Math.pow, XE = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      d = WE(d, "lab");
      var A = d[0], O = d[1], M = d[2], B, k, G, W, ae, ue;
      return k = (A + 16) / 116, B = isNaN(O) ? k : k + O / 500, G = isNaN(M) ? k : k - M / 200, k = fi.Yn * Qu(k), B = fi.Xn * Qu(B), G = fi.Zn * Qu(G), W = Zu(3.2404542 * B - 1.5371385 * k - 0.4985314 * G), ae = Zu(-0.969266 * B + 1.8760108 * k + 0.041556 * G), ue = Zu(0.0556434 * B - 0.2040259 * k + 1.0572252 * G), [W, ae, ue, d.length > 3 ? d[3] : 1];
    }, Zu = function(d) {
      return 255 * (d <= 304e-5 ? 12.92 * d : 1.055 * qE(d, 1 / 2.4) - 0.055);
    }, Qu = function(d) {
      return d > fi.t1 ? d * d * d : fi.t2 * (d - fi.t0);
    }, bd = XE, KE = b.unpack, ZE = b.type, QE = q, Ad = y, Ed = v, JE = gd;
    Ad.prototype.lab = function() {
      return JE(this._rgb);
    }, QE.lab = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(Ad, [null].concat(d, ["lab"])))();
    }, Ed.format.lab = bd, Ed.autodetect.push({
      p: 2,
      test: function() {
        for (var d = [], m = arguments.length; m--; )
          d[m] = arguments[m];
        if (d = KE(d, "lab"), ZE(d) === "array" && d.length === 3)
          return "lab";
      }
    });
    var ev = b.unpack, tv = b.RAD2DEG, nv = Math.sqrt, rv = Math.atan2, av = Math.round, iv = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = ev(d, "lab"), O = A[0], M = A[1], B = A[2], k = nv(M * M + B * B), G = (rv(B, M) * tv + 360) % 360;
      return av(k * 1e4) === 0 && (G = Number.NaN), [O, k, G];
    }, vd = iv, sv = b.unpack, ov = gd, uv = vd, Vv = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = sv(d, "rgb"), O = A[0], M = A[1], B = A[2], k = ov(O, M, B), G = k[0], W = k[1], ae = k[2];
      return uv(G, W, ae);
    }, lv = Vv, cv = b.unpack, fv = b.DEG2RAD, dv = Math.sin, hv = Math.cos, mv = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = cv(d, "lch"), O = A[0], M = A[1], B = A[2];
      return isNaN(B) && (B = 0), B = B * fv, [O, hv(B) * M, dv(B) * M];
    }, Td = mv, pv = b.unpack, gv = Td, bv = bd, Av = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      d = pv(d, "lch");
      var A = d[0], O = d[1], M = d[2], B = gv(A, O, M), k = B[0], G = B[1], W = B[2], ae = bv(k, G, W), ue = ae[0], Ae = ae[1], le = ae[2];
      return [ue, Ae, le, d.length > 3 ? d[3] : 1];
    }, yd = Av, Ev = b.unpack, vv = yd, Tv = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = Ev(d, "hcl").reverse();
      return vv.apply(void 0, A);
    }, yv = Tv, _v = b.unpack, Cv = b.type, _d = q, co = y, Ju = v, Cd = lv;
    co.prototype.lch = function() {
      return Cd(this._rgb);
    }, co.prototype.hcl = function() {
      return Cd(this._rgb).reverse();
    }, _d.lch = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(co, [null].concat(d, ["lch"])))();
    }, _d.hcl = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(co, [null].concat(d, ["hcl"])))();
    }, Ju.format.lch = yd, Ju.format.hcl = yv, ["lch", "hcl"].forEach(function(d) {
      return Ju.autodetect.push({
        p: 2,
        test: function() {
          for (var m = [], A = arguments.length; A--; )
            m[A] = arguments[A];
          if (m = _v(m, d), Cv(m) === "array" && m.length === 3)
            return d;
        }
      });
    });
    var Sv = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflower: "#6495ed",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      laserlemon: "#ffff54",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrod: "#fafad2",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      maroon2: "#7f0000",
      maroon3: "#b03060",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      purple2: "#7f007f",
      purple3: "#a020f0",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    }, Sd = Sv, xv = y, xd = v, Ov = b.type, rs = Sd, wv = dt, Iv = oe;
    xv.prototype.name = function() {
      for (var d = Iv(this._rgb, "rgb"), m = 0, A = Object.keys(rs); m < A.length; m += 1) {
        var O = A[m];
        if (rs[O] === d)
          return O.toLowerCase();
      }
      return d;
    }, xd.format.named = function(d) {
      if (d = d.toLowerCase(), rs[d])
        return wv(rs[d]);
      throw new Error("unknown color name: " + d);
    }, xd.autodetect.push({
      p: 5,
      test: function(d) {
        for (var m = [], A = arguments.length - 1; A-- > 0; )
          m[A] = arguments[A + 1];
        if (!m.length && Ov(d) === "string" && rs[d.toLowerCase()])
          return "named";
      }
    });
    var Rv = b.unpack, Nv = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = Rv(d, "rgb"), O = A[0], M = A[1], B = A[2];
      return (O << 16) + (M << 8) + B;
    }, kv = Nv, Lv = b.type, Pv = function(d) {
      if (Lv(d) == "number" && d >= 0 && d <= 16777215) {
        var m = d >> 16, A = d >> 8 & 255, O = d & 255;
        return [m, A, O, 1];
      }
      throw new Error("unknown num color: " + d);
    }, Dv = Pv, Mv = q, Od = y, wd = v, Fv = b.type, Bv = kv;
    Od.prototype.num = function() {
      return Bv(this._rgb);
    }, Mv.num = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(Od, [null].concat(d, ["num"])))();
    }, wd.format.num = Dv, wd.autodetect.push({
      p: 5,
      test: function() {
        for (var d = [], m = arguments.length; m--; )
          d[m] = arguments[m];
        if (d.length === 1 && Fv(d[0]) === "number" && d[0] >= 0 && d[0] <= 16777215)
          return "num";
      }
    });
    var $v = q, eV = y, Id = v, Rd = b.unpack, Nd = b.type, kd = Math.round;
    eV.prototype.rgb = function(d) {
      return d === void 0 && (d = !0), d === !1 ? this._rgb.slice(0, 3) : this._rgb.slice(0, 3).map(kd);
    }, eV.prototype.rgba = function(d) {
      return d === void 0 && (d = !0), this._rgb.slice(0, 4).map(function(m, A) {
        return A < 3 ? d === !1 ? m : kd(m) : m;
      });
    }, $v.rgb = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(eV, [null].concat(d, ["rgb"])))();
    }, Id.format.rgb = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = Rd(d, "rgba");
      return A[3] === void 0 && (A[3] = 1), A;
    }, Id.autodetect.push({
      p: 3,
      test: function() {
        for (var d = [], m = arguments.length; m--; )
          d[m] = arguments[m];
        if (d = Rd(d, "rgba"), Nd(d) === "array" && (d.length === 3 || d.length === 4 && Nd(d[3]) == "number" && d[3] >= 0 && d[3] <= 1))
          return "rgb";
      }
    });
    var fo = Math.log, Uv = function(d) {
      var m = d / 100, A, O, M;
      return m < 66 ? (A = 255, O = m < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (O = m - 2) + 104.49216199393888 * fo(O), M = m < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (M = m - 10) + 115.67994401066147 * fo(M)) : (A = 351.97690566805693 + 0.114206453784165 * (A = m - 55) - 40.25366309332127 * fo(A), O = 325.4494125711974 + 0.07943456536662342 * (O = m - 50) - 28.0852963507957 * fo(O), M = 255), [A, O, M, 1];
    }, Ld = Uv, Hv = Ld, jv = b.unpack, zv = Math.round, Gv = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      for (var A = jv(d, "rgb"), O = A[0], M = A[2], B = 1e3, k = 4e4, G = 0.4, W; k - B > G; ) {
        W = (k + B) * 0.5;
        var ae = Hv(W);
        ae[2] / ae[0] >= M / O ? k = W : B = W;
      }
      return zv(W);
    }, Yv = Gv, tV = q, ho = y, nV = v, Wv = Yv;
    ho.prototype.temp = ho.prototype.kelvin = ho.prototype.temperature = function() {
      return Wv(this._rgb);
    }, tV.temp = tV.kelvin = tV.temperature = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(ho, [null].concat(d, ["temp"])))();
    }, nV.format.temp = nV.format.kelvin = nV.format.temperature = Ld;
    var qv = b.unpack, rV = Math.cbrt, Xv = Math.pow, Kv = Math.sign, Zv = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = qv(d, "rgb"), O = A[0], M = A[1], B = A[2], k = [aV(O / 255), aV(M / 255), aV(B / 255)], G = k[0], W = k[1], ae = k[2], ue = rV(0.4122214708 * G + 0.5363325363 * W + 0.0514459929 * ae), Ae = rV(0.2119034982 * G + 0.6806995451 * W + 0.1073969566 * ae), le = rV(0.0883024619 * G + 0.2817188376 * W + 0.6299787005 * ae);
      return [
        0.2104542553 * ue + 0.793617785 * Ae - 0.0040720468 * le,
        1.9779984951 * ue - 2.428592205 * Ae + 0.4505937099 * le,
        0.0259040371 * ue + 0.7827717662 * Ae - 0.808675766 * le
      ];
    }, Pd = Zv;
    function aV(d) {
      var m = Math.abs(d);
      return m < 0.04045 ? d / 12.92 : (Kv(d) || 1) * Xv((m + 0.055) / 1.055, 2.4);
    }
    var Qv = b.unpack, mo = Math.pow, Jv = Math.sign, eT = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      d = Qv(d, "lab");
      var A = d[0], O = d[1], M = d[2], B = mo(A + 0.3963377774 * O + 0.2158037573 * M, 3), k = mo(A - 0.1055613458 * O - 0.0638541728 * M, 3), G = mo(A - 0.0894841775 * O - 1.291485548 * M, 3);
      return [
        255 * iV(4.0767416621 * B - 3.3077115913 * k + 0.2309699292 * G),
        255 * iV(-1.2684380046 * B + 2.6097574011 * k - 0.3413193965 * G),
        255 * iV(-0.0041960863 * B - 0.7034186147 * k + 1.707614701 * G),
        d.length > 3 ? d[3] : 1
      ];
    }, Dd = eT;
    function iV(d) {
      var m = Math.abs(d);
      return m > 31308e-7 ? (Jv(d) || 1) * (1.055 * mo(m, 1 / 2.4) - 0.055) : d * 12.92;
    }
    var tT = b.unpack, nT = b.type, rT = q, Md = y, Fd = v, aT = Pd;
    Md.prototype.oklab = function() {
      return aT(this._rgb);
    }, rT.oklab = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(Md, [null].concat(d, ["oklab"])))();
    }, Fd.format.oklab = Dd, Fd.autodetect.push({
      p: 3,
      test: function() {
        for (var d = [], m = arguments.length; m--; )
          d[m] = arguments[m];
        if (d = tT(d, "oklab"), nT(d) === "array" && d.length === 3)
          return "oklab";
      }
    });
    var iT = b.unpack, sT = Pd, oT = vd, uT = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      var A = iT(d, "rgb"), O = A[0], M = A[1], B = A[2], k = sT(O, M, B), G = k[0], W = k[1], ae = k[2];
      return oT(G, W, ae);
    }, VT = uT, lT = b.unpack, cT = Td, fT = Dd, dT = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      d = lT(d, "lch");
      var A = d[0], O = d[1], M = d[2], B = cT(A, O, M), k = B[0], G = B[1], W = B[2], ae = fT(k, G, W), ue = ae[0], Ae = ae[1], le = ae[2];
      return [ue, Ae, le, d.length > 3 ? d[3] : 1];
    }, hT = dT, mT = b.unpack, pT = b.type, gT = q, Bd = y, $d = v, bT = VT;
    Bd.prototype.oklch = function() {
      return bT(this._rgb);
    }, gT.oklch = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      return new (Function.prototype.bind.apply(Bd, [null].concat(d, ["oklch"])))();
    }, $d.format.oklch = hT, $d.autodetect.push({
      p: 3,
      test: function() {
        for (var d = [], m = arguments.length; m--; )
          d[m] = arguments[m];
        if (d = mT(d, "oklch"), pT(d) === "array" && d.length === 3)
          return "oklch";
      }
    });
    var Ud = y, AT = b.type;
    Ud.prototype.alpha = function(d, m) {
      return m === void 0 && (m = !1), d !== void 0 && AT(d) === "number" ? m ? (this._rgb[3] = d, this) : new Ud([this._rgb[0], this._rgb[1], this._rgb[2], d], "rgb") : this._rgb[3];
    };
    var ET = y;
    ET.prototype.clipped = function() {
      return this._rgb._clipped || !1;
    };
    var wa = y, vT = lo;
    wa.prototype.darken = function(d) {
      d === void 0 && (d = 1);
      var m = this, A = m.lab();
      return A[0] -= vT.Kn * d, new wa(A, "lab").alpha(m.alpha(), !0);
    }, wa.prototype.brighten = function(d) {
      return d === void 0 && (d = 1), this.darken(-d);
    }, wa.prototype.darker = wa.prototype.darken, wa.prototype.brighter = wa.prototype.brighten;
    var TT = y;
    TT.prototype.get = function(d) {
      var m = d.split("."), A = m[0], O = m[1], M = this[A]();
      if (O) {
        var B = A.indexOf(O) - (A.substr(0, 2) === "ok" ? 2 : 0);
        if (B > -1)
          return M[B];
        throw new Error("unknown channel " + O + " in mode " + A);
      } else
        return M;
    };
    var di = y, yT = b.type, _T = Math.pow, CT = 1e-7, ST = 20;
    di.prototype.luminance = function(d) {
      if (d !== void 0 && yT(d) === "number") {
        if (d === 0)
          return new di([0, 0, 0, this._rgb[3]], "rgb");
        if (d === 1)
          return new di([255, 255, 255, this._rgb[3]], "rgb");
        var m = this.luminance(), A = "rgb", O = ST, M = function(k, G) {
          var W = k.interpolate(G, 0.5, A), ae = W.luminance();
          return Math.abs(d - ae) < CT || !O-- ? W : ae > d ? M(k, W) : M(W, G);
        }, B = (m > d ? M(new di([0, 0, 0]), this) : M(this, new di([255, 255, 255]))).rgb();
        return new di(B.concat([this._rgb[3]]));
      }
      return xT.apply(void 0, this._rgb.slice(0, 3));
    };
    var xT = function(d, m, A) {
      return d = sV(d), m = sV(m), A = sV(A), 0.2126 * d + 0.7152 * m + 0.0722 * A;
    }, sV = function(d) {
      return d /= 255, d <= 0.03928 ? d / 12.92 : _T((d + 0.055) / 1.055, 2.4);
    }, Fn = {}, Hd = y, jd = b.type, po = Fn, zd = function(d, m, A) {
      A === void 0 && (A = 0.5);
      for (var O = [], M = arguments.length - 3; M-- > 0; )
        O[M] = arguments[M + 3];
      var B = O[0] || "lrgb";
      if (!po[B] && !O.length && (B = Object.keys(po)[0]), !po[B])
        throw new Error("interpolation mode " + B + " is not defined");
      return jd(d) !== "object" && (d = new Hd(d)), jd(m) !== "object" && (m = new Hd(m)), po[B](d, m, A).alpha(d.alpha() + A * (m.alpha() - d.alpha()));
    }, Gd = y, OT = zd;
    Gd.prototype.mix = Gd.prototype.interpolate = function(d, m) {
      m === void 0 && (m = 0.5);
      for (var A = [], O = arguments.length - 2; O-- > 0; )
        A[O] = arguments[O + 2];
      return OT.apply(void 0, [this, d, m].concat(A));
    };
    var Yd = y;
    Yd.prototype.premultiply = function(d) {
      d === void 0 && (d = !1);
      var m = this._rgb, A = m[3];
      return d ? (this._rgb = [m[0] * A, m[1] * A, m[2] * A, A], this) : new Yd([m[0] * A, m[1] * A, m[2] * A, A], "rgb");
    };
    var oV = y, wT = lo;
    oV.prototype.saturate = function(d) {
      d === void 0 && (d = 1);
      var m = this, A = m.lch();
      return A[1] += wT.Kn * d, A[1] < 0 && (A[1] = 0), new oV(A, "lch").alpha(m.alpha(), !0);
    }, oV.prototype.desaturate = function(d) {
      return d === void 0 && (d = 1), this.saturate(-d);
    };
    var Wd = y, qd = b.type;
    Wd.prototype.set = function(d, m, A) {
      A === void 0 && (A = !1);
      var O = d.split("."), M = O[0], B = O[1], k = this[M]();
      if (B) {
        var G = M.indexOf(B) - (M.substr(0, 2) === "ok" ? 2 : 0);
        if (G > -1) {
          if (qd(m) == "string")
            switch (m.charAt(0)) {
              case "+":
                k[G] += +m;
                break;
              case "-":
                k[G] += +m;
                break;
              case "*":
                k[G] *= +m.substr(1);
                break;
              case "/":
                k[G] /= +m.substr(1);
                break;
              default:
                k[G] = +m;
            }
          else if (qd(m) === "number")
            k[G] = m;
          else
            throw new Error("unsupported value for Color.set");
          var W = new Wd(k, M);
          return A ? (this._rgb = W._rgb, this) : W;
        }
        throw new Error("unknown channel " + B + " in mode " + M);
      } else
        return k;
    };
    var IT = y, RT = function(d, m, A) {
      var O = d._rgb, M = m._rgb;
      return new IT(
        O[0] + A * (M[0] - O[0]),
        O[1] + A * (M[1] - O[1]),
        O[2] + A * (M[2] - O[2]),
        "rgb"
      );
    };
    Fn.rgb = RT;
    var NT = y, uV = Math.sqrt, hi = Math.pow, kT = function(d, m, A) {
      var O = d._rgb, M = O[0], B = O[1], k = O[2], G = m._rgb, W = G[0], ae = G[1], ue = G[2];
      return new NT(
        uV(hi(M, 2) * (1 - A) + hi(W, 2) * A),
        uV(hi(B, 2) * (1 - A) + hi(ae, 2) * A),
        uV(hi(k, 2) * (1 - A) + hi(ue, 2) * A),
        "rgb"
      );
    };
    Fn.lrgb = kT;
    var LT = y, PT = function(d, m, A) {
      var O = d.lab(), M = m.lab();
      return new LT(
        O[0] + A * (M[0] - O[0]),
        O[1] + A * (M[1] - O[1]),
        O[2] + A * (M[2] - O[2]),
        "lab"
      );
    };
    Fn.lab = PT;
    var Xd = y, mi = function(d, m, A, O) {
      var M, B, k, G;
      O === "hsl" ? (k = d.hsl(), G = m.hsl()) : O === "hsv" ? (k = d.hsv(), G = m.hsv()) : O === "hcg" ? (k = d.hcg(), G = m.hcg()) : O === "hsi" ? (k = d.hsi(), G = m.hsi()) : O === "lch" || O === "hcl" ? (O = "hcl", k = d.hcl(), G = m.hcl()) : O === "oklch" && (k = d.oklch().reverse(), G = m.oklch().reverse());
      var W, ae, ue, Ae, le, _e;
      (O.substr(0, 1) === "h" || O === "oklch") && (M = k, W = M[0], ue = M[1], le = M[2], B = G, ae = B[0], Ae = B[1], _e = B[2]);
      var ye, Xe, Je, st;
      return !isNaN(W) && !isNaN(ae) ? (ae > W && ae - W > 180 ? st = ae - (W + 360) : ae < W && W - ae > 180 ? st = ae + 360 - W : st = ae - W, Xe = W + A * st) : isNaN(W) ? isNaN(ae) ? Xe = Number.NaN : (Xe = ae, (le == 1 || le == 0) && O != "hsv" && (ye = Ae)) : (Xe = W, (_e == 1 || _e == 0) && O != "hsv" && (ye = ue)), ye === void 0 && (ye = ue + A * (Ae - ue)), Je = le + A * (_e - le), O === "oklch" ? new Xd([Je, ye, Xe], O) : new Xd([Xe, ye, Je], O);
    }, DT = mi, Kd = function(d, m, A) {
      return DT(d, m, A, "lch");
    };
    Fn.lch = Kd, Fn.hcl = Kd;
    var MT = y, FT = function(d, m, A) {
      var O = d.num(), M = m.num();
      return new MT(O + A * (M - O), "num");
    };
    Fn.num = FT;
    var BT = mi, $T = function(d, m, A) {
      return BT(d, m, A, "hcg");
    };
    Fn.hcg = $T;
    var UT = mi, HT = function(d, m, A) {
      return UT(d, m, A, "hsi");
    };
    Fn.hsi = HT;
    var jT = mi, zT = function(d, m, A) {
      return jT(d, m, A, "hsl");
    };
    Fn.hsl = zT;
    var GT = mi, YT = function(d, m, A) {
      return GT(d, m, A, "hsv");
    };
    Fn.hsv = YT;
    var WT = y, qT = function(d, m, A) {
      var O = d.oklab(), M = m.oklab();
      return new WT(
        O[0] + A * (M[0] - O[0]),
        O[1] + A * (M[1] - O[1]),
        O[2] + A * (M[2] - O[2]),
        "oklab"
      );
    };
    Fn.oklab = qT;
    var XT = mi, KT = function(d, m, A) {
      return XT(d, m, A, "oklch");
    };
    Fn.oklch = KT;
    var VV = y, ZT = b.clip_rgb, lV = Math.pow, cV = Math.sqrt, fV = Math.PI, Zd = Math.cos, Qd = Math.sin, QT = Math.atan2, JT = function(d, m, A) {
      m === void 0 && (m = "lrgb"), A === void 0 && (A = null);
      var O = d.length;
      A || (A = Array.from(new Array(O)).map(function() {
        return 1;
      }));
      var M = O / A.reduce(function(Xe, Je) {
        return Xe + Je;
      });
      if (A.forEach(function(Xe, Je) {
        A[Je] *= M;
      }), d = d.map(function(Xe) {
        return new VV(Xe);
      }), m === "lrgb")
        return ey(d, A);
      for (var B = d.shift(), k = B.get(m), G = [], W = 0, ae = 0, ue = 0; ue < k.length; ue++)
        if (k[ue] = (k[ue] || 0) * A[0], G.push(isNaN(k[ue]) ? 0 : A[0]), m.charAt(ue) === "h" && !isNaN(k[ue])) {
          var Ae = k[ue] / 180 * fV;
          W += Zd(Ae) * A[0], ae += Qd(Ae) * A[0];
        }
      var le = B.alpha() * A[0];
      d.forEach(function(Xe, Je) {
        var st = Xe.get(m);
        le += Xe.alpha() * A[Je + 1];
        for (var ft = 0; ft < k.length; ft++)
          if (!isNaN(st[ft]))
            if (G[ft] += A[Je + 1], m.charAt(ft) === "h") {
              var an = st[ft] / 180 * fV;
              W += Zd(an) * A[Je + 1], ae += Qd(an) * A[Je + 1];
            } else
              k[ft] += st[ft] * A[Je + 1];
      });
      for (var _e = 0; _e < k.length; _e++)
        if (m.charAt(_e) === "h") {
          for (var ye = QT(ae / G[_e], W / G[_e]) / fV * 180; ye < 0; )
            ye += 360;
          for (; ye >= 360; )
            ye -= 360;
          k[_e] = ye;
        } else
          k[_e] = k[_e] / G[_e];
      return le /= O, new VV(k, m).alpha(le > 0.99999 ? 1 : le, !0);
    }, ey = function(d, m) {
      for (var A = d.length, O = [0, 0, 0, 0], M = 0; M < d.length; M++) {
        var B = d[M], k = m[M] / A, G = B._rgb;
        O[0] += lV(G[0], 2) * k, O[1] += lV(G[1], 2) * k, O[2] += lV(G[2], 2) * k, O[3] += G[3] * k;
      }
      return O[0] = cV(O[0]), O[1] = cV(O[1]), O[2] = cV(O[2]), O[3] > 0.9999999 && (O[3] = 1), new VV(ZT(O));
    }, ur = q, pi = b.type, ty = Math.pow, dV = function(d) {
      var m = "rgb", A = ur("#ccc"), O = 0, M = [0, 1], B = [], k = [0, 0], G = !1, W = [], ae = !1, ue = 0, Ae = 1, le = !1, _e = {}, ye = !0, Xe = 1, Je = function(ce) {
        if (ce = ce || ["#fff", "#000"], ce && pi(ce) === "string" && ur.brewer && ur.brewer[ce.toLowerCase()] && (ce = ur.brewer[ce.toLowerCase()]), pi(ce) === "array") {
          ce.length === 1 && (ce = [ce[0], ce[0]]), ce = ce.slice(0);
          for (var ke = 0; ke < ce.length; ke++)
            ce[ke] = ur(ce[ke]);
          B.length = 0;
          for (var Qe = 0; Qe < ce.length; Qe++)
            B.push(Qe / (ce.length - 1));
        }
        return Nn(), W = ce;
      }, st = function(ce) {
        if (G != null) {
          for (var ke = G.length - 1, Qe = 0; Qe < ke && ce >= G[Qe]; )
            Qe++;
          return Qe - 1;
        }
        return 0;
      }, ft = function(ce) {
        return ce;
      }, an = function(ce) {
        return ce;
      }, Kt = function(ce, ke) {
        var Qe, Ke;
        if (ke == null && (ke = !1), isNaN(ce) || ce === null)
          return A;
        if (ke)
          Ke = ce;
        else if (G && G.length > 2) {
          var sn = st(ce);
          Ke = sn / (G.length - 2);
        } else
          Ae !== ue ? Ke = (ce - ue) / (Ae - ue) : Ke = 1;
        Ke = an(Ke), ke || (Ke = ft(Ke)), Xe !== 1 && (Ke = ty(Ke, Xe)), Ke = k[0] + Ke * (1 - k[0] - k[1]), Ke = Math.min(1, Math.max(0, Ke));
        var Ct = Math.floor(Ke * 1e4);
        if (ye && _e[Ct])
          Qe = _e[Ct];
        else {
          if (pi(W) === "array")
            for (var ot = 0; ot < B.length; ot++) {
              var ht = B[ot];
              if (Ke <= ht) {
                Qe = W[ot];
                break;
              }
              if (Ke >= ht && ot === B.length - 1) {
                Qe = W[ot];
                break;
              }
              if (Ke > ht && Ke < B[ot + 1]) {
                Ke = (Ke - ht) / (B[ot + 1] - ht), Qe = ur.interpolate(W[ot], W[ot + 1], Ke, m);
                break;
              }
            }
          else
            pi(W) === "function" && (Qe = W(Ke));
          ye && (_e[Ct] = Qe);
        }
        return Qe;
      }, Nn = function() {
        return _e = {};
      };
      Je(d);
      var at = function(ce) {
        var ke = ur(Kt(ce));
        return ae && ke[ae] ? ke[ae]() : ke;
      };
      return at.classes = function(ce) {
        if (ce != null) {
          if (pi(ce) === "array")
            G = ce, M = [ce[0], ce[ce.length - 1]];
          else {
            var ke = ur.analyze(M);
            ce === 0 ? G = [ke.min, ke.max] : G = ur.limits(ke, "e", ce);
          }
          return at;
        }
        return G;
      }, at.domain = function(ce) {
        if (!arguments.length)
          return M;
        ue = ce[0], Ae = ce[ce.length - 1], B = [];
        var ke = W.length;
        if (ce.length === ke && ue !== Ae)
          for (var Qe = 0, Ke = Array.from(ce); Qe < Ke.length; Qe += 1) {
            var sn = Ke[Qe];
            B.push((sn - ue) / (Ae - ue));
          }
        else {
          for (var Ct = 0; Ct < ke; Ct++)
            B.push(Ct / (ke - 1));
          if (ce.length > 2) {
            var ot = ce.map(function(mt, gt) {
              return gt / (ce.length - 1);
            }), ht = ce.map(function(mt) {
              return (mt - ue) / (Ae - ue);
            });
            ht.every(function(mt, gt) {
              return ot[gt] === mt;
            }) || (an = function(mt) {
              if (mt <= 0 || mt >= 1)
                return mt;
              for (var gt = 0; mt >= ht[gt + 1]; )
                gt++;
              var lr = (mt - ht[gt]) / (ht[gt + 1] - ht[gt]), oa = ot[gt] + lr * (ot[gt + 1] - ot[gt]);
              return oa;
            });
          }
        }
        return M = [ue, Ae], at;
      }, at.mode = function(ce) {
        return arguments.length ? (m = ce, Nn(), at) : m;
      }, at.range = function(ce, ke) {
        return Je(ce), at;
      }, at.out = function(ce) {
        return ae = ce, at;
      }, at.spread = function(ce) {
        return arguments.length ? (O = ce, at) : O;
      }, at.correctLightness = function(ce) {
        return ce == null && (ce = !0), le = ce, Nn(), le ? ft = function(ke) {
          for (var Qe = Kt(0, !0).lab()[0], Ke = Kt(1, !0).lab()[0], sn = Qe > Ke, Ct = Kt(ke, !0).lab()[0], ot = Qe + (Ke - Qe) * ke, ht = Ct - ot, mt = 0, gt = 1, lr = 20; Math.abs(ht) > 0.01 && lr-- > 0; )
            (function() {
              return sn && (ht *= -1), ht < 0 ? (mt = ke, ke += (gt - ke) * 0.5) : (gt = ke, ke += (mt - ke) * 0.5), Ct = Kt(ke, !0).lab()[0], ht = Ct - ot;
            })();
          return ke;
        } : ft = function(ke) {
          return ke;
        }, at;
      }, at.padding = function(ce) {
        return ce != null ? (pi(ce) === "number" && (ce = [ce, ce]), k = ce, at) : k;
      }, at.colors = function(ce, ke) {
        arguments.length < 2 && (ke = "hex");
        var Qe = [];
        if (arguments.length === 0)
          Qe = W.slice(0);
        else if (ce === 1)
          Qe = [at(0.5)];
        else if (ce > 1) {
          var Ke = M[0], sn = M[1] - Ke;
          Qe = ny(0, ce, !1).map(function(gt) {
            return at(Ke + gt / (ce - 1) * sn);
          });
        } else {
          d = [];
          var Ct = [];
          if (G && G.length > 2)
            for (var ot = 1, ht = G.length, mt = 1 <= ht; mt ? ot < ht : ot > ht; mt ? ot++ : ot--)
              Ct.push((G[ot - 1] + G[ot]) * 0.5);
          else
            Ct = M;
          Qe = Ct.map(function(gt) {
            return at(gt);
          });
        }
        return ur[ke] && (Qe = Qe.map(function(gt) {
          return gt[ke]();
        })), Qe;
      }, at.cache = function(ce) {
        return ce != null ? (ye = ce, at) : ye;
      }, at.gamma = function(ce) {
        return ce != null ? (Xe = ce, at) : Xe;
      }, at.nodata = function(ce) {
        return ce != null ? (A = ur(ce), at) : A;
      }, at;
    };
    function ny(d, m, A) {
      for (var O = [], M = d < m, B = A ? M ? m + 1 : m - 1 : m, k = d; M ? k < B : k > B; M ? k++ : k--)
        O.push(k);
      return O;
    }
    var as = y, ry = dV, ay = function(d) {
      for (var m = [1, 1], A = 1; A < d; A++) {
        for (var O = [1], M = 1; M <= m.length; M++)
          O[M] = (m[M] || 0) + m[M - 1];
        m = O;
      }
      return m;
    }, iy = function(d) {
      var m, A, O, M, B, k, G;
      if (d = d.map(function(le) {
        return new as(le);
      }), d.length === 2)
        m = d.map(function(le) {
          return le.lab();
        }), B = m[0], k = m[1], M = function(le) {
          var _e = [0, 1, 2].map(function(ye) {
            return B[ye] + le * (k[ye] - B[ye]);
          });
          return new as(_e, "lab");
        };
      else if (d.length === 3)
        A = d.map(function(le) {
          return le.lab();
        }), B = A[0], k = A[1], G = A[2], M = function(le) {
          var _e = [0, 1, 2].map(function(ye) {
            return (1 - le) * (1 - le) * B[ye] + 2 * (1 - le) * le * k[ye] + le * le * G[ye];
          });
          return new as(_e, "lab");
        };
      else if (d.length === 4) {
        var W;
        O = d.map(function(le) {
          return le.lab();
        }), B = O[0], k = O[1], G = O[2], W = O[3], M = function(le) {
          var _e = [0, 1, 2].map(function(ye) {
            return (1 - le) * (1 - le) * (1 - le) * B[ye] + 3 * (1 - le) * (1 - le) * le * k[ye] + 3 * (1 - le) * le * le * G[ye] + le * le * le * W[ye];
          });
          return new as(_e, "lab");
        };
      } else if (d.length >= 5) {
        var ae, ue, Ae;
        ae = d.map(function(le) {
          return le.lab();
        }), Ae = d.length - 1, ue = ay(Ae), M = function(le) {
          var _e = 1 - le, ye = [0, 1, 2].map(function(Xe) {
            return ae.reduce(function(Je, st, ft) {
              return Je + ue[ft] * Math.pow(_e, Ae - ft) * Math.pow(le, ft) * st[Xe];
            }, 0);
          });
          return new as(ye, "lab");
        };
      } else
        throw new RangeError("No point in running bezier with only one color.");
      return M;
    }, sy = function(d) {
      var m = iy(d);
      return m.scale = function() {
        return ry(m);
      }, m;
    }, hV = q, Vr = function(d, m, A) {
      if (!Vr[A])
        throw new Error("unknown blend mode " + A);
      return Vr[A](d, m);
    }, ia = function(d) {
      return function(m, A) {
        var O = hV(A).rgb(), M = hV(m).rgb();
        return hV.rgb(d(O, M));
      };
    }, sa = function(d) {
      return function(m, A) {
        var O = [];
        return O[0] = d(m[0], A[0]), O[1] = d(m[1], A[1]), O[2] = d(m[2], A[2]), O;
      };
    }, oy = function(d) {
      return d;
    }, uy = function(d, m) {
      return d * m / 255;
    }, Vy = function(d, m) {
      return d > m ? m : d;
    }, ly = function(d, m) {
      return d > m ? d : m;
    }, cy = function(d, m) {
      return 255 * (1 - (1 - d / 255) * (1 - m / 255));
    }, fy = function(d, m) {
      return m < 128 ? 2 * d * m / 255 : 255 * (1 - 2 * (1 - d / 255) * (1 - m / 255));
    }, dy = function(d, m) {
      return 255 * (1 - (1 - m / 255) / (d / 255));
    }, hy = function(d, m) {
      return d === 255 ? 255 : (d = 255 * (m / 255) / (1 - d / 255), d > 255 ? 255 : d);
    };
    Vr.normal = ia(sa(oy)), Vr.multiply = ia(sa(uy)), Vr.screen = ia(sa(cy)), Vr.overlay = ia(sa(fy)), Vr.darken = ia(sa(Vy)), Vr.lighten = ia(sa(ly)), Vr.dodge = ia(sa(hy)), Vr.burn = ia(sa(dy));
    for (var my = Vr, mV = b.type, py = b.clip_rgb, gy = b.TWOPI, by = Math.pow, Ay = Math.sin, Ey = Math.cos, Jd = q, vy = function(d, m, A, O, M) {
      d === void 0 && (d = 300), m === void 0 && (m = -1.5), A === void 0 && (A = 1), O === void 0 && (O = 1), M === void 0 && (M = [0, 1]);
      var B = 0, k;
      mV(M) === "array" ? k = M[1] - M[0] : (k = 0, M = [M, M]);
      var G = function(W) {
        var ae = gy * ((d + 120) / 360 + m * W), ue = by(M[0] + k * W, O), Ae = B !== 0 ? A[0] + W * B : A, le = Ae * ue * (1 - ue) / 2, _e = Ey(ae), ye = Ay(ae), Xe = ue + le * (-0.14861 * _e + 1.78277 * ye), Je = ue + le * (-0.29227 * _e - 0.90649 * ye), st = ue + le * (1.97294 * _e);
        return Jd(py([Xe * 255, Je * 255, st * 255, 1]));
      };
      return G.start = function(W) {
        return W == null ? d : (d = W, G);
      }, G.rotations = function(W) {
        return W == null ? m : (m = W, G);
      }, G.gamma = function(W) {
        return W == null ? O : (O = W, G);
      }, G.hue = function(W) {
        return W == null ? A : (A = W, mV(A) === "array" ? (B = A[1] - A[0], B === 0 && (A = A[1])) : B = 0, G);
      }, G.lightness = function(W) {
        return W == null ? M : (mV(W) === "array" ? (M = W, k = W[1] - W[0]) : (M = [W, W], k = 0), G);
      }, G.scale = function() {
        return Jd.scale(G);
      }, G.hue(A), G;
    }, Ty = y, yy = "0123456789abcdef", _y = Math.floor, Cy = Math.random, Sy = function() {
      for (var d = "#", m = 0; m < 6; m++)
        d += yy.charAt(_y(Cy() * 16));
      return new Ty(d, "hex");
    }, pV = V, eh = Math.log, xy = Math.pow, Oy = Math.floor, wy = Math.abs, th = function(d, m) {
      m === void 0 && (m = null);
      var A = {
        min: Number.MAX_VALUE,
        max: Number.MAX_VALUE * -1,
        sum: 0,
        values: [],
        count: 0
      };
      return pV(d) === "object" && (d = Object.values(d)), d.forEach(function(O) {
        m && pV(O) === "object" && (O = O[m]), O != null && !isNaN(O) && (A.values.push(O), A.sum += O, O < A.min && (A.min = O), O > A.max && (A.max = O), A.count += 1);
      }), A.domain = [A.min, A.max], A.limits = function(O, M) {
        return nh(A, O, M);
      }, A;
    }, nh = function(d, m, A) {
      m === void 0 && (m = "equal"), A === void 0 && (A = 7), pV(d) == "array" && (d = th(d));
      var O = d.min, M = d.max, B = d.values.sort(function(bV, AV) {
        return bV - AV;
      });
      if (A === 1)
        return [O, M];
      var k = [];
      if (m.substr(0, 1) === "c" && (k.push(O), k.push(M)), m.substr(0, 1) === "e") {
        k.push(O);
        for (var G = 1; G < A; G++)
          k.push(O + G / A * (M - O));
        k.push(M);
      } else if (m.substr(0, 1) === "l") {
        if (O <= 0)
          throw new Error("Logarithmic scales are only possible for values > 0");
        var W = Math.LOG10E * eh(O), ae = Math.LOG10E * eh(M);
        k.push(O);
        for (var ue = 1; ue < A; ue++)
          k.push(xy(10, W + ue / A * (ae - W)));
        k.push(M);
      } else if (m.substr(0, 1) === "q") {
        k.push(O);
        for (var Ae = 1; Ae < A; Ae++) {
          var le = (B.length - 1) * Ae / A, _e = Oy(le);
          if (_e === le)
            k.push(B[_e]);
          else {
            var ye = le - _e;
            k.push(B[_e] * (1 - ye) + B[_e + 1] * ye);
          }
        }
        k.push(M);
      } else if (m.substr(0, 1) === "k") {
        var Xe, Je = B.length, st = new Array(Je), ft = new Array(A), an = !0, Kt = 0, Nn = null;
        Nn = [], Nn.push(O);
        for (var at = 1; at < A; at++)
          Nn.push(O + at / A * (M - O));
        for (Nn.push(M); an; ) {
          for (var ce = 0; ce < A; ce++)
            ft[ce] = 0;
          for (var ke = 0; ke < Je; ke++)
            for (var Qe = B[ke], Ke = Number.MAX_VALUE, sn = void 0, Ct = 0; Ct < A; Ct++) {
              var ot = wy(Nn[Ct] - Qe);
              ot < Ke && (Ke = ot, sn = Ct), ft[sn]++, st[ke] = sn;
            }
          for (var ht = new Array(A), mt = 0; mt < A; mt++)
            ht[mt] = null;
          for (var gt = 0; gt < Je; gt++)
            Xe = st[gt], ht[Xe] === null ? ht[Xe] = B[gt] : ht[Xe] += B[gt];
          for (var lr = 0; lr < A; lr++)
            ht[lr] *= 1 / ft[lr];
          an = !1;
          for (var oa = 0; oa < A; oa++)
            if (ht[oa] !== Nn[oa]) {
              an = !0;
              break;
            }
          Nn = ht, Kt++, Kt > 200 && (an = !1);
        }
        for (var ua = {}, gi = 0; gi < A; gi++)
          ua[gi] = [];
        for (var bi = 0; bi < Je; bi++)
          Xe = st[bi], ua[Xe].push(B[bi]);
        for (var Hr = [], Ia = 0; Ia < A; Ia++)
          Hr.push(ua[Ia][0]), Hr.push(ua[Ia][ua[Ia].length - 1]);
        Hr = Hr.sort(function(bV, AV) {
          return bV - AV;
        }), k.push(Hr[0]);
        for (var is = 1; is < Hr.length; is += 2) {
          var Ra = Hr[is];
          !isNaN(Ra) && k.indexOf(Ra) === -1 && k.push(Ra);
        }
      }
      return k;
    }, rh = { analyze: th, limits: nh }, ah = y, Iy = function(d, m) {
      d = new ah(d), m = new ah(m);
      var A = d.luminance(), O = m.luminance();
      return A > O ? (A + 0.05) / (O + 0.05) : (O + 0.05) / (A + 0.05);
    }, ih = y, Ur = Math.sqrt, Wt = Math.pow, Ry = Math.min, Ny = Math.max, sh = Math.atan2, oh = Math.abs, go = Math.cos, uh = Math.sin, ky = Math.exp, Vh = Math.PI, Ly = function(d, m, A, O, M) {
      A === void 0 && (A = 1), O === void 0 && (O = 1), M === void 0 && (M = 1);
      var B = function(Ra) {
        return 360 * Ra / (2 * Vh);
      }, k = function(Ra) {
        return 2 * Vh * Ra / 360;
      };
      d = new ih(d), m = new ih(m);
      var G = Array.from(d.lab()), W = G[0], ae = G[1], ue = G[2], Ae = Array.from(m.lab()), le = Ae[0], _e = Ae[1], ye = Ae[2], Xe = (W + le) / 2, Je = Ur(Wt(ae, 2) + Wt(ue, 2)), st = Ur(Wt(_e, 2) + Wt(ye, 2)), ft = (Je + st) / 2, an = 0.5 * (1 - Ur(Wt(ft, 7) / (Wt(ft, 7) + Wt(25, 7)))), Kt = ae * (1 + an), Nn = _e * (1 + an), at = Ur(Wt(Kt, 2) + Wt(ue, 2)), ce = Ur(Wt(Nn, 2) + Wt(ye, 2)), ke = (at + ce) / 2, Qe = B(sh(ue, Kt)), Ke = B(sh(ye, Nn)), sn = Qe >= 0 ? Qe : Qe + 360, Ct = Ke >= 0 ? Ke : Ke + 360, ot = oh(sn - Ct) > 180 ? (sn + Ct + 360) / 2 : (sn + Ct) / 2, ht = 1 - 0.17 * go(k(ot - 30)) + 0.24 * go(k(2 * ot)) + 0.32 * go(k(3 * ot + 6)) - 0.2 * go(k(4 * ot - 63)), mt = Ct - sn;
      mt = oh(mt) <= 180 ? mt : Ct <= sn ? mt + 360 : mt - 360, mt = 2 * Ur(at * ce) * uh(k(mt) / 2);
      var gt = le - W, lr = ce - at, oa = 1 + 0.015 * Wt(Xe - 50, 2) / Ur(20 + Wt(Xe - 50, 2)), ua = 1 + 0.045 * ke, gi = 1 + 0.015 * ke * ht, bi = 30 * ky(-Wt((ot - 275) / 25, 2)), Hr = 2 * Ur(Wt(ke, 7) / (Wt(ke, 7) + Wt(25, 7))), Ia = -Hr * uh(2 * k(bi)), is = Ur(Wt(gt / (A * oa), 2) + Wt(lr / (O * ua), 2) + Wt(mt / (M * gi), 2) + Ia * (lr / (O * ua)) * (mt / (M * gi)));
      return Ny(0, Ry(100, is));
    }, lh = y, Py = function(d, m, A) {
      A === void 0 && (A = "lab"), d = new lh(d), m = new lh(m);
      var O = d.get(A), M = m.get(A), B = 0;
      for (var k in O) {
        var G = (O[k] || 0) - (M[k] || 0);
        B += G * G;
      }
      return Math.sqrt(B);
    }, Dy = y, My = function() {
      for (var d = [], m = arguments.length; m--; )
        d[m] = arguments[m];
      try {
        return new (Function.prototype.bind.apply(Dy, [null].concat(d)))(), !0;
      } catch {
        return !1;
      }
    }, ch = q, fh = dV, Fy = {
      cool: function() {
        return fh([ch.hsl(180, 1, 0.9), ch.hsl(250, 0.7, 0.4)]);
      },
      hot: function() {
        return fh(["#000", "#f00", "#ff0", "#fff"]).mode("rgb");
      }
    }, bo = {
      // sequential
      OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
      PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
      BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
      Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
      BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
      YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
      YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
      Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
      RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
      Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
      YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
      Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
      GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
      Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
      YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
      PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
      Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
      PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
      Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
      // diverging
      Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
      RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
      RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
      PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
      PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
      RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
      BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
      RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
      PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
      // qualitative
      Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
      Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
      Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
      Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
      Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
      Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
      Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
      Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
    }, gV = 0, dh = Object.keys(bo); gV < dh.length; gV += 1) {
      var hh = dh[gV];
      bo[hh.toLowerCase()] = bo[hh];
    }
    var By = bo, Xt = q;
    Xt.average = JT, Xt.bezier = sy, Xt.blend = my, Xt.cubehelix = vy, Xt.mix = Xt.interpolate = zd, Xt.random = Sy, Xt.scale = dV, Xt.analyze = rh.analyze, Xt.contrast = Iy, Xt.deltaE = Ly, Xt.distance = Py, Xt.limits = rh.limits, Xt.valid = My, Xt.scales = Fy, Xt.colors = Sd, Xt.brewer = By;
    var $y = Xt;
    return $y;
  });
})(kp);
var P2 = kp.exports;
const el = /* @__PURE__ */ pn(P2), tl = "#3d82e2", Ch = "#db1b42", Lp = {
  shadow1: "rgba(0,0,0,0.01)",
  shadow2: "rgba(0,0,0,0.02)",
  shadow3: "rgba(0,0,0,0.03)",
  shadow4: "rgba(0,0,0,0.04)",
  shadow6: "rgba(0,0,0,0.06)",
  shadow8: "rgba(0,0,0,0.08)",
  shadow12: "rgba(0,0,0,0.12)",
  shadow16: "rgba(0,0,0,0.16)",
  surfaceZ1Light: "0px 1px 3px 1px rgba(22, 26, 30, 0.01), 0px 4px 8px -6px rgba(22, 26, 30, 0.08), 0px 1px 5px -4px rgba(22, 26, 30, 0.08), 0px 0px 0px 1px rgba(22, 26, 30, 0.04), 0px 1px 0px 0px rgba(22, 26, 30, 0.02)"
}, Pp = (e) => ({
  primary: e,
  darkPrimary: el(e).darken(0.25).hex(),
  fadedPrimary: el(e).alpha(0.45).hex()
}), D2 = {
  black: "rgba(0,0,0,0.9)",
  white: "#fff",
  lightGrey: "#f4f4f4",
  medGrey: "#dfdfdf",
  darkGrey: "#737376",
  blue: tl,
  warn: Ch,
  darkWarn: el(Ch).darken(0.25).hex(),
  ...Pp(tl),
  ...Lp
}, M2 = "'Open Sans', sans-serif", Sh = {
  1: "13px",
  2: "15px",
  3: "18px"
}, xh = {
  1: 400,
  2: 600
}, Oh = {
  1: "20px",
  2: "22px",
  3: "24px"
}, F2 = "voiceflow-chat", ef = document.createElement("div");
ef.id = F2;
document.body.appendChild(ef);
ef.attachShadow({ mode: "open" });
const Dp = 150, Mp = (e, t = Dp) => e.map((n) => `${n} ${t}ms ease`).join(", "), B2 = () => ({
  theme: {
    colors: D2,
    shadows: Lp,
    space: {
      1: "4px",
      2: "6px",
      3: "12px",
      4: "16px",
      5: "20px",
      6: "24px"
    },
    sizes: {
      xxs: "16px",
      xs: "24px",
      sm: "36px",
      md: "42px",
      lg: "56px",
      xl: "60px",
      xxl: "72px"
    },
    fonts: {
      default: M2
    },
    fontSizes: Sh,
    fontWeights: xh,
    lineHeights: Oh,
    radii: {
      1: "8px",
      2: "10px",
      round: "50%"
    }
  },
  media: {
    mobile: "(max-width: 768px)"
  },
  utils: {
    anim: (e) => ({
      animation: e.map((t) => `${t} ${Dp}ms`).join(", ")
    }),
    trans: (e) => ({
      transition: Mp(e)
    }),
    typo: ({ size: e = Sh[2], weight: t = xh[1], height: n = Oh[1] }) => ({
      fontFamily: "$default",
      fontSize: e,
      fontWeight: t,
      lineHeight: n
    })
  }
}), $2 = L2(B2(), !1), { styled: Te, keyframes: mu, theme: vU, createTheme: U2 } = $2, H2 = ({ color: e }) => U2({
  colors: e ? Pp(e) : {}
}), j2 = mu({
  "50%": { opacity: 1 }
}), Fp = mu({
  from: { opacity: 0 },
  to: { opacity: 1 }
}), z2 = mu({
  from: { transform: "rotate(0deg)" },
  to: { transform: "rotate(360deg)" }
}), G2 = (e) => mu({
  from: { transform: `translateY(${e}px)` },
  to: { transform: "translateY(0px)" }
}), tf = ({
  distance: e = 12,
  duration: t,
  delay: n
}) => ({
  opacity: 0,
  animation: [Fp, G2(e)].map((r) => `${r} ${t}ms ease-out ${n}ms forwards`).join(", ")
}), Bp = {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, Y2 = _t(vt.AVATAR), $p = Te(Y2("div"), {
  flexShrink: 0,
  borderRadius: "$round",
  backgroundColor: "$lightGrey",
  backgroundPosition: "center",
  backgroundRepeat: "no-repeat",
  backgroundSize: "cover",
  variants: {
    size: {
      small: {
        height: 26,
        width: 26
      },
      large: {
        height: "$xxl",
        width: "$xxl",
        boxSizing: "border-box",
        boxShadow: "0 4px 16px 0 $shadow4, 0 0 0 1px $shadow2"
      }
    }
  },
  defaultVariants: {
    size: "small"
  }
}), W2 = ({ avatar: e, ...t }) => /* @__PURE__ */ X.jsx($p, { ...t, css: { backgroundImage: `url(${e})`, ...t.css } }), ba = Object.assign(W2, {
  Container: $p
}), nf = _t(vt.ASSISTANT_INFO), rf = Te(nf("h2", "title"), {
  ...Bp,
  width: "100%",
  margin: 0,
  typo: { size: 20, weight: "$2", height: "$3" },
  color: "$black"
}), Up = Te(nf("p", "description"), {
  display: "-webkit-box",
  margin: 0,
  typo: {},
  color: "$darkGrey",
  "-webkit-line-clamp": 2,
  "-webkit-box-orient": "vertical",
  overflow: "hidden",
  wordBreak: "break-word"
}), Hp = Te(nf("div"), {
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  padding: "48px 32px",
  textAlign: "center",
  [`& ${ba.Container}`]: {
    marginBottom: "$4"
  },
  [`& ${rf}`]: {
    marginBottom: 8
  }
}), q2 = ({ title: e, description: t, avatar: n }) => /* @__PURE__ */ X.jsxs(Hp, { children: [
  /* @__PURE__ */ X.jsx(ba, { size: "large", avatar: n }),
  /* @__PURE__ */ X.jsx(rf, { children: e }),
  /* @__PURE__ */ X.jsx(Up, { children: t })
] }), jp = Object.assign(q2, {
  Container: Hp,
  Title: rf,
  Description: Up
}), X2 = (e) => /* @__PURE__ */ Se.createElement("svg", { viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ Se.createElement("path", { id: "vf-close", d: "M13.748 3.32a.773.773 0 0 0-1.093-1.094l-4.389 4.39a.363.363 0 0 1-.514 0L3.368 2.23a.779.779 0 0 0-1.101 0l-.039.038a.779.779 0 0 0 0 1.101l4.385 4.385a.363.363 0 0 1 0 .514l-4.37 4.37a.773.773 0 1 0 1.092 1.093l4.37-4.37a.363.363 0 0 1 .514 0l4.413 4.412a.779.779 0 0 0 1.101 0l.039-.038a.779.779 0 0 0 0-1.101L9.359 8.222a.363.363 0 0 1 0-.514l4.389-4.389z", fill: "currentColor" })), K2 = (e) => /* @__PURE__ */ Se.createElement("svg", { width: 10, height: 10, viewBox: "0 0 10 10", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ Se.createElement("path", { id: "vf-close-v2", d: "M9.74785 1.31915C10.0496 1.01737 10.0496 0.528102 9.74785 0.226329C9.44607 -0.0754433 8.9568 -0.0754431 8.65503 0.22633L5.26629 3.61507C5.12438 3.75698 4.8943 3.75698 4.75239 3.61507L1.36785 0.230531C1.06376 -0.0735626 0.570729 -0.0735623 0.266636 0.230531L0.22807 0.269097C-0.0760235 0.57319 -0.0760232 1.06622 0.22807 1.37032L3.61261 4.75485C3.75452 4.89676 3.75452 5.12684 3.61261 5.26875L0.242553 8.63881C-0.0592196 8.94058 -0.0592194 9.42985 0.242554 9.73162C0.544326 10.0334 1.0336 10.0334 1.33537 9.73162L4.70542 6.36157C4.84733 6.21966 5.07741 6.21966 5.21932 6.36157L8.63214 9.77439C8.93624 10.0785 9.42927 10.0785 9.73336 9.77439L9.77193 9.73582C10.076 9.43173 10.076 8.9387 9.77193 8.63461L6.35911 5.22179C6.2172 5.07987 6.2172 4.84979 6.35911 4.70788L9.74785 1.31915Z", fill: "currentColor" })), Z2 = (e) => /* @__PURE__ */ Se.createElement("svg", { viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ Se.createElement("g", { fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ Se.createElement("path", { fill: "currentColor", d: "M14.25 7.281a.75.75 0 0 1 0 1.5H3.38l2.474 2.77a.75.75 0 1 1-1.152.96l-3.5-4a.75.75 0 0 1 0-.96l3.5-4a.75.75 0 0 1 1.152.96L3.38 7.282H14.25z" }))), Q2 = (e) => /* @__PURE__ */ Se.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ Se.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.56574 7.41994C8.56574 5.53075 10.1046 4 12.0007 4C13.8967 4 15.4357 5.53075 15.4357 7.41994V11.6195C15.4357 13.5087 13.8967 15.0395 12.0007 15.0395C10.1046 15.0395 8.56574 13.5087 8.56574 11.6195V7.41994ZM12.0007 5.5C10.9356 5.5 10.0718 6.35999 10.0718 7.41994V11.6195C10.0718 12.6795 10.9356 13.5395 12.0007 13.5395C13.0658 13.5395 13.9296 12.6795 13.9296 11.6195V7.41994C13.9296 6.35999 13.0658 5.5 12.0007 5.5Z", fill: "currentColor" }), /* @__PURE__ */ Se.createElement("path", { d: "M6.25305 10.4868C6.66895 10.4868 7.0061 10.8225 7.0061 11.2368C7.0061 13.9837 9.24194 16.2105 12 16.2105C14.7581 16.2105 16.9939 13.9837 16.9939 11.2368C16.9939 10.8225 17.3311 10.4868 17.747 10.4868C18.1628 10.4868 18.5 10.8225 18.5 11.2368C18.5 14.5584 15.9882 17.2957 12.7531 17.6675V19.25C12.7531 19.6642 12.4159 20 12 20C11.5841 20 11.247 19.6642 11.247 19.25V17.6675C8.01185 17.2958 5.5 14.5584 5.5 11.2368C5.5 10.8225 5.83715 10.4868 6.25305 10.4868Z", fill: "currentColor" })), J2 = (e) => /* @__PURE__ */ Se.createElement("svg", { viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ Se.createElement("g", { id: "vf-minus", fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ Se.createElement("path", { d: "M15 8a.84.84 0 0 1-.84.84H1.84a.84.84 0 0 1 0-1.68h12.32A.84.84 0 0 1 15 8z", fill: "currentColor" }))), e_ = (e) => /* @__PURE__ */ Se.createElement("svg", { viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ Se.createElement("defs", null, /* @__PURE__ */ Se.createElement("linearGradient", { x1: "50%", y1: "0%", x2: "50%", y2: "100%", id: "linearGradient-1" }, /* @__PURE__ */ Se.createElement("stop", { stopColor: "currentColor", stopOpacity: 0.85, offset: "0%" }), /* @__PURE__ */ Se.createElement("stop", { stopColor: "currentColor", offset: "100%" })), /* @__PURE__ */ Se.createElement("path", { d: "M8.50003057,3.75 C8.50003057,3.335786 8.16424057,3 7.75003057,3 C7.33582057,3 7.00003057,3.335786 7.00003057,3.75 L7.00003057,10.64873 L5.23016057,9.17384 C4.91194957,8.90866 4.43902557,8.95166 4.17385257,9.26987 C3.90867987,9.58807 3.95167287,10.061 4.26988057,10.32617 L7.26988057,12.82617 C7.54801057,13.0579 7.95202057,13.0579 8.23016057,12.82617 L11.2301606,10.32617 C11.5483606,10.061 11.5913606,9.58807 11.3261806,9.26987 C11.0610106,8.95166 10.5880906,8.90866 10.2698806,9.17384 L8.50003057,10.64871 L8.50003057,3.75 Z", id: "path-2" })), /* @__PURE__ */ Se.createElement("g", { id: "vf-arrow-up", stroke: "none", strokeWidth: 1, fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ Se.createElement("g", { id: "Path", transform: "translate(7.750018, 7.999984) rotate(180.000000) translate(-7.750018, -7.999984) " }, /* @__PURE__ */ Se.createElement("use", { fill: "currentColor", xlinkHref: "#path-2" }), /* @__PURE__ */ Se.createElement("use", { fillOpacity: 0.85, fill: "url(#linearGradient-1)", xlinkHref: "#path-2" })))), t_ = (e) => /* @__PURE__ */ Se.createElement("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ Se.createElement("g", { transform: "scale(1.5)", "transform-origin": "center" }, /* @__PURE__ */ Se.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.4489 6.04082C17.1346 5.77108 16.6611 5.80725 16.3914 6.12159C16.1216 6.43594 16.1578 6.90944 16.4721 7.17917C17.6708 8.20778 18.5 9.96132 18.5 12.0032C18.5 14.0421 17.6723 15.7945 16.4753 16.824C16.1613 17.0941 16.1256 17.5677 16.3957 17.8817C16.6658 18.1957 17.1394 18.2314 17.4534 17.9613C19.016 16.6174 20 14.4319 20 12.0032C20 9.57152 19.0144 7.38412 17.4489 6.04082ZM9.87746 6.28049C10.861 5.44627 12.3684 6.14733 12.3684 7.43503V16.567C12.3684 17.8551 10.8614 18.5554 9.87746 17.7215L7.05067 15.3267H5.51316C4.67768 15.3267 4 14.649 4 13.8135V10.1885C4 9.35302 4.67768 8.67534 5.51316 8.67534H7.05067L9.87746 6.28049ZM10.853 7.42037C10.853 7.42037 10.85 7.42247 10.8477 7.42447L7.81046 9.99759C7.675 10.1124 7.50321 10.1753 7.32566 10.1753H5.51316C5.51015 10.1753 5.5085 10.176 5.5085 10.176C5.5085 10.176 5.50574 10.1775 5.50394 10.1793C5.50213 10.1811 5.5007 10.1838 5.5007 10.1838C5.5007 10.1838 5.5 10.1855 5.5 10.1885V13.8135C5.5 13.8165 5.5007 13.8182 5.5007 13.8182C5.5007 13.8182 5.50213 13.8209 5.50394 13.8227C5.50574 13.8245 5.50849 13.826 5.50849 13.826C5.50849 13.826 5.51013 13.8267 5.51316 13.8267H7.32566C7.50321 13.8267 7.675 13.8896 7.81046 14.0044L10.8471 16.577C10.8498 16.5793 10.8532 16.5817 10.8532 16.5817C10.8532 16.5817 10.8574 16.5808 10.8609 16.5792C10.8645 16.5775 10.868 16.5747 10.868 16.5747C10.868 16.5747 10.8684 16.5707 10.8684 16.567V7.43503C10.8684 7.43141 10.868 7.42747 10.868 7.42747C10.868 7.42747 10.8645 7.42458 10.8607 7.42283C10.8573 7.42125 10.853 7.42037 10.853 7.42037ZM14.0645 8.56574C14.285 8.21513 14.748 8.10971 15.0986 8.33027C16.2391 9.04769 16.9474 10.457 16.9474 12.0048C16.9474 13.5515 16.2395 14.9628 15.0951 15.6738C14.7433 15.8924 14.2808 15.7844 14.0622 15.4326C13.8436 15.0808 13.9516 14.6183 14.3035 14.3997C14.9326 14.0088 15.4474 13.1275 15.4474 12.0048C15.4474 10.883 14.9331 9.99825 14.2999 9.59993C13.9493 9.37937 13.8439 8.91634 14.0645 8.56574Z", fill: "currentColor" }))), n_ = (e) => /* @__PURE__ */ Se.createElement("svg", { viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ Se.createElement("g", { transform: "scale(1.5)", "transform-origin": "center" }, /* @__PURE__ */ Se.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.3684 7.43506C12.3684 6.14737 10.861 5.44631 9.87746 6.28053L7.05067 8.67538H5.51316C4.67768 8.67538 4 9.35306 4 10.1885V13.8135C4 14.649 4.67768 15.3267 5.51316 15.3267H7.05067L9.87746 17.7215C10.8614 18.5554 12.3684 17.8552 12.3684 16.567V7.43506ZM10.8477 7.42451C10.85 7.4225 10.853 7.4204 10.853 7.4204C10.853 7.4204 10.8573 7.42128 10.8607 7.42286C10.8645 7.42461 10.868 7.4275 10.868 7.4275C10.868 7.4275 10.8684 7.43145 10.8684 7.43506V16.567C10.8684 16.5707 10.868 16.5748 10.868 16.5748C10.868 16.5748 10.8645 16.5776 10.8609 16.5793C10.8574 16.5809 10.8532 16.5817 10.8532 16.5817C10.8532 16.5817 10.8518 16.5807 10.8501 16.5794L10.8471 16.5771L7.81046 14.0044C7.675 13.8897 7.50321 13.8267 7.32566 13.8267H5.51316C5.51013 13.8267 5.50849 13.826 5.50849 13.826C5.50849 13.826 5.50574 13.8246 5.50394 13.8228C5.50213 13.821 5.5007 13.8182 5.5007 13.8182C5.5007 13.8182 5.5 13.8165 5.5 13.8135V10.1885C5.5 10.1855 5.5007 10.1839 5.5007 10.1839C5.5007 10.1839 5.50213 10.1811 5.50394 10.1793C5.50574 10.1775 5.5085 10.1761 5.5085 10.1761C5.5085 10.1761 5.51015 10.1754 5.51316 10.1754H7.32566C7.50321 10.1754 7.675 10.1124 7.81046 9.99762L10.8477 7.42451ZM16.1714 9.65967C15.8785 9.36678 15.4036 9.36678 15.1107 9.65967C14.8178 9.95257 14.8178 10.4274 15.1107 10.7203L16.3849 11.9945L15.1107 13.2686C14.8178 13.5615 14.8178 14.0364 15.1107 14.3293C15.4036 14.6222 15.8785 14.6222 16.1714 14.3293L17.4455 13.0551L18.7197 14.3293C19.0126 14.6222 19.4874 14.6222 19.7803 14.3293C20.0732 14.0364 20.0732 13.5615 19.7803 13.2686L18.5062 11.9945L19.7803 10.7203C20.0732 10.4274 20.0732 9.95257 19.7803 9.65967C19.4874 9.36678 19.0126 9.36678 18.7197 9.65967L17.4455 10.9338L16.1714 9.65967Z", fill: "currentColor" }))), r_ = (e) => /* @__PURE__ */ Se.createElement("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ Se.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.4 7.5H11.6C10.5952 7.5 9.93174 7.50117 9.42335 7.5427C8.93248 7.58281 8.71966 7.65295 8.59202 7.71799C8.21569 7.90973 7.90973 8.21569 7.71799 8.59202C7.65295 8.71966 7.58281 8.93248 7.5427 9.42336C7.50117 9.93174 7.5 10.5952 7.5 11.6V12.4C7.5 13.4048 7.50117 14.0683 7.5427 14.5766C7.58281 15.0675 7.65295 15.2803 7.71799 15.408C7.90973 15.7843 8.21569 16.0903 8.59202 16.282C8.71966 16.3471 8.93248 16.4172 9.42335 16.4573C9.93174 16.4988 10.5952 16.5 11.6 16.5H12.4C13.4048 16.5 14.0683 16.4988 14.5766 16.4573C15.0675 16.4172 15.2803 16.3471 15.408 16.282C15.7843 16.0903 16.0903 15.7843 16.282 15.408C16.3471 15.2803 16.4172 15.0675 16.4573 14.5766C16.4988 14.0683 16.5 13.4048 16.5 12.4V11.6C16.5 10.5952 16.4988 9.93174 16.4573 9.42336C16.4172 8.93248 16.3471 8.71966 16.282 8.59202C16.0903 8.21569 15.7843 7.90973 15.408 7.71799C15.2803 7.65295 15.0675 7.58281 14.5766 7.5427C14.0683 7.50117 13.4048 7.5 12.4 7.5ZM6.38148 7.91103C6 8.65972 6 9.63982 6 11.6V12.4C6 14.3602 6 15.3403 6.38148 16.089C6.71703 16.7475 7.25247 17.283 7.91103 17.6185C8.65972 18 9.63982 18 11.6 18H12.4C14.3602 18 15.3403 18 16.089 17.6185C16.7475 17.283 17.283 16.7475 17.6185 16.089C18 15.3403 18 14.3602 18 12.4V11.6C18 9.63982 18 8.65972 17.6185 7.91103C17.283 7.25247 16.7475 6.71703 16.089 6.38148C15.3403 6 14.3602 6 12.4 6H11.6C9.63982 6 8.65972 6 7.91103 6.38148C7.25247 6.71703 6.71703 7.25247 6.38148 7.91103Z", fill: "currentColor" })), nl = (e) => /* @__PURE__ */ Se.createElement("svg", { width: 24, height: 25, viewBox: "0 0 24 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...e }, /* @__PURE__ */ Se.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.29398 20.4966C4.56534 20.4966 4 19.8827 4 19.1539V12.3847C4 11.6559 4.56534 11.042 5.29398 11.042H8.12364L10.8534 4.92738C10.9558 4.69809 11.1677 4.54023 11.4114 4.50434L11.5175 4.49658C12.3273 4.49658 13.0978 4.85402 13.6571 5.48039C14.2015 6.09009 14.5034 6.90649 14.5034 7.7535L14.5027 8.92295L18.1434 8.92346C18.6445 8.92346 19.1173 9.13931 19.4618 9.51188L19.5612 9.62829C19.8955 10.0523 20.0479 10.6054 19.9868 11.1531L19.1398 18.742C19.0297 19.7286 18.2529 20.4966 17.2964 20.4966H8.69422H5.29398ZM11.9545 6.02658L9.41727 11.7111L9.42149 11.7693L9.42091 19.042H17.2964C17.4587 19.042 17.6222 18.8982 17.6784 18.6701L17.6942 18.5807L18.5412 10.9918C18.5604 10.8194 18.5134 10.6486 18.4189 10.5287C18.3398 10.4284 18.2401 10.378 18.1434 10.378H13.7761C13.3745 10.378 13.0488 10.0524 13.0488 9.65073V7.7535C13.0488 7.2587 12.8749 6.78825 12.5721 6.44915C12.4281 6.28794 12.2615 6.16343 12.0824 6.07923L11.9545 6.02658ZM7.96636 12.4966H5.45455V19.042H7.96636V12.4966Z", fill: "white" }), /* @__PURE__ */ Se.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.29398 20.4966C4.56534 20.4966 4 19.8827 4 19.1539V12.3847C4 11.6559 4.56534 11.042 5.29398 11.042H8.12364L10.8534 4.92738C10.9558 4.69809 11.1677 4.54023 11.4114 4.50434L11.5175 4.49658C12.3273 4.49658 13.0978 4.85402 13.6571 5.48039C14.2015 6.09009 14.5034 6.90649 14.5034 7.7535L14.5027 8.92295L18.1434 8.92346C18.6445 8.92346 19.1173 9.13931 19.4618 9.51188L19.5612 9.62829C19.8955 10.0523 20.0479 10.6054 19.9868 11.1531L19.1398 18.742C19.0297 19.7286 18.2529 20.4966 17.2964 20.4966H8.69422H5.29398ZM11.9545 6.02658L9.41727 11.7111L9.42149 11.7693L9.42091 19.042H17.2964C17.4587 19.042 17.6222 18.8982 17.6784 18.6701L17.6942 18.5807L18.5412 10.9918C18.5604 10.8194 18.5134 10.6486 18.4189 10.5287C18.3398 10.4284 18.2401 10.378 18.1434 10.378H13.7761C13.3745 10.378 13.0488 10.0524 13.0488 9.65073V7.7535C13.0488 7.2587 12.8749 6.78825 12.5721 6.44915C12.4281 6.28794 12.2615 6.16343 12.0824 6.07923L11.9545 6.02658ZM7.96636 12.4966H5.45455V19.042H7.96636V12.4966Z", fill: "currentColor" })), zp = (e) => /* @__PURE__ */ Se.createElement("svg", { width: "16px", height: "8px", viewBox: "0 0 16.0 8.0", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...e }, /* @__PURE__ */ Se.createElement("defs", null, /* @__PURE__ */ Se.createElement("clipPath", { id: "i0" }, /* @__PURE__ */ Se.createElement("path", { d: "M9.3912777,0.590799928 L11.8266759,3.22760605 C12.8648163,4.35160464 14.3915663,5 16,5 L0,5 C0.0295978076,5 0.0591679461,4.99978044 0.0887078805,4.99934241 C1.66434944,4.97597796 3.15405745,4.33102228 4.17311097,3.22783933 L6.60912844,0.590718281 C7.33672461,-0.196938863 8.66373617,-0.196900538 9.3912777,0.590799928 Z" })), /* @__PURE__ */ Se.createElement("clipPath", { id: "i1" }, /* @__PURE__ */ Se.createElement("path", { d: "M17,-1.99999948 L17,7 L-1,7 L-1,-1.99999948 L17,-1.99999948 Z M9.3912777,0.590799928 C8.66373617,-0.196900538 7.33672461,-0.196938863 6.60912844,0.590718281 L4.17311097,3.22783933 C3.15405745,4.33102228 1.66434944,4.97597796 0.0887078805,4.99934241 C0.0591679461,4.99978044 0.0295978076,5 0,5 L16,5 C14.3915663,5 12.8648163,4.35160464 11.8266759,3.22760605 Z" })), /* @__PURE__ */ Se.createElement("clipPath", { id: "i2" }, /* @__PURE__ */ Se.createElement("path", { d: "M16,0 L16,2 L0,2 L0,0 L16,0 Z" }))), /* @__PURE__ */ Se.createElement("g", { transform: "translate(-239.0 1.0)" }, /* @__PURE__ */ Se.createElement("g", { transform: "translate(239.0 0.0)" }, /* @__PURE__ */ Se.createElement("g", { clipPath: "url(#i0)" }, /* @__PURE__ */ Se.createElement("polygon", { points: "0,1.11022302e-16 16,1.11022302e-16 16,5 0,5 0,1.11022302e-16", stroke: "none", fill: "#FFFFFF" })), /* @__PURE__ */ Se.createElement("g", { clipPath: "url(#i1)" }, /* @__PURE__ */ Se.createElement("path", { d: "M16,5 L0,5 C0.0295978076,5 0.0591679461,4.99978044 0.0887078805,4.99934241 C1.66434944,4.97597796 3.15405745,4.33102228 4.17311097,3.22783933 L6.60912844,0.590718281 C7.33672461,-0.196938863 8.66373617,-0.196900538 9.3912777,0.590799928 L11.8266759,3.22760605 C12.8648163,4.35160464 14.3915663,5 16,5 Z", stroke: "#DFDFDF", strokeWidth: 2, fill: "none", strokeMiterlimit: 5 })), /* @__PURE__ */ Se.createElement("g", { transform: "translate(0.0 5.0)" }, /* @__PURE__ */ Se.createElement("g", { clipPath: "url(#i2)" }, /* @__PURE__ */ Se.createElement("polygon", { points: "0,0 16,0 16,2 0,2 0,0", stroke: "none", fill: "#FFFFFF" })))))), a_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  close: X2,
  closeV2: K2,
  largeArrowLeft: Z2,
  microphone: Q2,
  minus: J2,
  smallArrowUp: e_,
  sound: t_,
  soundOff: n_,
  stop: r_,
  thumbsUp: nl,
  topCaret: zp
}, Symbol.toStringTag, { value: "Module" })), i_ = _t(vt.ICON), Gp = Te(i_("div"), { display: "flex" }), s_ = ({ svg: e, ...t }) => {
  const n = typeof e == "string" ? a_[e] : e;
  return /* @__PURE__ */ X.jsx(Gp, { ...t, children: /* @__PURE__ */ X.jsx(n, {}) });
}, zt = Object.assign(s_, {
  Frame: Gp
}), Yp = (e, t) => dn.forwardRef(
  ({ variant: n = t, ...r }, a) => {
    const i = e[n];
    return i ? /* @__PURE__ */ X.jsx(i, { ...r, ref: a }) : null;
  }
);
var za = /* @__PURE__ */ ((e) => (e.PRIMARY = "primary", e.SECONDARY = "secondary", e))(za || {});
const af = _t(vt.BUTTON), Wp = Te("button", {
  border: 0,
  padding: 0,
  "&:focus": {
    outline: 0
  },
  "&:hover": {
    cursor: "pointer"
  }
}), sf = Te(af(Wp), {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  padding: "0 14px",
  borderRadius: "$1",
  typo: { weight: "$2" },
  whiteSpace: "nowrap",
  overflowWrap: "anywhere"
}), qp = Te(af(sf, za.PRIMARY), {
  minHeight: "$md",
  color: "$white",
  trans: ["background-color"],
  padding: "10px 14px",
  boxSizing: "border-box",
  whiteSpace: "break-spaces",
  variants: {
    type: {
      info: {
        backgroundColor: "$primary",
        "&:hover": {
          backgroundColor: "$darkPrimary"
        }
      },
      warn: {
        backgroundColor: "$warn",
        "&:hover": {
          backgroundColor: "$darkWarn"
        }
      },
      subtle: {
        color: "$black",
        backgroundColor: "inherit",
        trans: ["color"],
        "&:hover": {
          color: "#000"
        }
      }
    }
  },
  defaultVariants: {
    type: "info"
  }
}), Xp = Te(af(sf, za.SECONDARY), {
  height: "$sm",
  border: "1px solid $fadedPrimary",
  color: "$primary",
  backgroundColor: "$white",
  boxShadow: "0 1px 2px $shadow2",
  trans: ["border-color"],
  "&:hover": {
    borderColor: "$primary"
  }
}), o_ = {
  [za.PRIMARY]: qp,
  [za.SECONDARY]: Xp
}, u_ = Yp(o_, za.PRIMARY), tr = Object.assign(u_, {
  Variant: za,
  Reset: Wp,
  Container: sf,
  Primary: qp,
  Secondary: Xp
}), V_ = _t(vt.BUBBLE), Kp = Te(V_(tr.Reset), {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "$round",
  backgroundColor: "$primary",
  trans: ["background-color", "box-shadow"],
  "&:hover": {
    backgroundColor: "$darkPrimary"
  },
  variants: {
    size: {
      small: {
        height: "$xs",
        width: "$xs",
        [`& ${zt.Frame}`]: {
          width: "$xxs",
          height: "$xxs"
        }
      },
      large: {
        height: "$xl",
        width: "$xl",
        border: "1px solid $shadow4",
        boxShadow: "0 1px 6px $shadow6, 0 2px 24px $shadow8",
        [`& ${zt.Frame}`]: {
          width: "$sm",
          height: "$sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "large"
  }
}), l_ = ({ svg: e, color: t, ...n }) => /* @__PURE__ */ X.jsx(Kp, { ...n, children: /* @__PURE__ */ X.jsx(zt, { svg: e, css: { color: t, ...n.css } }) }), rl = Object.assign(l_, {
  Container: Kp
}), c_ = _t(vt.IMAGE), Zp = Te(c_("img"), {
  variants: {
    isRounded: {
      true: {
        borderRadius: "$1"
      }
    },
    mode: {
      overlay: {
        width: 248
      },
      embedded: {
        width: "100%",
        maxWidth: 512
      }
    }
  },
  defaultVariants: {
    isRounded: !0,
    mode: "overlay"
  }
}), f_ = ({ image: e, ...t }) => /* @__PURE__ */ X.jsx(Zp, { ...t, src: e || void 0 }), Qp = Object.assign(f_, { Base: Zp }), of = Xc({
  scrollToBottom: () => {
  }
}), { Consumer: TU } = of, d_ = ({ target: e, children: t }) => {
  const n = qr(() => {
    requestAnimationFrame(() => {
      const a = e.current;
      if (!a)
        return;
      const { scrollTop: i, scrollHeight: s, clientHeight: o } = a, u = s - o;
      u !== i && a.scrollTo({ top: u });
    });
  }, []), r = Jr(() => ({ scrollToBottom: n }), [n]);
  return /* @__PURE__ */ X.jsx(of.Provider, { value: r, children: t });
};
var lt;
(function(e) {
  e.assertEqual = (a) => a;
  function t(a) {
  }
  e.assertIs = t;
  function n(a) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (a) => {
    const i = {};
    for (const s of a)
      i[s] = s;
    return i;
  }, e.getValidEnumValues = (a) => {
    const i = e.objectKeys(a).filter((o) => typeof a[a[o]] != "number"), s = {};
    for (const o of i)
      s[o] = a[o];
    return e.objectValues(s);
  }, e.objectValues = (a) => e.objectKeys(a).map(function(i) {
    return a[i];
  }), e.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
    const i = [];
    for (const s in a)
      Object.prototype.hasOwnProperty.call(a, s) && i.push(s);
    return i;
  }, e.find = (a, i) => {
    for (const s of a)
      if (i(s))
        return s;
  }, e.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  function r(a, i = " | ") {
    return a.map((s) => typeof s == "string" ? `'${s}'` : s).join(i);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (a, i) => typeof i == "bigint" ? i.toString() : i;
})(lt || (lt = {}));
var al;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(al || (al = {}));
const Ee = lt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), ma = (e) => {
  switch (typeof e) {
    case "undefined":
      return Ee.undefined;
    case "string":
      return Ee.string;
    case "number":
      return isNaN(e) ? Ee.nan : Ee.number;
    case "boolean":
      return Ee.boolean;
    case "function":
      return Ee.function;
    case "bigint":
      return Ee.bigint;
    case "symbol":
      return Ee.symbol;
    case "object":
      return Array.isArray(e) ? Ee.array : e === null ? Ee.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Ee.promise : typeof Map < "u" && e instanceof Map ? Ee.map : typeof Set < "u" && e instanceof Set ? Ee.set : typeof Date < "u" && e instanceof Date ? Ee.date : Ee.object;
    default:
      return Ee.unknown;
  }
}, me = lt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), h_ = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class br extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(i) {
      return i.message;
    }, r = { _errors: [] }, a = (i) => {
      for (const s of i.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(a);
        else if (s.code === "invalid_return_type")
          a(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          a(s.argumentsError);
        else if (s.path.length === 0)
          r._errors.push(n(s));
        else {
          let o = r, u = 0;
          for (; u < s.path.length; ) {
            const V = s.path[u];
            u === s.path.length - 1 ? (o[V] = o[V] || { _errors: [] }, o[V]._errors.push(n(s))) : o[V] = o[V] || { _errors: [] }, o = o[V], u++;
          }
        }
    };
    return a(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, lt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const a of this.issues)
      a.path.length > 0 ? (n[a.path[0]] = n[a.path[0]] || [], n[a.path[0]].push(t(a))) : r.push(t(a));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
br.create = (e) => new br(e);
const Is = (e, t) => {
  let n;
  switch (e.code) {
    case me.invalid_type:
      e.received === Ee.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case me.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, lt.jsonStringifyReplacer)}`;
      break;
    case me.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${lt.joinValues(e.keys, ", ")}`;
      break;
    case me.invalid_union:
      n = "Invalid input";
      break;
    case me.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${lt.joinValues(e.options)}`;
      break;
    case me.invalid_enum_value:
      n = `Invalid enum value. Expected ${lt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case me.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case me.invalid_return_type:
      n = "Invalid function return type";
      break;
    case me.invalid_date:
      n = "Invalid date";
      break;
    case me.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : lt.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case me.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case me.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case me.custom:
      n = "Invalid input";
      break;
    case me.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case me.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case me.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, lt.assertNever(e);
  }
  return { message: n };
};
let Jp = Is;
function m_(e) {
  Jp = e;
}
function Mo() {
  return Jp;
}
const Fo = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: a } = e, i = [...n, ...a.path || []], s = {
    ...a,
    path: i
  };
  let o = "";
  const u = r.filter((V) => !!V).slice().reverse();
  for (const V of u)
    o = V(s, { data: t, defaultError: o }).message;
  return {
    ...a,
    path: i,
    message: a.message || o
  };
}, p_ = [];
function ve(e, t) {
  const n = Fo({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Mo(),
      Is
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
class mn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const a of n) {
      if (a.status === "aborted")
        return Be;
      a.status === "dirty" && t.dirty(), r.push(a.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const a of n)
      r.push({
        key: await a.key,
        value: await a.value
      });
    return mn.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const a of n) {
      const { key: i, value: s } = a;
      if (i.status === "aborted" || s.status === "aborted")
        return Be;
      i.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), i.value !== "__proto__" && (typeof s.value < "u" || a.alwaysSet) && (r[i.value] = s.value);
    }
    return { status: t.value, value: r };
  }
}
const Be = Object.freeze({
  status: "aborted"
}), eg = (e) => ({ status: "dirty", value: e }), On = (e) => ({ status: "valid", value: e }), il = (e) => e.status === "aborted", sl = (e) => e.status === "dirty", Rs = (e) => e.status === "valid", Bo = (e) => typeof Promise < "u" && e instanceof Promise;
var Re;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Re || (Re = {}));
class Lr {
  constructor(t, n, r, a) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = a;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const wh = (e, t) => {
  if (Rs(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new br(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function Ue(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: a } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: a } : { errorMap: (s, o) => s.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: r ?? o.defaultError } : { message: n ?? o.defaultError }, description: a };
}
class ze {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return ma(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: ma(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new mn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: ma(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Bo(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const a = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ma(t)
    }, i = this._parseSync({ data: t, path: a.path, parent: a });
    return wh(a, i);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ma(t)
    }, a = this._parse({ data: t, path: r.path, parent: r }), i = await (Bo(a) ? a : Promise.resolve(a));
    return wh(r, i);
  }
  refine(t, n) {
    const r = (a) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(a) : n;
    return this._refinement((a, i) => {
      const s = t(a), o = () => i.addIssue({
        code: me.custom,
        ...r(a)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((u) => u ? !0 : (o(), !1)) : s ? !0 : (o(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, a) => t(r) ? !0 : (a.addIssue(typeof n == "function" ? n(r, a) : n), !1));
  }
  _refinement(t) {
    return new vr({
      schema: this,
      typeName: Le.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Wr.create(this, this._def);
  }
  nullable() {
    return Wa.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Ar.create(this, this._def);
  }
  promise() {
    return Ni.create(this, this._def);
  }
  or(t) {
    return Ps.create([this, t], this._def);
  }
  and(t) {
    return Ds.create(this, t, this._def);
  }
  transform(t) {
    return new vr({
      ...Ue(this._def),
      schema: this,
      typeName: Le.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Us({
      ...Ue(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Le.ZodDefault
    });
  }
  brand() {
    return new ng({
      typeName: Le.ZodBranded,
      type: this,
      ...Ue(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new jo({
      ...Ue(this._def),
      innerType: this,
      catchValue: n,
      typeName: Le.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Qs.create(this, t);
  }
  readonly() {
    return Go.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const g_ = /^c[^\s-]{8,}$/i, b_ = /^[a-z][a-z0-9]*$/, A_ = /^[0-9A-HJKMNP-TV-Z]{26}$/, E_ = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, v_ = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, T_ = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let vV;
const y_ = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, __ = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, C_ = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function S_(e, t) {
  return !!((t === "v4" || !t) && y_.test(e) || (t === "v6" || !t) && __.test(e));
}
class gr extends ze {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Ee.string) {
      const i = this._getOrReturnCtx(t);
      return ve(
        i,
        {
          code: me.invalid_type,
          expected: Ee.string,
          received: i.parsedType
        }
        //
      ), Be;
    }
    const r = new mn();
    let a;
    for (const i of this._def.checks)
      if (i.kind === "min")
        t.data.length < i.value && (a = this._getOrReturnCtx(t, a), ve(a, {
          code: me.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "max")
        t.data.length > i.value && (a = this._getOrReturnCtx(t, a), ve(a, {
          code: me.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "length") {
        const s = t.data.length > i.value, o = t.data.length < i.value;
        (s || o) && (a = this._getOrReturnCtx(t, a), s ? ve(a, {
          code: me.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : o && ve(a, {
          code: me.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), r.dirty());
      } else if (i.kind === "email")
        v_.test(t.data) || (a = this._getOrReturnCtx(t, a), ve(a, {
          validation: "email",
          code: me.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "emoji")
        vV || (vV = new RegExp(T_, "u")), vV.test(t.data) || (a = this._getOrReturnCtx(t, a), ve(a, {
          validation: "emoji",
          code: me.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "uuid")
        E_.test(t.data) || (a = this._getOrReturnCtx(t, a), ve(a, {
          validation: "uuid",
          code: me.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid")
        g_.test(t.data) || (a = this._getOrReturnCtx(t, a), ve(a, {
          validation: "cuid",
          code: me.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid2")
        b_.test(t.data) || (a = this._getOrReturnCtx(t, a), ve(a, {
          validation: "cuid2",
          code: me.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "ulid")
        A_.test(t.data) || (a = this._getOrReturnCtx(t, a), ve(a, {
          validation: "ulid",
          code: me.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "url")
        try {
          new URL(t.data);
        } catch {
          a = this._getOrReturnCtx(t, a), ve(a, {
            validation: "url",
            code: me.invalid_string,
            message: i.message
          }), r.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(t.data) || (a = this._getOrReturnCtx(t, a), ve(a, {
          validation: "regex",
          code: me.invalid_string,
          message: i.message
        }), r.dirty())) : i.kind === "trim" ? t.data = t.data.trim() : i.kind === "includes" ? t.data.includes(i.value, i.position) || (a = this._getOrReturnCtx(t, a), ve(a, {
          code: me.invalid_string,
          validation: { includes: i.value, position: i.position },
          message: i.message
        }), r.dirty()) : i.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : i.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : i.kind === "startsWith" ? t.data.startsWith(i.value) || (a = this._getOrReturnCtx(t, a), ve(a, {
          code: me.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), r.dirty()) : i.kind === "endsWith" ? t.data.endsWith(i.value) || (a = this._getOrReturnCtx(t, a), ve(a, {
          code: me.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), r.dirty()) : i.kind === "datetime" ? C_(i).test(t.data) || (a = this._getOrReturnCtx(t, a), ve(a, {
          code: me.invalid_string,
          validation: "datetime",
          message: i.message
        }), r.dirty()) : i.kind === "ip" ? S_(t.data, i.version) || (a = this._getOrReturnCtx(t, a), ve(a, {
          validation: "ip",
          code: me.invalid_string,
          message: i.message
        }), r.dirty()) : lt.assertNever(i);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((a) => t.test(a), {
      validation: n,
      code: me.invalid_string,
      ...Re.errToObj(r)
    });
  }
  _addCheck(t) {
    return new gr({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Re.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Re.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Re.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Re.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Re.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Re.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Re.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Re.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      ...Re.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Re.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...Re.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Re.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Re.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Re.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Re.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Re.errToObj(n)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, Re.errToObj(t));
  }
  trim() {
    return new gr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new gr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new gr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
gr.create = (e) => {
  var t;
  return new gr({
    checks: [],
    typeName: Le.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Ue(e)
  });
};
function x_(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, a = n > r ? n : r, i = parseInt(e.toFixed(a).replace(".", "")), s = parseInt(t.toFixed(a).replace(".", ""));
  return i % s / Math.pow(10, a);
}
class Aa extends ze {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Ee.number) {
      const i = this._getOrReturnCtx(t);
      return ve(i, {
        code: me.invalid_type,
        expected: Ee.number,
        received: i.parsedType
      }), Be;
    }
    let r;
    const a = new mn();
    for (const i of this._def.checks)
      i.kind === "int" ? lt.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), ve(r, {
        code: me.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), a.dirty()) : i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: me.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), a.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: me.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), a.dirty()) : i.kind === "multipleOf" ? x_(t.data, i.value) !== 0 && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: me.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), a.dirty()) : i.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), ve(r, {
        code: me.not_finite,
        message: i.message
      }), a.dirty()) : lt.assertNever(i);
    return { status: a.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, Re.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, Re.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, Re.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, Re.toString(n));
  }
  setLimit(t, n, r, a) {
    return new Aa({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: Re.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Aa({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Re.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Re.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Re.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Re.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Re.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Re.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Re.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Re.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Re.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && lt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
Aa.create = (e) => new Aa({
  checks: [],
  typeName: Le.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Ue(e)
});
class Ea extends ze {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Ee.bigint) {
      const i = this._getOrReturnCtx(t);
      return ve(i, {
        code: me.invalid_type,
        expected: Ee.bigint,
        received: i.parsedType
      }), Be;
    }
    let r;
    const a = new mn();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: me.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), a.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: me.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), a.dirty()) : i.kind === "multipleOf" ? t.data % i.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: me.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), a.dirty()) : lt.assertNever(i);
    return { status: a.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, Re.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, Re.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, Re.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, Re.toString(n));
  }
  setLimit(t, n, r, a) {
    return new Ea({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: Re.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Ea({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Re.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Re.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Re.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Re.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Re.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
Ea.create = (e) => {
  var t;
  return new Ea({
    checks: [],
    typeName: Le.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Ue(e)
  });
};
class Ns extends ze {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Ee.boolean) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: me.invalid_type,
        expected: Ee.boolean,
        received: r.parsedType
      }), Be;
    }
    return On(t.data);
  }
}
Ns.create = (e) => new Ns({
  typeName: Le.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Ue(e)
});
class Ga extends ze {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Ee.date) {
      const i = this._getOrReturnCtx(t);
      return ve(i, {
        code: me.invalid_type,
        expected: Ee.date,
        received: i.parsedType
      }), Be;
    }
    if (isNaN(t.data.getTime())) {
      const i = this._getOrReturnCtx(t);
      return ve(i, {
        code: me.invalid_date
      }), Be;
    }
    const r = new mn();
    let a;
    for (const i of this._def.checks)
      i.kind === "min" ? t.data.getTime() < i.value && (a = this._getOrReturnCtx(t, a), ve(a, {
        code: me.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? t.data.getTime() > i.value && (a = this._getOrReturnCtx(t, a), ve(a, {
        code: me.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : lt.assertNever(i);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Ga({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Re.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Re.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
Ga.create = (e) => new Ga({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: Le.ZodDate,
  ...Ue(e)
});
class $o extends ze {
  _parse(t) {
    if (this._getType(t) !== Ee.symbol) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: me.invalid_type,
        expected: Ee.symbol,
        received: r.parsedType
      }), Be;
    }
    return On(t.data);
  }
}
$o.create = (e) => new $o({
  typeName: Le.ZodSymbol,
  ...Ue(e)
});
class ks extends ze {
  _parse(t) {
    if (this._getType(t) !== Ee.undefined) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: me.invalid_type,
        expected: Ee.undefined,
        received: r.parsedType
      }), Be;
    }
    return On(t.data);
  }
}
ks.create = (e) => new ks({
  typeName: Le.ZodUndefined,
  ...Ue(e)
});
class Ls extends ze {
  _parse(t) {
    if (this._getType(t) !== Ee.null) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: me.invalid_type,
        expected: Ee.null,
        received: r.parsedType
      }), Be;
    }
    return On(t.data);
  }
}
Ls.create = (e) => new Ls({
  typeName: Le.ZodNull,
  ...Ue(e)
});
class Ri extends ze {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return On(t.data);
  }
}
Ri.create = (e) => new Ri({
  typeName: Le.ZodAny,
  ...Ue(e)
});
class Ha extends ze {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return On(t.data);
  }
}
Ha.create = (e) => new Ha({
  typeName: Le.ZodUnknown,
  ...Ue(e)
});
class Kr extends ze {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return ve(n, {
      code: me.invalid_type,
      expected: Ee.never,
      received: n.parsedType
    }), Be;
  }
}
Kr.create = (e) => new Kr({
  typeName: Le.ZodNever,
  ...Ue(e)
});
class Uo extends ze {
  _parse(t) {
    if (this._getType(t) !== Ee.undefined) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: me.invalid_type,
        expected: Ee.void,
        received: r.parsedType
      }), Be;
    }
    return On(t.data);
  }
}
Uo.create = (e) => new Uo({
  typeName: Le.ZodVoid,
  ...Ue(e)
});
class Ar extends ze {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), a = this._def;
    if (n.parsedType !== Ee.array)
      return ve(n, {
        code: me.invalid_type,
        expected: Ee.array,
        received: n.parsedType
      }), Be;
    if (a.exactLength !== null) {
      const s = n.data.length > a.exactLength.value, o = n.data.length < a.exactLength.value;
      (s || o) && (ve(n, {
        code: s ? me.too_big : me.too_small,
        minimum: o ? a.exactLength.value : void 0,
        maximum: s ? a.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: a.exactLength.message
      }), r.dirty());
    }
    if (a.minLength !== null && n.data.length < a.minLength.value && (ve(n, {
      code: me.too_small,
      minimum: a.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.minLength.message
    }), r.dirty()), a.maxLength !== null && n.data.length > a.maxLength.value && (ve(n, {
      code: me.too_big,
      maximum: a.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((s, o) => a.type._parseAsync(new Lr(n, s, n.path, o)))).then((s) => mn.mergeArray(r, s));
    const i = [...n.data].map((s, o) => a.type._parseSync(new Lr(n, s, n.path, o)));
    return mn.mergeArray(r, i);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new Ar({
      ...this._def,
      minLength: { value: t, message: Re.toString(n) }
    });
  }
  max(t, n) {
    return new Ar({
      ...this._def,
      maxLength: { value: t, message: Re.toString(n) }
    });
  }
  length(t, n) {
    return new Ar({
      ...this._def,
      exactLength: { value: t, message: Re.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Ar.create = (e, t) => new Ar({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Le.ZodArray,
  ...Ue(t)
});
function Ti(e) {
  if (e instanceof Ut) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Wr.create(Ti(r));
    }
    return new Ut({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof Ar ? new Ar({
      ...e._def,
      type: Ti(e.element)
    }) : e instanceof Wr ? Wr.create(Ti(e.unwrap())) : e instanceof Wa ? Wa.create(Ti(e.unwrap())) : e instanceof Pr ? Pr.create(e.items.map((t) => Ti(t))) : e;
}
class Ut extends ze {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = lt.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== Ee.object) {
      const V = this._getOrReturnCtx(t);
      return ve(V, {
        code: me.invalid_type,
        expected: Ee.object,
        received: V.parsedType
      }), Be;
    }
    const { status: r, ctx: a } = this._processInputParams(t), { shape: i, keys: s } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Kr && this._def.unknownKeys === "strip"))
      for (const V in a.data)
        s.includes(V) || o.push(V);
    const u = [];
    for (const V of s) {
      const c = i[V], f = a.data[V];
      u.push({
        key: { status: "valid", value: V },
        value: c._parse(new Lr(a, f, a.path, V)),
        alwaysSet: V in a.data
      });
    }
    if (this._def.catchall instanceof Kr) {
      const V = this._def.unknownKeys;
      if (V === "passthrough")
        for (const c of o)
          u.push({
            key: { status: "valid", value: c },
            value: { status: "valid", value: a.data[c] }
          });
      else if (V === "strict")
        o.length > 0 && (ve(a, {
          code: me.unrecognized_keys,
          keys: o
        }), r.dirty());
      else if (V !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const V = this._def.catchall;
      for (const c of o) {
        const f = a.data[c];
        u.push({
          key: { status: "valid", value: c },
          value: V._parse(
            new Lr(a, f, a.path, c)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: c in a.data
        });
      }
    }
    return a.common.async ? Promise.resolve().then(async () => {
      const V = [];
      for (const c of u) {
        const f = await c.key;
        V.push({
          key: f,
          value: await c.value,
          alwaysSet: c.alwaysSet
        });
      }
      return V;
    }).then((V) => mn.mergeObjectSync(r, V)) : mn.mergeObjectSync(r, u);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return Re.errToObj, new Ut({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var a, i, s, o;
          const u = (s = (i = (a = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(a, n, r).message) !== null && s !== void 0 ? s : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (o = Re.errToObj(t).message) !== null && o !== void 0 ? o : u
          } : {
            message: u
          };
        }
      } : {}
    });
  }
  strip() {
    return new Ut({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Ut({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Ut({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Ut({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: Le.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Ut({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return lt.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new Ut({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return lt.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new Ut({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ti(this);
  }
  partial(t) {
    const n = {};
    return lt.objectKeys(this.shape).forEach((r) => {
      const a = this.shape[r];
      t && !t[r] ? n[r] = a : n[r] = a.optional();
    }), new Ut({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return lt.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let i = this.shape[r];
        for (; i instanceof Wr; )
          i = i._def.innerType;
        n[r] = i;
      }
    }), new Ut({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return tg(lt.objectKeys(this.shape));
  }
}
Ut.create = (e, t) => new Ut({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Kr.create(),
  typeName: Le.ZodObject,
  ...Ue(t)
});
Ut.strictCreate = (e, t) => new Ut({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Kr.create(),
  typeName: Le.ZodObject,
  ...Ue(t)
});
Ut.lazycreate = (e, t) => new Ut({
  shape: e,
  unknownKeys: "strip",
  catchall: Kr.create(),
  typeName: Le.ZodObject,
  ...Ue(t)
});
class Ps extends ze {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function a(i) {
      for (const o of i)
        if (o.result.status === "valid")
          return o.result;
      for (const o of i)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const s = i.map((o) => new br(o.ctx.common.issues));
      return ve(n, {
        code: me.invalid_union,
        unionErrors: s
      }), Be;
    }
    if (n.common.async)
      return Promise.all(r.map(async (i) => {
        const s = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: s
          }),
          ctx: s
        };
      })).then(a);
    {
      let i;
      const s = [];
      for (const u of r) {
        const V = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, c = u._parseSync({
          data: n.data,
          path: n.path,
          parent: V
        });
        if (c.status === "valid")
          return c;
        c.status === "dirty" && !i && (i = { result: c, ctx: V }), V.common.issues.length && s.push(V.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const o = s.map((u) => new br(u));
      return ve(n, {
        code: me.invalid_union,
        unionErrors: o
      }), Be;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ps.create = (e, t) => new Ps({
  options: e,
  typeName: Le.ZodUnion,
  ...Ue(t)
});
const xo = (e) => e instanceof Fs ? xo(e.schema) : e instanceof vr ? xo(e.innerType()) : e instanceof Bs ? [e.value] : e instanceof va ? e.options : e instanceof $s ? Object.keys(e.enum) : e instanceof Us ? xo(e._def.innerType) : e instanceof ks ? [void 0] : e instanceof Ls ? [null] : null;
class pu extends ze {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Ee.object)
      return ve(n, {
        code: me.invalid_type,
        expected: Ee.object,
        received: n.parsedType
      }), Be;
    const r = this.discriminator, a = n.data[r], i = this.optionsMap.get(a);
    return i ? n.common.async ? i._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : i._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (ve(n, {
      code: me.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), Be);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const a = /* @__PURE__ */ new Map();
    for (const i of n) {
      const s = xo(i.shape[t]);
      if (!s)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const o of s) {
        if (a.has(o))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(o)}`);
        a.set(o, i);
      }
    }
    return new pu({
      typeName: Le.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: a,
      ...Ue(r)
    });
  }
}
function ol(e, t) {
  const n = ma(e), r = ma(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === Ee.object && r === Ee.object) {
    const a = lt.objectKeys(t), i = lt.objectKeys(e).filter((o) => a.indexOf(o) !== -1), s = { ...e, ...t };
    for (const o of i) {
      const u = ol(e[o], t[o]);
      if (!u.valid)
        return { valid: !1 };
      s[o] = u.data;
    }
    return { valid: !0, data: s };
  } else if (n === Ee.array && r === Ee.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const a = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i], o = t[i], u = ol(s, o);
      if (!u.valid)
        return { valid: !1 };
      a.push(u.data);
    }
    return { valid: !0, data: a };
  } else
    return n === Ee.date && r === Ee.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class Ds extends ze {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), a = (i, s) => {
      if (il(i) || il(s))
        return Be;
      const o = ol(i.value, s.value);
      return o.valid ? ((sl(i) || sl(s)) && n.dirty(), { status: n.value, value: o.data }) : (ve(r, {
        code: me.invalid_intersection_types
      }), Be);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([i, s]) => a(i, s)) : a(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Ds.create = (e, t, n) => new Ds({
  left: e,
  right: t,
  typeName: Le.ZodIntersection,
  ...Ue(n)
});
class Pr extends ze {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ee.array)
      return ve(r, {
        code: me.invalid_type,
        expected: Ee.array,
        received: r.parsedType
      }), Be;
    if (r.data.length < this._def.items.length)
      return ve(r, {
        code: me.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Be;
    !this._def.rest && r.data.length > this._def.items.length && (ve(r, {
      code: me.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const i = [...r.data].map((s, o) => {
      const u = this._def.items[o] || this._def.rest;
      return u ? u._parse(new Lr(r, s, r.path, o)) : null;
    }).filter((s) => !!s);
    return r.common.async ? Promise.all(i).then((s) => mn.mergeArray(n, s)) : mn.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Pr({
      ...this._def,
      rest: t
    });
  }
}
Pr.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Pr({
    items: e,
    typeName: Le.ZodTuple,
    rest: null,
    ...Ue(t)
  });
};
class Ms extends ze {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ee.object)
      return ve(r, {
        code: me.invalid_type,
        expected: Ee.object,
        received: r.parsedType
      }), Be;
    const a = [], i = this._def.keyType, s = this._def.valueType;
    for (const o in r.data)
      a.push({
        key: i._parse(new Lr(r, o, r.path, o)),
        value: s._parse(new Lr(r, r.data[o], r.path, o))
      });
    return r.common.async ? mn.mergeObjectAsync(n, a) : mn.mergeObjectSync(n, a);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof ze ? new Ms({
      keyType: t,
      valueType: n,
      typeName: Le.ZodRecord,
      ...Ue(r)
    }) : new Ms({
      keyType: gr.create(),
      valueType: t,
      typeName: Le.ZodRecord,
      ...Ue(n)
    });
  }
}
class Ho extends ze {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ee.map)
      return ve(r, {
        code: me.invalid_type,
        expected: Ee.map,
        received: r.parsedType
      }), Be;
    const a = this._def.keyType, i = this._def.valueType, s = [...r.data.entries()].map(([o, u], V) => ({
      key: a._parse(new Lr(r, o, r.path, [V, "key"])),
      value: i._parse(new Lr(r, u, r.path, [V, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const u of s) {
          const V = await u.key, c = await u.value;
          if (V.status === "aborted" || c.status === "aborted")
            return Be;
          (V.status === "dirty" || c.status === "dirty") && n.dirty(), o.set(V.value, c.value);
        }
        return { status: n.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const u of s) {
        const V = u.key, c = u.value;
        if (V.status === "aborted" || c.status === "aborted")
          return Be;
        (V.status === "dirty" || c.status === "dirty") && n.dirty(), o.set(V.value, c.value);
      }
      return { status: n.value, value: o };
    }
  }
}
Ho.create = (e, t, n) => new Ho({
  valueType: t,
  keyType: e,
  typeName: Le.ZodMap,
  ...Ue(n)
});
class Ya extends ze {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ee.set)
      return ve(r, {
        code: me.invalid_type,
        expected: Ee.set,
        received: r.parsedType
      }), Be;
    const a = this._def;
    a.minSize !== null && r.data.size < a.minSize.value && (ve(r, {
      code: me.too_small,
      minimum: a.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.minSize.message
    }), n.dirty()), a.maxSize !== null && r.data.size > a.maxSize.value && (ve(r, {
      code: me.too_big,
      maximum: a.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function s(u) {
      const V = /* @__PURE__ */ new Set();
      for (const c of u) {
        if (c.status === "aborted")
          return Be;
        c.status === "dirty" && n.dirty(), V.add(c.value);
      }
      return { status: n.value, value: V };
    }
    const o = [...r.data.values()].map((u, V) => i._parse(new Lr(r, u, r.path, V)));
    return r.common.async ? Promise.all(o).then((u) => s(u)) : s(o);
  }
  min(t, n) {
    return new Ya({
      ...this._def,
      minSize: { value: t, message: Re.toString(n) }
    });
  }
  max(t, n) {
    return new Ya({
      ...this._def,
      maxSize: { value: t, message: Re.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Ya.create = (e, t) => new Ya({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: Le.ZodSet,
  ...Ue(t)
});
class Oi extends ze {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Ee.function)
      return ve(n, {
        code: me.invalid_type,
        expected: Ee.function,
        received: n.parsedType
      }), Be;
    function r(o, u) {
      return Fo({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Mo(),
          Is
        ].filter((V) => !!V),
        issueData: {
          code: me.invalid_arguments,
          argumentsError: u
        }
      });
    }
    function a(o, u) {
      return Fo({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Mo(),
          Is
        ].filter((V) => !!V),
        issueData: {
          code: me.invalid_return_type,
          returnTypeError: u
        }
      });
    }
    const i = { errorMap: n.common.contextualErrorMap }, s = n.data;
    if (this._def.returns instanceof Ni) {
      const o = this;
      return On(async function(...u) {
        const V = new br([]), c = await o._def.args.parseAsync(u, i).catch((h) => {
          throw V.addIssue(r(u, h)), V;
        }), f = await Reflect.apply(s, this, c);
        return await o._def.returns._def.type.parseAsync(f, i).catch((h) => {
          throw V.addIssue(a(f, h)), V;
        });
      });
    } else {
      const o = this;
      return On(function(...u) {
        const V = o._def.args.safeParse(u, i);
        if (!V.success)
          throw new br([r(u, V.error)]);
        const c = Reflect.apply(s, this, V.data), f = o._def.returns.safeParse(c, i);
        if (!f.success)
          throw new br([a(c, f.error)]);
        return f.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Oi({
      ...this._def,
      args: Pr.create(t).rest(Ha.create())
    });
  }
  returns(t) {
    return new Oi({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new Oi({
      args: t || Pr.create([]).rest(Ha.create()),
      returns: n || Ha.create(),
      typeName: Le.ZodFunction,
      ...Ue(r)
    });
  }
}
class Fs extends ze {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
Fs.create = (e, t) => new Fs({
  getter: e,
  typeName: Le.ZodLazy,
  ...Ue(t)
});
class Bs extends ze {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return ve(n, {
        received: n.data,
        code: me.invalid_literal,
        expected: this._def.value
      }), Be;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Bs.create = (e, t) => new Bs({
  value: e,
  typeName: Le.ZodLiteral,
  ...Ue(t)
});
function tg(e, t) {
  return new va({
    values: e,
    typeName: Le.ZodEnum,
    ...Ue(t)
  });
}
class va extends ze {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return ve(n, {
        expected: lt.joinValues(r),
        received: n.parsedType,
        code: me.invalid_type
      }), Be;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return ve(n, {
        received: n.data,
        code: me.invalid_enum_value,
        options: r
      }), Be;
    }
    return On(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t) {
    return va.create(t);
  }
  exclude(t) {
    return va.create(this.options.filter((n) => !t.includes(n)));
  }
}
va.create = tg;
class $s extends ze {
  _parse(t) {
    const n = lt.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== Ee.string && r.parsedType !== Ee.number) {
      const a = lt.objectValues(n);
      return ve(r, {
        expected: lt.joinValues(a),
        received: r.parsedType,
        code: me.invalid_type
      }), Be;
    }
    if (n.indexOf(t.data) === -1) {
      const a = lt.objectValues(n);
      return ve(r, {
        received: r.data,
        code: me.invalid_enum_value,
        options: a
      }), Be;
    }
    return On(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
$s.create = (e, t) => new $s({
  values: e,
  typeName: Le.ZodNativeEnum,
  ...Ue(t)
});
class Ni extends ze {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Ee.promise && n.common.async === !1)
      return ve(n, {
        code: me.invalid_type,
        expected: Ee.promise,
        received: n.parsedType
      }), Be;
    const r = n.parsedType === Ee.promise ? n.data : Promise.resolve(n.data);
    return On(r.then((a) => this._def.type.parseAsync(a, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Ni.create = (e, t) => new Ni({
  type: e,
  typeName: Le.ZodPromise,
  ...Ue(t)
});
class vr extends ze {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Le.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), a = this._def.effect || null, i = {
      addIssue: (s) => {
        ve(r, s), s.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), a.type === "preprocess") {
      const s = a.transform(r.data, i);
      return r.common.issues.length ? {
        status: "dirty",
        value: r.data
      } : r.common.async ? Promise.resolve(s).then((o) => this._def.schema._parseAsync({
        data: o,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: s,
        path: r.path,
        parent: r
      });
    }
    if (a.type === "refinement") {
      const s = (o) => {
        const u = a.refinement(o, i);
        if (r.common.async)
          return Promise.resolve(u);
        if (u instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? Be : (o.status === "dirty" && n.dirty(), s(o.value), { status: n.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? Be : (o.status === "dirty" && n.dirty(), s(o.value).then(() => ({ status: n.value, value: o.value }))));
    }
    if (a.type === "transform")
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Rs(s))
          return s;
        const o = a.transform(s.value, i);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => Rs(s) ? Promise.resolve(a.transform(s.value, i)).then((o) => ({ status: n.value, value: o })) : s);
    lt.assertNever(a);
  }
}
vr.create = (e, t, n) => new vr({
  schema: e,
  typeName: Le.ZodEffects,
  effect: t,
  ...Ue(n)
});
vr.createWithPreprocess = (e, t, n) => new vr({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: Le.ZodEffects,
  ...Ue(n)
});
class Wr extends ze {
  _parse(t) {
    return this._getType(t) === Ee.undefined ? On(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Wr.create = (e, t) => new Wr({
  innerType: e,
  typeName: Le.ZodOptional,
  ...Ue(t)
});
class Wa extends ze {
  _parse(t) {
    return this._getType(t) === Ee.null ? On(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Wa.create = (e, t) => new Wa({
  innerType: e,
  typeName: Le.ZodNullable,
  ...Ue(t)
});
class Us extends ze {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === Ee.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Us.create = (e, t) => new Us({
  innerType: e,
  typeName: Le.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...Ue(t)
});
class jo extends ze {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, a = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Bo(a) ? a.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new br(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new br(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
jo.create = (e, t) => new jo({
  innerType: e,
  typeName: Le.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...Ue(t)
});
class zo extends ze {
  _parse(t) {
    if (this._getType(t) !== Ee.nan) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: me.invalid_type,
        expected: Ee.nan,
        received: r.parsedType
      }), Be;
    }
    return { status: "valid", value: t.data };
  }
}
zo.create = (e) => new zo({
  typeName: Le.ZodNaN,
  ...Ue(e)
});
const O_ = Symbol("zod_brand");
class ng extends ze {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Qs extends ze {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? Be : i.status === "dirty" ? (n.dirty(), eg(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const a = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return a.status === "aborted" ? Be : a.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: a.value
      }) : this._def.out._parseSync({
        data: a.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new Qs({
      in: t,
      out: n,
      typeName: Le.ZodPipeline
    });
  }
}
class Go extends ze {
  _parse(t) {
    const n = this._def.innerType._parse(t);
    return Rs(n) && (n.value = Object.freeze(n.value)), n;
  }
}
Go.create = (e, t) => new Go({
  innerType: e,
  typeName: Le.ZodReadonly,
  ...Ue(t)
});
const rg = (e, t = {}, n) => e ? Ri.create().superRefine((r, a) => {
  var i, s;
  if (!e(r)) {
    const o = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, u = (s = (i = o.fatal) !== null && i !== void 0 ? i : n) !== null && s !== void 0 ? s : !0, V = typeof o == "string" ? { message: o } : o;
    a.addIssue({ code: "custom", ...V, fatal: u });
  }
}) : Ri.create(), w_ = {
  object: Ut.lazycreate
};
var Le;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Le || (Le = {}));
const I_ = (e, t = {
  message: `Input not instance of ${e.name}`
}) => rg((n) => n instanceof e, t), ag = gr.create, ig = Aa.create, R_ = zo.create, N_ = Ea.create, sg = Ns.create, k_ = Ga.create, L_ = $o.create, P_ = ks.create, D_ = Ls.create, M_ = Ri.create, F_ = Ha.create, B_ = Kr.create, $_ = Uo.create, U_ = Ar.create, H_ = Ut.create, j_ = Ut.strictCreate, z_ = Ps.create, G_ = pu.create, Y_ = Ds.create, W_ = Pr.create, q_ = Ms.create, X_ = Ho.create, K_ = Ya.create, Z_ = Oi.create, Q_ = Fs.create, J_ = Bs.create, eC = va.create, tC = $s.create, nC = Ni.create, Ih = vr.create, rC = Wr.create, aC = Wa.create, iC = vr.createWithPreprocess, sC = Qs.create, oC = () => ag().optional(), uC = () => ig().optional(), VC = () => sg().optional(), lC = {
  string: (e) => gr.create({ ...e, coerce: !0 }),
  number: (e) => Aa.create({ ...e, coerce: !0 }),
  boolean: (e) => Ns.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Ea.create({ ...e, coerce: !0 }),
  date: (e) => Ga.create({ ...e, coerce: !0 })
}, cC = Be;
var F = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Is,
  setErrorMap: m_,
  getErrorMap: Mo,
  makeIssue: Fo,
  EMPTY_PATH: p_,
  addIssueToContext: ve,
  ParseStatus: mn,
  INVALID: Be,
  DIRTY: eg,
  OK: On,
  isAborted: il,
  isDirty: sl,
  isValid: Rs,
  isAsync: Bo,
  get util() {
    return lt;
  },
  get objectUtil() {
    return al;
  },
  ZodParsedType: Ee,
  getParsedType: ma,
  ZodType: ze,
  ZodString: gr,
  ZodNumber: Aa,
  ZodBigInt: Ea,
  ZodBoolean: Ns,
  ZodDate: Ga,
  ZodSymbol: $o,
  ZodUndefined: ks,
  ZodNull: Ls,
  ZodAny: Ri,
  ZodUnknown: Ha,
  ZodNever: Kr,
  ZodVoid: Uo,
  ZodArray: Ar,
  ZodObject: Ut,
  ZodUnion: Ps,
  ZodDiscriminatedUnion: pu,
  ZodIntersection: Ds,
  ZodTuple: Pr,
  ZodRecord: Ms,
  ZodMap: Ho,
  ZodSet: Ya,
  ZodFunction: Oi,
  ZodLazy: Fs,
  ZodLiteral: Bs,
  ZodEnum: va,
  ZodNativeEnum: $s,
  ZodPromise: Ni,
  ZodEffects: vr,
  ZodTransformer: vr,
  ZodOptional: Wr,
  ZodNullable: Wa,
  ZodDefault: Us,
  ZodCatch: jo,
  ZodNaN: zo,
  BRAND: O_,
  ZodBranded: ng,
  ZodPipeline: Qs,
  ZodReadonly: Go,
  custom: rg,
  Schema: ze,
  ZodSchema: ze,
  late: w_,
  get ZodFirstPartyTypeKind() {
    return Le;
  },
  coerce: lC,
  any: M_,
  array: U_,
  bigint: N_,
  boolean: sg,
  date: k_,
  discriminatedUnion: G_,
  effect: Ih,
  enum: eC,
  function: Z_,
  instanceof: I_,
  intersection: Y_,
  lazy: Q_,
  literal: J_,
  map: X_,
  nan: R_,
  nativeEnum: tC,
  never: B_,
  null: D_,
  nullable: aC,
  number: ig,
  object: H_,
  oboolean: VC,
  onumber: uC,
  optional: rC,
  ostring: oC,
  pipeline: sC,
  preprocess: iC,
  promise: nC,
  record: q_,
  set: K_,
  strictObject: j_,
  string: ag,
  symbol: L_,
  transformer: Ih,
  tuple: W_,
  undefined: P_,
  union: z_,
  unknown: F_,
  void: $_,
  NEVER: cC,
  ZodIssueCode: me,
  quotelessJson: h_,
  ZodError: br
});
const fC = {
  OPEN_URL: "open_url"
}, og = F.object({
  type: F.string(),
  payload: F.unknown()
}).passthrough();
og.extend({
  type: F.literal(fC.OPEN_URL),
  payload: F.object({
    url: F.string()
  }).passthrough()
}).passthrough();
const dC = {
  FULL: "full",
  HIDDEN: "hidden",
  CROPPED: "cropped"
}, hC = {
  LIST: "List",
  CAROUSEL: "Carousel"
}, mC = {
  APL: "apl",
  IMAGE: "image"
}, pC = F.object({
  actions: F.array(og).optional()
}), gC = F.object({
  label: F.string().optional()
}), gu = pC.merge(gC), Zr = {
  TEXT: "text",
  ACTION: "action",
  INTENT: "intent",
  LAUNCH: "launch",
  NO_REPLY: "no-reply",
  EXIT_SCENARIO: "exit-scenario"
}, Dr = F.object({
  type: F.string(),
  payload: F.any().optional(),
  // payload can be string or object
  diagramID: F.string().optional()
}), bC = Dr.extend({
  type: F.literal(Zr.ACTION),
  payload: gu.passthrough().optional()
}).passthrough(), ug = Dr.extend({
  type: F.string().refine((e) => !Object.values(Zr).includes(e)),
  payload: gu.passthrough().optional()
}).passthrough(), AC = ug.extend({
  type: F.string().refine((e) => e.startsWith("path-")),
  payload: gu.passthrough().required({ label: !0 })
}).passthrough(), EC = F.object({
  rawText: F.string(),
  canonicalText: F.string(),
  startIndex: F.number()
}), vC = F.object({
  name: F.string(),
  value: F.string(),
  query: F.string().optional(),
  verboseValue: F.array(EC).optional()
}).passthrough(), uf = gu.extend({
  data: F.record(F.any()).optional(),
  query: F.string().default(""),
  entities: F.array(vC).default([]),
  intent: F.object({ name: F.string() }).passthrough(),
  confidence: F.number().optional()
}).passthrough(), bu = Dr.extend({
  type: F.literal(Zr.INTENT),
  payload: uf
}).passthrough(), TC = bu.extend({
  payload: uf.required({ data: !0, entities: !0 })
}).passthrough().describe("Legacy intent request type that `general-runtime` expects Alexa to send"), yC = bu.extend({
  payload: uf.omit({ data: !0 }).required({ entities: !0 })
}).passthrough().describe("The legacy intent request type that `general-runtime` expects from its clients."), _C = Dr.extend({
  type: F.literal(Zr.LAUNCH),
  payload: F.object({
    persona: F.string().optional()
  }).passthrough().optional()
}).passthrough(), CC = Dr.omit({ payload: !0 }).extend({
  type: F.literal(Zr.NO_REPLY)
}).passthrough(), Vg = Dr.extend({
  type: F.literal(Zr.TEXT),
  payload: F.string()
}).passthrough(), lg = (e) => Vg.safeParse(e).success;
F.union([
  bC,
  TC,
  yC,
  ug,
  bu,
  _C,
  AC,
  CC,
  Vg
]);
Dr.omit({ payload: !0 }).extend({
  type: F.literal(Zr.EXIT_SCENARIO),
  payload: F.object({
    intentID: F.string()
  })
}).passthrough();
F.object({
  tts: F.boolean().optional(),
  stopAll: F.boolean().optional(),
  stripSSML: F.boolean().optional(),
  stopTypes: F.array(F.string()).optional(),
  selfDelegate: F.boolean().optional(),
  excludeTypes: F.array(F.string()).optional()
});
const cg = F.any(), Vn = {
  LOG: "log",
  END: "end",
  TEXT: "text",
  PATH: "path",
  FLOW: "flow",
  GOTO: "goto",
  SPEAK: "speak",
  BLOCK: "block",
  DEBUG: "debug",
  CHOICE: "choice",
  STREAM: "stream",
  VISUAL: "visual",
  CARD_V2: "cardV2",
  CAROUSEL: "carousel",
  NO_REPLY: "no-reply",
  ENTITY_FILLING: "entity-filling",
  CHANNEL_ACTION: "channel-action",
  KNOWLEDGE_BASE: "knowledgeBase"
}, SC = F.object({
  label: F.string().optional(),
  event: Dr.optional()
}), fg = F.object({
  name: F.string(),
  request: Dr.optional()
}), gn = F.object({
  type: F.nativeEnum(Vn),
  paths: F.array(SC).optional(),
  defaultPath: F.number().optional(),
  time: F.number().optional()
});
gn.extend({
  type: F.literal(Vn.BLOCK),
  payload: F.object({
    blockID: F.string()
  })
});
const dg = F.object({
  title: F.string(),
  buttons: F.array(fg),
  imageUrl: F.string().nullable(),
  description: F.object({
    text: F.string(),
    // slate is optional, but text is required
    slate: cg.optional()
  })
}).partial(), xC = gn.extend({
  type: F.literal(Vn.CARD_V2),
  payload: dg
}), OC = gn.extend({
  type: F.literal(Vn.CAROUSEL),
  payload: F.object({
    cards: F.array(dg),
    layout: F.nativeEnum(hC)
  })
});
gn.extend({
  type: F.literal(Vn.CHANNEL_ACTION),
  payload: F.object({
    name: F.string(),
    payload: F.record(F.any())
  })
});
const wC = gn.extend({
  type: F.literal(Vn.CHOICE),
  payload: F.object({
    buttons: F.array(fg)
  })
});
gn.extend({
  type: F.literal(Vn.DEBUG),
  payload: F.object({
    type: F.string().optional(),
    message: F.string()
  })
});
gn.extend({
  type: F.literal(Vn.ENTITY_FILLING),
  payload: F.object({
    entityToFill: F.string(),
    intent: bu
  })
});
gn.extend({
  type: F.literal(Vn.END)
});
gn.extend({
  type: F.literal(Vn.FLOW),
  payload: F.object({
    name: F.string().optional(),
    diagramID: F.string()
  })
});
gn.extend({
  type: F.literal(Vn.GOTO),
  payload: F.object({
    request: Dr
  })
});
gn.extend({
  type: F.literal(Vn.LOG),
  // TODO: define this later
  payload: F.record(F.unknown())
});
gn.extend({
  type: F.literal(Vn.NO_REPLY),
  payload: F.object({
    timeout: F.number()
  })
});
const IC = {
  AUDIO: "audio",
  MESSAGE: "message"
};
gn.extend({
  type: F.literal(Vn.SPEAK),
  payload: F.object({
    src: F.string().nullable().optional(),
    type: F.nativeEnum(IC),
    voice: F.string().optional(),
    isPrompt: F.boolean().optional()
  })
});
const RC = {
  LOOP: "LOOP",
  PLAY: "PLAY",
  PAUSE: "PAUSE",
  END: "END"
};
gn.extend({
  type: F.literal(Vn.STREAM),
  payload: F.object({
    src: F.string(),
    token: F.string(),
    action: F.nativeEnum(RC),
    loop: F.boolean().optional(),
    title: F.string().optional(),
    iconImage: F.string().optional(),
    description: F.string().optional(),
    backgroundImage: F.string().optional()
  })
});
const NC = gn.extend({
  type: F.literal(Vn.TEXT),
  payload: F.object({
    slate: F.object({
      content: cg
    }),
    delay: F.number().optional()
  })
}), kC = F.object({
  visualType: F.literal(mC.IMAGE).optional(),
  image: F.string().nullable(),
  device: F.string().nullable().optional(),
  options: F.object({ loop: F.boolean().optional() }).optional(),
  frameType: F.string().optional(),
  dimensions: F.object({ width: F.number(), height: F.number() }).nullable().optional(),
  canvasVisibility: F.nativeEnum(dC).optional()
}), LC = gn.extend({
  type: F.literal(Vn.VISUAL),
  /**
   * APL is deprecated, so we only support Image for now.
   */
  payload: kC
});
var hg = function(t, n) {
  var r = "000000000" + t;
  return r.substr(r.length - n);
}, PC = hg, DC = typeof window == "object" ? window : self, MC = Object.keys(DC).length, FC = navigator.mimeTypes ? navigator.mimeTypes.length : 0, BC = PC((FC + navigator.userAgent.length).toString(36) + MC.toString(36), 4), $C = function() {
  return BC;
}, ul, Rh = typeof window < "u" && (window.crypto || window.msCrypto) || typeof self < "u" && self.crypto;
if (Rh) {
  var UC = Math.pow(2, 32) - 1;
  ul = function() {
    return Math.abs(Rh.getRandomValues(new Uint32Array(1))[0] / UC);
  };
} else
  ul = Math.random;
var HC = ul, Yo = $C, mg = hg, jC = HC, Vs = 0, Vf = 4, Wo = 36, pg = Math.pow(Wo, Vf);
function Vl() {
  return mg((jC() * pg << 0).toString(Wo), Vf);
}
function gg() {
  return Vs = Vs < pg ? Vs : 0, Vs++, Vs - 1;
}
function Js() {
  var e = "c", t = (/* @__PURE__ */ new Date()).getTime().toString(Wo), n = mg(gg().toString(Wo), Vf), r = Yo(), a = Vl() + Vl();
  return e + t + n + r + a;
}
Js.slug = function() {
  var t = (/* @__PURE__ */ new Date()).getTime().toString(36), n = gg().toString(36).slice(-4), r = Yo().slice(0, 1) + Yo().slice(-1), a = Vl().slice(-2);
  return t.slice(-2) + n + r + a;
};
Js.isCuid = function(t) {
  return typeof t != "string" ? !1 : !!t.startsWith("c");
};
Js.isSlug = function(t) {
  if (typeof t != "string")
    return !1;
  var n = t.length;
  return n >= 7 && n <= 10;
};
Js.fingerprint = Yo;
var zC = Js;
const Hs = /* @__PURE__ */ pn(zC);
var cn = /* @__PURE__ */ ((e) => (e.TEXT = "text", e.IMAGE = "image", e.CARD = "card", e.CAROUSEL = "carousel", e.END = "END", e.EXTENSION = "EXTENSION", e))(cn || {});
const js = 1e3, GC = () => Qc.os.name === "iOS", YC = () => {
  const e = globalThis.navigator;
  return e && e.brave !== void 0 ? e.brave.isBrave.name === "isBrave" : !1;
}, WC = () => !!getComputedStyle(document.documentElement).getPropertyValue("--arc-palette-title"), qC = () => !YC() && !WC() && Qc.browser.name === "Chrome", XC = (e) => typeof e == "function", KC = (e) => {
  const [t, n] = Jt(e), r = un(t), a = qr((i) => {
    r.current = XC(i) ? i(r.current) : i, n(r.current);
  }, []);
  return [t, a, r];
}, ZC = (e) => (t, n) => Jr(() => {
  const r = `voiceflow-chat-widget:${t}`;
  return {
    get: () => {
      try {
        const a = e.getItem(r);
        return a === null ? n : JSON.parse(a);
      } catch {
        return n;
      }
    },
    set: (a) => e.setItem(r, JSON.stringify(a)),
    clear: () => e.removeItem(r)
  };
}, []), QC = (e) => {
  const t = ZC(e);
  return (n, r) => {
    const a = t(n, r), [i, s] = Jt(a.get), o = un(i), u = qr((V) => {
      s((c) => {
        let f;
        return typeof V == "function" ? f = V(c) : f = V, a.set(f), o.current = f, f;
      });
    }, []);
    return [i, u, o];
  };
}, JC = QC(globalThis.localStorage);
var jn = {};
const eS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), tS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), nS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), rS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), aS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), iS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), sS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), oS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), uS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), VS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Buttons: tS,
  Capture: nS,
  CaptureV2: rS,
  CardV2: aS,
  Carousel: iS,
  Interaction: sS,
  Prompt: oS,
  Utils: uS
}, Symbol.toStringTag, { value: "Module" }));
var ll;
(function(e) {
  e.INTENT = "INTENT";
})(ll || (ll = {}));
var cl;
(function(e) {
  e.STACKED = "stacked", e.CAROUSEL = "carousel";
})(cl || (cl = {}));
const Nh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ButtonType() {
    return ll;
  },
  get ButtonsLayout() {
    return cl;
  }
}, Symbol.toStringTag, { value: "Module" })), bg = "VF.";
var zs;
(function(e) {
  e.Workspace = "WS", e.DialogManager = "DM";
})(zs || (zs = {}));
const Ag = (e) => (t) => typeof t == "string" && t.startsWith(`${bg}${e}.`), lS = Ag(zs.Workspace), cS = Ag(zs.DialogManager), fS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get APIKeySubType() {
    return zs;
  },
  API_KEY_PREFIX: bg,
  isDialogManagerAPIKey: cS,
  isWorkspaceAPIKey: lS
}, Symbol.toStringTag, { value: "Module" }));
var fl;
(function(e) {
  e.LUIS = "LUIS", e.VFNLU = "VFNLU";
})(fl || (fl = {}));
var qo;
(function(e) {
  e.CURVED = "CURVED", e.STRAIGHT = "STRAIGHT";
})(qo || (qo = {}));
var dl;
(function(e) {
  e.BLOCK = "block", e.ACTIONS = "actions";
})(dl || (dl = {}));
var hl;
(function(e) {
  e.INTENT = "INTENT";
})(hl || (hl = {}));
var ml;
(function(e) {
  e.FAIL = "fail", e.NEXT = "next", e.PAUSE = "pause", e.NO_REPLY = "no-reply", e.NO_MATCH = "else", e.PREVIOUS = "previous";
})(ml || (ml = {}));
var pl;
(function(e) {
  e.TOPIC = "TOPIC", e.GROUP = "GROUP", e.COMPONENT = "COMPONENT", e.TEMPLATE = "TEMPLATE";
})(pl || (pl = {}));
var gl;
(function(e) {
  e.NODE = "NODE", e.DIAGRAM = "DIAGRAM";
})(gl || (gl = {}));
const dS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get DiagramType() {
    return pl;
  },
  get MenuItemType() {
    return gl;
  }
}, Symbol.toStringTag, { value: "Module" })), hS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var bl;
(function(e) {
  e.PDF = "pdf", e.TEXT = "text", e.URL = "url", e.DOCX = "docx", e.TABLE = "table";
})(bl || (bl = {}));
var Al;
(function(e) {
  e.DAILY = "daily", e.WEEKLY = "weekly", e.MONTHLY = "monthly", e.NEVER = "never";
})(Al || (Al = {}));
var El;
(function(e) {
  e.AND = "and", e.OR = "or";
})(El || (El = {}));
var vl;
(function(e) {
  e.ZENDESK = "zendesk";
})(vl || (vl = {}));
var Tl;
(function(e) {
  e.ERROR = "ERROR", e.SUCCESS = "SUCCESS", e.PENDING = "PENDING", e.INITIALIZED = "INITIALIZED";
})(Tl || (Tl = {}));
var yl;
(function(e) {
  e.RECURSIVE_TEXT_SPLITTER = "recursive_text_splitter";
})(yl || (yl = {}));
var _l;
(function(e) {
  e.PUBLIC = "public", e.PRIVATE = "private";
})(_l || (_l = {}));
var Cl;
(function(e) {
  e.VF_NLU = "VF_NLU", e.VF_NLU_LLM_HYBRID = "VF_NLU_LLM_HYBRID";
})(Cl || (Cl = {}));
const mS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ChunkStrategyType() {
    return yl;
  },
  get ClassifyStrategy() {
    return Cl;
  },
  get IntegrationTypes() {
    return vl;
  },
  get KnowledgeBaseBooleanOperators() {
    return El;
  },
  get KnowledgeBaseDocumentRefreshRate() {
    return Al;
  },
  get KnowledgeBaseDocumentStatus() {
    return Tl;
  },
  get KnowledgeBaseDocumentType() {
    return bl;
  },
  get LinkType() {
    return qo;
  },
  get Privacy() {
    return _l;
  }
}, Symbol.toStringTag, { value: "Module" })), pS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), gS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), bS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), AS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Sl;
(function(e) {
  e.DESIGN = "DESIGN", e.REVIEW = "REVIEW", e.COMPLETE = "COMPLETE";
})(Sl || (Sl = {}));
var xl;
(function(e) {
  e.CONVERSATION = "conversation", e.PROTOTYPE = "prototype", e.NLU_DATASOURCE_IMPORT = "nluDatasourceImport";
})(xl || (xl = {}));
var Ol;
(function(e) {
  e.FOLDER = "FOLDER", e.DIAGRAM = "DIAGRAM";
})(Ol || (Ol = {}));
const ES = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get DomainStatus() {
    return Sl;
  },
  get FolderItemType() {
    return Ol;
  },
  get NLUUnclassifiedDataType() {
    return xl;
  }
}, Symbol.toStringTag, { value: "Module" })), kh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ApiKey: fS,
  get BaseNodeType() {
    return dl;
  },
  Diagram: dS,
  get LinkType() {
    return qo;
  },
  get NoteType() {
    return hl;
  },
  get PortType() {
    return ml;
  },
  Program: hS,
  Project: mS,
  get ProjectNLP() {
    return fl;
  },
  ProjectSecret: pS,
  RefreshJob: gS,
  Transcript: bS,
  VariableState: AS,
  Version: ES
}, Symbol.toStringTag, { value: "Module" })), vS = "stopTypes", TS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _V1_STOP_TYPES: vS
}, Symbol.toStringTag, { value: "Module" })), yS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), _S = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), CS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var wl;
(function(e) {
  e.FORM_DATA = "formData", e.RAW_INPUT = "rawInput", e.URL_ENCODED = "urlEncoded";
})(wl || (wl = {}));
var Il;
(function(e) {
  e.GET = "GET", e.PUT = "PUT", e.POST = "POST", e.PATCH = "PATCH", e.DELETE = "DELETE";
})(Il || (Il = {}));
const SS = (e) => e.toLowerCase();
var Rl;
(function(e) {
  e.GET = "Make a GET Request", e.PUT = "Make a PUT Request", e.POST = "Make a POST Request", e.PATCH = "Make a PATCH Request", e.DELETE = "Make a DELETE Request";
})(Rl || (Rl = {}));
const xS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get APIActionType() {
    return Rl;
  },
  get APIBodyType() {
    return wl;
  },
  get APIMethod() {
    return Il;
  },
  lowercaseAPIMethod: SS
}, Symbol.toStringTag, { value: "Module" }));
var Nl;
(function(e) {
  e.URL = "URL", e.PATH = "PATH", e.INTENT = "INTENT";
})(Nl || (Nl = {}));
const OS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ButtonAction() {
    return Nl;
  }
}, Symbol.toStringTag, { value: "Module" })), wS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var kl;
(function(e) {
  e.INTENT = "intent", e.QUERY = "query";
})(kl || (kl = {}));
const IS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get CaptureType() {
    return kl;
  }
}, Symbol.toStringTag, { value: "Module" }));
var Ll;
(function(e) {
  e.SIMPLE = "Simple", e.STANDARD = "Standard";
})(Ll || (Ll = {}));
const RS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get CardType() {
    return Ll;
  }
}, Symbol.toStringTag, { value: "Module" })), NS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Pl;
(function(e) {
  e.CAROUSEL = "Carousel", e.LIST = "List";
})(Pl || (Pl = {}));
const kS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get CarouselLayout() {
    return Pl;
  }
}, Symbol.toStringTag, { value: "Module" })), LS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), PS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), DS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var ne;
(function(e) {
  e.TEXT = "text", e.SPEAK = "speak", e.START = "start", e.CARD = "card", e.CARD_V2 = "cardV2", e.CAROUSEL = "carousel", e.BUTTONS = "buttons", e.INTERACTION = "interaction", e.AI_CAPTURE = "ai_capture", e.AI_RESPONSE = "generative", e.AI_SET = "ai_set", e.SET = "set", e.SET_V2 = "setV2", e.IF = "if", e.IF_V2 = "ifV2", e.RANDOM = "random", e.RANDOM_V2 = "randomV2", e.CAPTURE = "capture", e.CAPTURE_V2 = "captureV2", e.GOTO = "goTo", e.GOTO_NODE = "goToNode", e.GOTO_DOMAIN = "goToDomain", e.API = "api", e.ZAPIER = "zapier", e.INTEGRATIONS = "integrations", e.GOOGLE_SHEETS = "google_sheets", e.INTENT = "intent", e.FLOW = "flow", e.COMPONENT = "component", e.CODE = "code", e.EXIT = "exit", e.PROMPT = "prompt", e.COMMAND = "command", e.TRACE = "trace", e.CHANNEL_ACTION = "channel_action", e.CUSTOM_BLOCK_POINTER = "custom_block_pointer", e.URL = "url", e.STREAM = "stream", e.VISUAL = "visual", e.GENERAL = "general", e.DIRECTIVE = "directive", e.DEPRECATED = "deprecated";
})(ne || (ne = {}));
const Eg = [ne.GOTO], MS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), FS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), BS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), $S = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), US = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Dl;
(function(e) {
  e.CREATE_DATA = "Create Data", e.UPDATE_DATA = "Update Data", e.DELETE_DATA = "Delete Data", e.RETRIEVE_DATA = "Retrieve Data";
})(Dl || (Dl = {}));
const HS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get GoogleSheetsActionType() {
    return Dl;
  }
}, Symbol.toStringTag, { value: "Module" })), jS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), zS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), GS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), YS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Ml;
(function(e) {
  e.PATH = "path", e.NONE = "none";
})(Ml || (Ml = {}));
const WS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get IfNoMatchType() {
    return Ml;
  }
}, Symbol.toStringTag, { value: "Module" })), qS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Fl;
(function(e) {
  e.PATH = "PATH", e.GO_TO = "GO_TO";
})(Fl || (Fl = {}));
const XS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ChoiceAction() {
    return Fl;
  }
}, Symbol.toStringTag, { value: "Module" }));
var Bl;
(function(e) {
  e.LOCAL = "LOCAL", e.GLOBAL = "GLOBAL";
})(Bl || (Bl = {}));
const KS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get IntentAvailability() {
    return Bl;
  }
}, Symbol.toStringTag, { value: "Module" })), ZS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), QS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var $l;
(function(e) {
  e[e.DEFAULT = 1] = "DEFAULT", e[e.DO_DUPLICATES = 2] = "DO_DUPLICATES";
})($l || ($l = {}));
const JS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get RandomType() {
    return $l;
  }
}, Symbol.toStringTag, { value: "Module" }));
var Ul;
(function(e) {
  e[e.DEFAULT = 1] = "DEFAULT", e[e.DO_DUPLICATES = 2] = "DO_DUPLICATES";
})(Ul || (Ul = {}));
const e3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get RandomType() {
    return Ul;
  }
}, Symbol.toStringTag, { value: "Module" })), t3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), n3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Hl;
(function(e) {
  e.AUDIO = "audio", e.MESSAGE = "message";
})(Hl || (Hl = {}));
const r3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TraceSpeakType() {
    return Hl;
  }
}, Symbol.toStringTag, { value: "Module" })), a3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var jl;
(function(e) {
  e.LOOP = "LOOP", e.PLAY = "PLAY", e.PAUSE = "PAUSE", e.END = "END";
})(jl || (jl = {}));
const i3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TraceStreamAction() {
    return jl;
  }
}, Symbol.toStringTag, { value: "Module" })), s3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), o3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var zl;
(function(e) {
  e.PREVIEW = "preview", e.ALL_VARIANTS = "all-variants";
})(zl || (zl = {}));
var Gl;
(function(e) {
  e.JUMP = "jump", e.PUSH = "push";
})(Gl || (Gl = {}));
var Gs;
(function(e) {
  e.INTENT = "intent", e.ALEXA = "alexa";
})(Gs || (Gs = {}));
const u3 = (e) => e.type === Gs.INTENT, V3 = Object.values(Gs), l3 = (e) => !V3.includes(e.type);
var Yl;
(function(e) {
  e.EQUALS = "equals", e.GREATER = "greater", e.LESS = "less", e.AND = "and", e.OR = "or", e.VALUE = "value", e.VARIABLE = "variable", e.ADVANCE = "advance", e.PLUS = "plus", e.MINUS = "minus", e.TIMES = "times", e.DIVIDE = "divide", e.NOT = "not";
})(Yl || (Yl = {}));
var Wl;
(function(e) {
  e.EQUALS = "equals", e.GREATER = "greater", e.LESS = "less", e.AND = "and", e.OR = "or", e.VALUE = "value", e.VARIABLE = "variable", e.ADVANCE = "advance", e.NOT_EQUAL = "not_equal", e.GREATER_OR_EQUAL = "greater_or_equal", e.LESS_OR_EQUAL = "less_or_equal", e.CONTAINS = "contains", e.NOT_CONTAIN = "not_contain", e.STARTS_WITH = "starts_with", e.ENDS_WITH = "ends_with", e.HAS_VALUE = "has_value", e.IS_EMPTY = "is_empty";
})(Wl || (Wl = {}));
var ql;
(function(e) {
  e.VARIABLE = "variable", e.VALUE = "value", e.LOGIC_GROUP = "logic_group", e.EXPRESSION = "expression";
})(ql || (ql = {}));
var Xl;
(function(e) {
  e.ZAPIER = "Zapier", e.CUSTOM_API = "Custom API", e.GOOGLE_SHEETS = "Google Sheets";
})(Xl || (Xl = {}));
var Kl;
(function(e) {
  e.ZAPIER = "Zapier", e.GOOGLE_SHEETS = "Google Sheets";
})(Kl || (Kl = {}));
var Zl;
(function(e) {
  e.NODE = "NODE", e.GLOBAL = "GLOBAL";
})(Zl || (Zl = {}));
var Ql;
(function(e) {
  e.PATH = "path", e.REPROMPT = "reprompt", e.BOTH = "both";
})(Ql || (Ql = {}));
var Jl;
(function(e) {
  e.PATH = "path", e.REPROMPT = "reprompt";
})(Jl || (Jl = {}));
var Dn;
(function(e) {
  e.LOG = "log", e.END = "end", e.TEXT = "text", e.PATH = "path", e.FLOW = "flow", e.GOTO = "goto", e.SPEAK = "speak", e.BLOCK = "block", e.DEBUG = "debug", e.CHOICE = "choice", e.STREAM = "stream", e.VISUAL = "visual", e.CARD_V2 = "cardV2", e.CAROUSEL = "carousel", e.NO_REPLY = "no-reply", e.ENTITY_FILLING = "entity-filling", e.CHANNEL_ACTION = "channel-action", e.KNOWLEDGE_BASE = "knowledgeBase", e.COMPLETION_START = "completion-start", e.COMPLETION_CONTINUE = "completion-continue", e.COMPLETION_END = "completion-end";
})(Dn || (Dn = {}));
const c3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get CanvasNodeVisibility() {
    return zl;
  },
  get CommandType() {
    return Gl;
  },
  get ConditionsLogicInterface() {
    return ql;
  },
  get EventType() {
    return Gs;
  },
  get ExpressionType() {
    return Yl;
  },
  get ExpressionTypeV2() {
    return Wl;
  },
  get IntegrationPlatform() {
    return Kl;
  },
  get IntegrationType() {
    return Xl;
  },
  get IntentScope() {
    return Zl;
  },
  get NoMatchType() {
    return Ql;
  },
  get NoReplyType() {
    return Jl;
  },
  get TraceType() {
    return Dn;
  },
  isGeneralEvent: l3,
  isIntentEvent: u3
}, Symbol.toStringTag, { value: "Module" }));
var ec;
(function(e) {
  e.MOBILE = "mobile", e.TABLET = "tablet", e.DESKTOP = "desktop", e.SMART_WATCH = "smart_watch", e.TELEVISION = "television", e.IN_CAR_DISPLAY = "in_car_display", e.ECHO_SPOT = "echo_spot", e.ECHO_SHOW_8 = "echo_show_8", e.ECHO_SHOW_10 = "echo_show_10", e.FIRE_HD_8 = "fire_hd_8", e.FIRE_HD_10 = "fire_hd_10", e.FIRE_TV_CUBE = "fire_tv_cube", e.GOOGLE_NEST_HUB = "google_nest_hub";
})(ec || (ec = {}));
var tc;
(function(e) {
  e.FULL = "full", e.HIDDEN = "hidden", e.CROPPED = "cropped";
})(tc || (tc = {}));
var nc;
(function(e) {
  e.JSON = "JSON", e.SPLASH = "SPLASH";
})(nc || (nc = {}));
var rc;
(function(e) {
  e.APL = "apl", e.IMAGE = "image";
})(rc || (rc = {}));
var ac;
(function(e) {
  e.AUTO = "AUTO", e.DEVICE = "DEVICE", e.CUSTOM_SIZE = "CUSTOM_SIZE";
})(ac || (ac = {}));
const f3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get APLType() {
    return nc;
  },
  get CanvasVisibility() {
    return tc;
  },
  get DeviceType() {
    return ec;
  },
  get FrameType() {
    return ac;
  },
  get VisualType() {
    return rc;
  }
}, Symbol.toStringTag, { value: "Module" }));
var ic;
(function(e) {
  e.START_A_ZAP = "Start a Zap";
})(ic || (ic = {}));
const d3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ZapierActionType() {
    return ic;
  }
}, Symbol.toStringTag, { value: "Module" })), Lh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AICapture: yS,
  AIResponse: _S,
  AISet: CS,
  Api: xS,
  Buttons: OS,
  Capture: wS,
  CaptureV2: IS,
  Card: RS,
  CardV2: NS,
  Carousel: kS,
  ChannelAction: LS,
  Code: PS,
  Command: QS,
  Component: DS,
  CustomBlockPointer: MS,
  Directive: FS,
  Exit: BS,
  Flow: $S,
  General: US,
  GoTo: jS,
  GoToDomain: zS,
  GoToNode: GS,
  GoogleSheets: HS,
  If: YS,
  IfV2: WS,
  Integration: qS,
  Intent: KS,
  Interaction: XS,
  get NodeType() {
    return ne;
  },
  Prompt: ZS,
  RUNTIME_ONLY_NODES: Eg,
  Random: JS,
  RandomV2: e3,
  Set: t3,
  SetV2: n3,
  Speak: r3,
  Start: a3,
  Stream: i3,
  Text: s3,
  Url: o3,
  Utils: c3,
  Visual: f3,
  Zapier: d3,
  _v1: TS
}, Symbol.toStringTag, { value: "Module" })), vg = (e = {}) => ({ ...e }), Ph = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultPlatformData: vg
}, Symbol.toStringTag, { value: "Module" }));
var Xo;
(function(e) {
  e.OPEN_URL = "open_url";
})(Xo || (Xo = {}));
const Tg = (e) => e.type === Xo.OPEN_URL, h3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ActionType() {
    return Xo;
  },
  isOpenURLAction: Tg
}, Symbol.toStringTag, { value: "Module" }));
var Tr;
(function(e) {
  e.TEXT = "text", e.ACTION = "action", e.INTENT = "intent", e.LAUNCH = "launch", e.NO_REPLY = "no-reply";
})(Tr || (Tr = {}));
const m3 = (e) => e.type === Tr.TEXT, p3 = (e) => e.type === Tr.ACTION, g3 = (e) => e.type === Tr.LAUNCH, b3 = (e) => e.type === Tr.NO_REPLY, A3 = (e) => e.type === Tr.INTENT, E3 = Object.values(Tr), v3 = (e) => !E3.includes(e.type), Dh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Action: h3,
  get RequestType() {
    return Tr;
  },
  isActionRequest: p3,
  isGeneralRequest: v3,
  isIntentRequest: A3,
  isLaunchRequest: g3,
  isNoReplyRequest: b3,
  isTextRequest: m3
}, Symbol.toStringTag, { value: "Module" })), T3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Bt;
(function(e) {
  e.TEXT = "text", e.SPEAK = "speak", e.AUDIO = "audio", e.VISUALS = "visuals", e.CARD = "card", e.CAROUSEL = "carousel", e.BUTTONS = "buttons", e.CHOICE = "choice", e.CAPTURE = "capture", e.PROMPT = "prompt", e.INTENT = "intent", e.CONDITION = "condition", e.SET = "set", e.RANDOM = "random", e.FLOW = "flow", e.EXIT = "exit", e.API = "api", e.GOOGLE_SHEETS = "google_sheets", e.CUSTOM_CODE = "custom_code", e.CUSTOM_ACTION = "custom_action", e.START = "start";
})(Bt || (Bt = {}));
var sc;
(function(e) {
  e.CONVERSATION_START = "conversation_start", e.NLU_INTENT_RESOLVED = "nlu.intent_resolved";
})(sc || (sc = {}));
const Mh = {
  [ne.TEXT]: Bt.TEXT,
  [ne.SPEAK]: Bt.SPEAK,
  [ne.START]: Bt.START,
  [ne.CARD]: Bt.CARD,
  [ne.CAROUSEL]: Bt.CAROUSEL,
  [ne.BUTTONS]: Bt.BUTTONS,
  [ne.SET]: Bt.SET,
  [ne.SET_V2]: Bt.SET,
  [ne.IF]: Bt.CONDITION,
  [ne.IF_V2]: Bt.CONDITION,
  [ne.RANDOM]: Bt.RANDOM,
  [ne.CAPTURE]: Bt.CAPTURE,
  [ne.CAPTURE_V2]: Bt.CAPTURE,
  [ne.API]: Bt.API,
  /** @deprecated */
  [ne.GOOGLE_SHEETS]: Bt.GOOGLE_SHEETS,
  [ne.INTENT]: Bt.INTENT,
  [ne.CODE]: Bt.CUSTOM_CODE,
  [ne.EXIT]: Bt.EXIT,
  [ne.PROMPT]: Bt.PROMPT,
  [ne.VISUAL]: Bt.VISUALS
};
function y3(e) {
  return e in Mh ? Mh[e] : void 0;
}
const _3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get GlobalLogKind() {
    return sc;
  },
  get StepLogKind() {
    return Bt;
  },
  nodeTypeToStepLogKind: y3
}, Symbol.toStringTag, { value: "Module" }));
var Rr;
(function(e) {
  e.OFF = "off", e.ERROR = "error", e.WARN = "warn", e.INFO = "info", e.VERBOSE = "verbose";
})(Rr || (Rr = {}));
const C3 = {
  [Rr.OFF]: -1,
  [Rr.ERROR]: 0,
  [Rr.WARN]: 1,
  [Rr.INFO]: 2,
  [Rr.VERBOSE]: 3
}, S3 = (e) => C3[e], x3 = new Set(Object.values(Rr)), O3 = (e) => x3.has(e), w3 = Rr.INFO, I3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_LOG_LEVEL: w3,
  Kinds: _3,
  get LogLevel() {
    return Rr;
  },
  Logs: T3,
  getValueForLogLevel: S3,
  isLogLevel: O3
}, Symbol.toStringTag, { value: "Module" }));
var Fa;
(function(e) {
  e.BACKGROUND_COLOR = "backgroundColor", e.COLOR = "color", e.ITALIC = "italic", e.UNDERLINE = "underline", e.FONT_WEIGHT = "fontWeight", e.FONT_FAMILY = "fontFamily", e.STRIKE_THROUGH = "strikeThrough";
})(Fa || (Fa = {}));
var qa;
(function(e) {
  e.LINK = "link", e.VARIABLE = "variable";
})(qa || (qa = {}));
var oc;
(function(e) {
  e.TEXT_ALIGN = "textAlign";
})(oc || (oc = {}));
const R3 = (e) => e.type === qa.VARIABLE, N3 = (e) => e.type === qa.LINK, Fh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ElementProperty() {
    return oc;
  },
  get ElementType() {
    return qa;
  },
  get TextProperty() {
    return Fa;
  },
  isLinkElement: N3,
  isVariableElement: R3
}, Symbol.toStringTag, { value: "Module" })), Bh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TraceType() {
    return Dn;
  }
}, Symbol.toStringTag, { value: "Module" }));
var wi;
(function(e) {
  e.DaVinci_003 = "text-davinci-003", e.GPT_3_5_turbo = "gpt-3.5-turbo", e.GPT_4 = "gpt-4", e.GPT_4_turbo = "gpt-4-turbo", e.GPT_4o = "gpt-4o", e.CLAUDE_V1 = "claude-v1", e.CLAUDE_V2 = "claude-v2", e.CLAUDE_INSTANT_V1 = "claude-instant-v1";
})(wi || (wi = {}));
const k3 = [wi.GPT_3_5_turbo, wi.GPT_4, wi.GPT_4_turbo];
var uc;
(function(e) {
  e.PROMPT = "prompt", e.MEMORY = "memory", e.MEMORY_PROMPT = "memory_prompt";
})(uc || (uc = {}));
var Vc;
(function(e) {
  e.KNOWLEDGE_BASE = "knowledge_base", e.DEFAULT = "default";
})(Vc || (Vc = {}));
const L3 = "[not found]";
var lc;
(function(e) {
  e.SYSTEM = "system", e.ASSISTANT = "assistant", e.USER = "user";
})(lc || (lc = {}));
const P3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ChatModels: k3,
  get DATA_SOURCE() {
    return Vc;
  },
  get GPT_MODEL() {
    return wi;
  },
  KNOWLEDGE_BASE_NOT_FOUND: L3,
  get PROMPT_MODE() {
    return uc;
  },
  get Role() {
    return lc;
  }
}, Symbol.toStringTag, { value: "Module" }));
var $h;
(function(e) {
  e.PRODUCTION = "production", e.DEVELOPMENT = "development", e.LOCAL = "local", e.E2E = "e2e", e.TEST = "test", e.STAGING = "staging";
})($h || ($h = {}));
var D3 = { exports: {} };
function M3(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var TV = { exports: {} };
const F3 = {}, B3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: F3
}, Symbol.toStringTag, { value: "Module" })), $3 = /* @__PURE__ */ Zc(B3);
var Uh;
function yg() {
  return Uh || (Uh = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(bt, function() {
      var n = n || function(r, a) {
        var i;
        if (typeof window < "u" && window.crypto && (i = window.crypto), typeof self < "u" && self.crypto && (i = self.crypto), typeof globalThis < "u" && globalThis.crypto && (i = globalThis.crypto), !i && typeof window < "u" && window.msCrypto && (i = window.msCrypto), !i && typeof bt < "u" && bt.crypto && (i = bt.crypto), !i && typeof M3 == "function")
          try {
            i = $3;
          } catch {
          }
        var s = function() {
          if (i) {
            if (typeof i.getRandomValues == "function")
              try {
                return i.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof i.randomBytes == "function")
              try {
                return i.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, o = Object.create || /* @__PURE__ */ function() {
          function E() {
          }
          return function(S) {
            var $;
            return E.prototype = S, $ = new E(), E.prototype = null, $;
          };
        }(), u = {}, V = u.lib = {}, c = V.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(E) {
              var S = o(this);
              return E && S.mixIn(E), (!S.hasOwnProperty("init") || this.init === S.init) && (S.init = function() {
                S.$super.init.apply(this, arguments);
              }), S.init.prototype = S, S.$super = this, S;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var E = this.extend();
              return E.init.apply(E, arguments), E;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(E) {
              for (var S in E)
                E.hasOwnProperty(S) && (this[S] = E[S]);
              E.hasOwnProperty("toString") && (this.toString = E.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }(), f = V.WordArray = c.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(E, S) {
            E = this.words = E || [], S != a ? this.sigBytes = S : this.sigBytes = E.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(E) {
            return (E || h).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(E) {
            var S = this.words, $ = E.words, U = this.sigBytes, y = E.sigBytes;
            if (this.clamp(), U % 4)
              for (var j = 0; j < y; j++) {
                var q = $[j >>> 2] >>> 24 - j % 4 * 8 & 255;
                S[U + j >>> 2] |= q << 24 - (U + j) % 4 * 8;
              }
            else
              for (var Q = 0; Q < y; Q += 4)
                S[U + Q >>> 2] = $[Q >>> 2];
            return this.sigBytes += y, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var E = this.words, S = this.sigBytes;
            E[S >>> 2] &= 4294967295 << 32 - S % 4 * 8, E.length = r.ceil(S / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var E = c.clone.call(this);
            return E.words = this.words.slice(0), E;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(E) {
            for (var S = [], $ = 0; $ < E; $ += 4)
              S.push(s());
            return new f.init(S, E);
          }
        }), p = u.enc = {}, h = p.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(E) {
            for (var S = E.words, $ = E.sigBytes, U = [], y = 0; y < $; y++) {
              var j = S[y >>> 2] >>> 24 - y % 4 * 8 & 255;
              U.push((j >>> 4).toString(16)), U.push((j & 15).toString(16));
            }
            return U.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(E) {
            for (var S = E.length, $ = [], U = 0; U < S; U += 2)
              $[U >>> 3] |= parseInt(E.substr(U, 2), 16) << 24 - U % 8 * 4;
            return new f.init($, S / 2);
          }
        }, g = p.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(E) {
            for (var S = E.words, $ = E.sigBytes, U = [], y = 0; y < $; y++) {
              var j = S[y >>> 2] >>> 24 - y % 4 * 8 & 255;
              U.push(String.fromCharCode(j));
            }
            return U.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(E) {
            for (var S = E.length, $ = [], U = 0; U < S; U++)
              $[U >>> 2] |= (E.charCodeAt(U) & 255) << 24 - U % 4 * 8;
            return new f.init($, S);
          }
        }, b = p.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(E) {
            try {
              return decodeURIComponent(escape(g.stringify(E)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(E) {
            return g.parse(unescape(encodeURIComponent(E)));
          }
        }, v = V.BufferedBlockAlgorithm = c.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new f.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(E) {
            typeof E == "string" && (E = b.parse(E)), this._data.concat(E), this._nDataBytes += E.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(E) {
            var S, $ = this._data, U = $.words, y = $.sigBytes, j = this.blockSize, q = j * 4, Q = y / q;
            E ? Q = r.ceil(Q) : Q = r.max((Q | 0) - this._minBufferSize, 0);
            var I = Q * j, ie = r.min(I * 4, y);
            if (I) {
              for (var z = 0; z < I; z += j)
                this._doProcessBlock(U, z);
              S = U.splice(0, I), $.sigBytes -= ie;
            }
            return new f.init(S, ie);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var E = c.clone.call(this);
            return E._data = this._data.clone(), E;
          },
          _minBufferSize: 0
        });
        V.Hasher = v.extend({
          /**
           * Configuration options.
           */
          cfg: c.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(E) {
            this.cfg = this.cfg.extend(E), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            v.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(E) {
            return this._append(E), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(E) {
            E && this._append(E);
            var S = this._doFinalize();
            return S;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(E) {
            return function(S, $) {
              return new E.init($).finalize(S);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(E) {
            return function(S, $) {
              return new x.HMAC.init(E, $).finalize(S);
            };
          }
        });
        var x = u.algo = {};
        return u;
      }(Math);
      return n;
    });
  }(TV)), TV.exports;
}
(function(e, t) {
  (function(n, r) {
    e.exports = r(yg());
  })(bt, function(n) {
    return function() {
      var r = n, a = r.lib, i = a.WordArray, s = r.enc;
      s.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function(u) {
          var V = u.words, c = u.sigBytes, f = this._map;
          u.clamp();
          for (var p = [], h = 0; h < c; h += 3)
            for (var g = V[h >>> 2] >>> 24 - h % 4 * 8 & 255, b = V[h + 1 >>> 2] >>> 24 - (h + 1) % 4 * 8 & 255, v = V[h + 2 >>> 2] >>> 24 - (h + 2) % 4 * 8 & 255, x = g << 16 | b << 8 | v, E = 0; E < 4 && h + E * 0.75 < c; E++)
              p.push(f.charAt(x >>> 6 * (3 - E) & 63));
          var S = f.charAt(64);
          if (S)
            for (; p.length % 4; )
              p.push(S);
          return p.join("");
        },
        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function(u) {
          var V = u.length, c = this._map, f = this._reverseMap;
          if (!f) {
            f = this._reverseMap = [];
            for (var p = 0; p < c.length; p++)
              f[c.charCodeAt(p)] = p;
          }
          var h = c.charAt(64);
          if (h) {
            var g = u.indexOf(h);
            g !== -1 && (V = g);
          }
          return o(u, V, f);
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
      };
      function o(u, V, c) {
        for (var f = [], p = 0, h = 0; h < V; h++)
          if (h % 4) {
            var g = c[u.charCodeAt(h - 1)] << h % 4 * 2, b = c[u.charCodeAt(h)] >>> 6 - h % 4 * 2, v = g | b;
            f[p >>> 2] |= v << 24 - p % 4 * 8, p++;
          }
        return i.create(f, p);
      }
    }(), n.enc.Base64;
  });
})(D3);
var U3 = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r(yg());
  })(bt, function(n) {
    return n.enc.Utf8;
  });
})(U3);
var yV = Math.floor(Math.random() * 16777215), Hh = St.index = parseInt(Math.random() * 16777215, 10), jh = (typeof process > "u" || typeof process.pid != "number" ? Math.floor(Math.random() * 1e5) : process.pid) % 65535, Oo = function(e) {
  return !!(e != null && e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e));
}, _g = [];
for (var Hn = 0; Hn < 256; Hn++)
  _g[Hn] = (Hn <= 15 ? "0" : "") + Hn.toString(16);
var zh = new RegExp("^[0-9a-fA-F]{24}$"), Ys = [];
Hn = 0;
for (; Hn < 10; )
  Ys[48 + Hn] = Hn++;
for (; Hn < 16; )
  Ys[55 + Hn] = Ys[87 + Hn] = Hn++;
function St(e) {
  if (!(this instanceof St))
    return new St(e);
  if (e && (e instanceof St || e._bsontype === "ObjectID"))
    return e;
  if (this._bsontype = "ObjectID", e == null || typeof e == "number") {
    this.id = this.generate(e);
    return;
  }
  var t = St.isValid(e);
  if (!t && e != null)
    throw new Error(
      "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
    );
  if (t && typeof e == "string" && e.length === 24)
    return St.createFromHexString(e);
  if (e != null && e.length === 12)
    this.id = e;
  else {
    if (e != null && typeof e.toHexString == "function")
      return e;
    throw new Error(
      "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
    );
  }
}
St.default = St;
St.createFromTime = function(e) {
  return e = parseInt(e, 10) % 4294967295, new St(j3(8, e) + "0000000000000000");
};
St.createFromHexString = function(e) {
  if (typeof e > "u" || e != null && e.length !== 24)
    throw new Error(
      "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
    );
  for (var t = "", n = 0; n < 24; )
    t += String.fromCharCode(Ys[e.charCodeAt(n++)] << 4 | Ys[e.charCodeAt(n++)]);
  return new St(t);
};
St.isValid = function(e) {
  return e == null ? !1 : typeof e == "number" ? !0 : typeof e == "string" ? e.length === 12 || e.length === 24 && zh.test(e) : e instanceof St || Oo(e) ? !0 : typeof e.toHexString == "function" && (e.id instanceof _Buffer || typeof e.id == "string") ? e.id.length === 12 || e.id.length === 24 && zh.test(e.id) : !1;
};
St.prototype = {
  constructor: St,
  /**
   * Return the ObjectID id as a 24 byte hex string representation
   *
   * @return {String} return the 24 byte hex string representation.
   * @api public
   */
  toHexString: function() {
    if (!this.id || !this.id.length)
      throw new Error(
        "invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]"
      );
    if (this.id.length === 24)
      return this.id;
    if (Oo(this.id))
      return this.id.toString("hex");
    for (var e = "", t = 0; t < this.id.length; t++)
      e += _g[this.id.charCodeAt(t)];
    return e;
  },
  /**
   * Compares the equality of this ObjectID with `otherID`.
   *
   * @param {Object} otherId ObjectID instance to compare against.
   * @return {Boolean} the result of comparing two ObjectID's
   * @api public
   */
  equals: function(e) {
    return e instanceof St ? this.toString() === e.toString() : typeof e == "string" && St.isValid(e) && e.length === 12 && Oo(this.id) ? e === this.id.toString("binary") : typeof e == "string" && St.isValid(e) && e.length === 24 ? e.toLowerCase() === this.toHexString() : typeof e == "string" && St.isValid(e) && e.length === 12 ? e === this.id : e != null && (e instanceof St || e.toHexString) ? e.toHexString() === this.toHexString() : !1;
  },
  /**
   * Returns the generation date (accurate up to the second) that this ID was generated.
   *
   * @return {Date} the generation date
   * @api public
   */
  getTimestamp: function() {
    var e = /* @__PURE__ */ new Date(), t;
    return Oo(this.id) ? t = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24 : t = this.id.charCodeAt(3) | this.id.charCodeAt(2) << 8 | this.id.charCodeAt(1) << 16 | this.id.charCodeAt(0) << 24, e.setTime(Math.floor(t) * 1e3), e;
  },
  /**
  * Generate a 12 byte id buffer used in ObjectID's
  *
  * @method
  * @param {number} [time] optional parameter allowing to pass in a second based timestamp.
  * @return {string} return the 12 byte id buffer string.
  */
  generate: function(e) {
    typeof e != "number" && (e = ~~(Date.now() / 1e3)), e = parseInt(e, 10) % 4294967295;
    var t = H3();
    return String.fromCharCode(
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      yV >> 16 & 255,
      yV >> 8 & 255,
      yV & 255,
      jh >> 8 & 255,
      jh & 255,
      t >> 16 & 255,
      t >> 8 & 255,
      t & 255
    );
  }
};
function H3() {
  return Hh = (Hh + 1) % 16777215;
}
function j3(e, t) {
  return t = t.toString(16), t.length === e ? t : "00000000".substring(t.length, e) + t;
}
var z3 = Symbol && Symbol.for && Symbol.for("nodejs.util.inspect.custom") || "inspect";
St.prototype[z3] = function() {
  return "ObjectID(" + this + ")";
};
St.prototype.toJSON = St.prototype.toHexString;
St.prototype.toString = St.prototype.toHexString;
var G3 = typeof bt == "object" && bt && bt.Object === Object && bt, Cg = G3, Y3 = Cg, W3 = typeof self == "object" && self && self.Object === Object && self, q3 = Y3 || W3 || Function("return this")(), ea = q3, X3 = ea, K3 = X3.Symbol, Au = K3, Gh = Au, Sg = Object.prototype, Z3 = Sg.hasOwnProperty, Q3 = Sg.toString, ls = Gh ? Gh.toStringTag : void 0;
function J3(e) {
  var t = Z3.call(e, ls), n = e[ls];
  try {
    e[ls] = void 0;
    var r = !0;
  } catch {
  }
  var a = Q3.call(e);
  return r && (t ? e[ls] = n : delete e[ls]), a;
}
var ex = J3, tx = Object.prototype, nx = tx.toString;
function rx(e) {
  return nx.call(e);
}
var ax = rx, Yh = Au, ix = ex, sx = ax, ox = "[object Null]", ux = "[object Undefined]", Wh = Yh ? Yh.toStringTag : void 0;
function Vx(e) {
  return e == null ? e === void 0 ? ux : ox : Wh && Wh in Object(e) ? ix(e) : sx(e);
}
var lf = Vx;
function lx(e) {
  return e != null && typeof e == "object";
}
var xg = lx, cx = Function.prototype, fx = cx.toString;
fx.call(Object);
const dx = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
function hx(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var Og = hx, mx = lf, px = xg, gx = "[object Arguments]";
function bx(e) {
  return px(e) && mx(e) == gx;
}
var Ax = bx, qh = Ax, Ex = xg, wg = Object.prototype, vx = wg.hasOwnProperty, Tx = wg.propertyIsEnumerable;
qh(/* @__PURE__ */ function() {
  return arguments;
}());
var Ko = { exports: {} };
function yx() {
  return !1;
}
var _x = yx;
Ko.exports;
(function(e, t) {
  var n = ea, r = _x, a = t && !t.nodeType && t, i = a && !0 && e && !e.nodeType && e, s = i && i.exports === a, o = s ? n.Buffer : void 0, u = o ? o.isBuffer : void 0, V = u || r;
  e.exports = V;
})(Ko, Ko.exports);
Ko.exports;
var Zo = { exports: {} };
Zo.exports;
(function(e, t) {
  var n = Cg, r = t && !t.nodeType && t, a = r && !0 && e && !e.nodeType && e, i = a && a.exports === r, s = i && n.process, o = function() {
    try {
      var u = a && a.require && a.require("util").types;
      return u || s && s.binding && s.binding("util");
    } catch {
    }
  }();
  e.exports = o;
})(Zo, Zo.exports);
var Cx = Zo.exports, Xh = Cx;
Xh && Xh.isTypedArray;
var Sx = lf, xx = Og, Ox = "[object AsyncFunction]", wx = "[object Function]", Ix = "[object GeneratorFunction]", Rx = "[object Proxy]";
function Nx(e) {
  if (!xx(e))
    return !1;
  var t = Sx(e);
  return t == wx || t == Ix || t == Ox || t == Rx;
}
var kx = Nx;
function Lx() {
  this.__data__ = [], this.size = 0;
}
var Px = Lx;
function Dx(e, t) {
  return e === t || e !== e && t !== t;
}
var Mx = Dx, Fx = Mx;
function Bx(e, t) {
  for (var n = e.length; n--; )
    if (Fx(e[n][0], t))
      return n;
  return -1;
}
var Eu = Bx, $x = Eu, Ux = Array.prototype, Hx = Ux.splice;
function jx(e) {
  var t = this.__data__, n = $x(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : Hx.call(t, n, 1), --this.size, !0;
}
var zx = jx, Gx = Eu;
function Yx(e) {
  var t = this.__data__, n = Gx(t, e);
  return n < 0 ? void 0 : t[n][1];
}
var Wx = Yx, qx = Eu;
function Xx(e) {
  return qx(this.__data__, e) > -1;
}
var Kx = Xx, Zx = Eu;
function Qx(e, t) {
  var n = this.__data__, r = Zx(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
var Jx = Qx, e6 = Px, t6 = zx, n6 = Wx, r6 = Kx, a6 = Jx;
function $i(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
$i.prototype.clear = e6;
$i.prototype.delete = t6;
$i.prototype.get = n6;
$i.prototype.has = r6;
$i.prototype.set = a6;
var vu = $i, i6 = vu;
function s6() {
  this.__data__ = new i6(), this.size = 0;
}
var o6 = s6;
function u6(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
var V6 = u6;
function l6(e) {
  return this.__data__.get(e);
}
var c6 = l6;
function f6(e) {
  return this.__data__.has(e);
}
var d6 = f6, h6 = ea, m6 = h6["__core-js_shared__"], p6 = m6, _V = p6, Kh = function() {
  var e = /[^.]+$/.exec(_V && _V.keys && _V.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function g6(e) {
  return !!Kh && Kh in e;
}
var b6 = g6, A6 = Function.prototype, E6 = A6.toString;
function v6(e) {
  if (e != null) {
    try {
      return E6.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var Ig = v6, T6 = kx, y6 = b6, _6 = Og, C6 = Ig, S6 = /[\\^$.*+?()[\]{}|]/g, x6 = /^\[object .+?Constructor\]$/, O6 = Function.prototype, w6 = Object.prototype, I6 = O6.toString, R6 = w6.hasOwnProperty, N6 = RegExp(
  "^" + I6.call(R6).replace(S6, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function k6(e) {
  if (!_6(e) || y6(e))
    return !1;
  var t = T6(e) ? N6 : x6;
  return t.test(C6(e));
}
var L6 = k6;
function P6(e, t) {
  return e == null ? void 0 : e[t];
}
var D6 = P6, M6 = L6, F6 = D6;
function B6(e, t) {
  var n = F6(e, t);
  return M6(n) ? n : void 0;
}
var Ui = B6, $6 = Ui, U6 = ea, H6 = $6(U6, "Map"), cf = H6, j6 = Ui, z6 = j6(Object, "create"), Tu = z6, Zh = Tu;
function G6() {
  this.__data__ = Zh ? Zh(null) : {}, this.size = 0;
}
var Y6 = G6;
function W6(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var q6 = W6, X6 = Tu, K6 = "__lodash_hash_undefined__", Z6 = Object.prototype, Q6 = Z6.hasOwnProperty;
function J6(e) {
  var t = this.__data__;
  if (X6) {
    var n = t[e];
    return n === K6 ? void 0 : n;
  }
  return Q6.call(t, e) ? t[e] : void 0;
}
var eO = J6, tO = Tu, nO = Object.prototype, rO = nO.hasOwnProperty;
function aO(e) {
  var t = this.__data__;
  return tO ? t[e] !== void 0 : rO.call(t, e);
}
var iO = aO, sO = Tu, oO = "__lodash_hash_undefined__";
function uO(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = sO && t === void 0 ? oO : t, this;
}
var VO = uO, lO = Y6, cO = q6, fO = eO, dO = iO, hO = VO;
function Hi(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Hi.prototype.clear = lO;
Hi.prototype.delete = cO;
Hi.prototype.get = fO;
Hi.prototype.has = dO;
Hi.prototype.set = hO;
var mO = Hi, Qh = mO, pO = vu, gO = cf;
function bO() {
  this.size = 0, this.__data__ = {
    hash: new Qh(),
    map: new (gO || pO)(),
    string: new Qh()
  };
}
var AO = bO;
function EO(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
var vO = EO, TO = vO;
function yO(e, t) {
  var n = e.__data__;
  return TO(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
var yu = yO, _O = yu;
function CO(e) {
  var t = _O(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
var SO = CO, xO = yu;
function OO(e) {
  return xO(this, e).get(e);
}
var wO = OO, IO = yu;
function RO(e) {
  return IO(this, e).has(e);
}
var NO = RO, kO = yu;
function LO(e, t) {
  var n = kO(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
var PO = LO, DO = AO, MO = SO, FO = wO, BO = NO, $O = PO;
function ji(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
ji.prototype.clear = DO;
ji.prototype.delete = MO;
ji.prototype.get = FO;
ji.prototype.has = BO;
ji.prototype.set = $O;
var ff = ji, UO = vu, HO = cf, jO = ff, zO = 200;
function GO(e, t) {
  var n = this.__data__;
  if (n instanceof UO) {
    var r = n.__data__;
    if (!HO || r.length < zO - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new jO(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
var YO = GO, WO = vu, qO = o6, XO = V6, KO = c6, ZO = d6, QO = YO;
function eo(e) {
  var t = this.__data__ = new WO(e);
  this.size = t.size;
}
eo.prototype.clear = qO;
eo.prototype.delete = XO;
eo.prototype.get = KO;
eo.prototype.has = ZO;
eo.prototype.set = QO;
var JO = "__lodash_hash_undefined__";
function ew(e) {
  return this.__data__.set(e, JO), this;
}
var tw = ew;
function nw(e) {
  return this.__data__.has(e);
}
var rw = nw, aw = ff, iw = tw, sw = rw;
function cc(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new aw(); ++t < n; )
    this.add(e[t]);
}
cc.prototype.add = cc.prototype.push = iw;
cc.prototype.has = sw;
var ow = ea;
ow.Uint8Array;
function uw(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var Vw = uw, Jh = Au, e0 = Jh ? Jh.prototype : void 0;
e0 && e0.valueOf;
var lw = Ui, cw = ea, fw = lw(cw, "DataView"), dw = fw, hw = Ui, mw = ea, pw = hw(mw, "Promise"), gw = pw, bw = Ui, Aw = ea, Ew = bw(Aw, "Set"), Rg = Ew, vw = Ui, Tw = ea, yw = vw(Tw, "WeakMap"), _w = yw, fc = dw, dc = cf, hc = gw, mc = Rg, pc = _w, Ng = lf, zi = Ig, t0 = "[object Map]", Cw = "[object Object]", n0 = "[object Promise]", r0 = "[object Set]", a0 = "[object WeakMap]", i0 = "[object DataView]", Sw = zi(fc), xw = zi(dc), Ow = zi(hc), ww = zi(mc), Iw = zi(pc), Ei = Ng;
(fc && Ei(new fc(new ArrayBuffer(1))) != i0 || dc && Ei(new dc()) != t0 || hc && Ei(hc.resolve()) != n0 || mc && Ei(new mc()) != r0 || pc && Ei(new pc()) != a0) && (Ei = function(e) {
  var t = Ng(e), n = t == Cw ? e.constructor : void 0, r = n ? zi(n) : "";
  if (r)
    switch (r) {
      case Sw:
        return i0;
      case xw:
        return t0;
      case Ow:
        return n0;
      case ww:
        return r0;
      case Iw:
        return a0;
    }
  return t;
});
var kg = ff, Rw = "Expected a function";
function df(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(Rw);
  var n = function() {
    var r = arguments, a = t ? t.apply(this, r) : r[0], i = n.cache;
    if (i.has(a))
      return i.get(a);
    var s = e.apply(this, r);
    return n.cache = i.set(a, s) || i, s;
  };
  return n.cache = new (df.Cache || kg)(), n;
}
df.Cache = kg;
var Nw = df, kw = Nw, Lw = 500;
function Pw(e) {
  var t = kw(e, function(r) {
    return n.size === Lw && n.clear(), r;
  }), n = t.cache;
  return t;
}
var Dw = Pw, Mw = Dw, Fw = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Bw = /\\(\\)?/g;
Mw(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(Fw, function(n, r, a, i) {
    t.push(a ? i.replace(Bw, "$1") : r || n);
  }), t;
});
var s0 = Au, o0 = s0 ? s0.prototype : void 0;
o0 && o0.toString;
Array.from({ length: 26 }).map((e, t) => String.fromCharCode(97 + t));
function $w() {
}
var Uw = $w, CV = Rg, Hw = Uw, jw = Vw, zw = 1 / 0;
CV && 1 / jw(new CV([, -0]))[1] == zw;
var _u = {}, Gw = {};
Object.defineProperty(_u, "__esModule", { value: !0 });
function Yw(e, t) {
  return e.type === t.type;
}
_u.isType = Yw;
function Lg(e, t) {
  t === void 0 && (t = function(s) {
    return s instanceof Error;
  });
  var n = {}, r = e ? e + "/" : "";
  function a(s, o, u) {
    u === void 0 && (u = t);
    var V = r + s;
    if (Gw.NODE_ENV !== "production") {
      if (n[V])
        throw new Error("Duplicate action type: " + V);
      n[V] = !0;
    }
    return Object.assign(function(c, f) {
      var p = {
        type: V,
        payload: c
      };
      return (o || f) && (p.meta = Object.assign({}, o, f)), u && (typeof u == "boolean" || u(c)) && (p.error = !0), p;
    }, {
      type: V,
      toString: function() {
        return V;
      },
      match: function(c) {
        return c.type === V;
      }
    });
  }
  function i(s, o) {
    return {
      type: r + s,
      started: a(s + "_STARTED", o, !1),
      done: a(s + "_DONE", o, !1),
      failed: a(s + "_FAILED", o, !0)
    };
  }
  return Object.assign(a, { async: i });
}
var Ww = _u.actionCreatorFactory = Lg;
_u.default = Lg;
Ww();
var Pg = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    var n = 1e3, r = 6e4, a = 36e5, i = "millisecond", s = "second", o = "minute", u = "hour", V = "day", c = "week", f = "month", p = "quarter", h = "year", g = "date", b = "Invalid Date", v = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, x = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, E = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, S = function(H, P, N) {
      var K = String(H);
      return !K || K.length >= P ? H : "" + Array(P + 1 - K.length).join(N) + H;
    }, $ = { s: S, z: function(H) {
      var P = -H.utcOffset(), N = Math.abs(P), K = Math.floor(N / 60), D = N % 60;
      return (P <= 0 ? "+" : "-") + S(K, 2, "0") + ":" + S(D, 2, "0");
    }, m: function H(P, N) {
      if (P.date() < N.date())
        return -H(N, P);
      var K = 12 * (N.year() - P.year()) + (N.month() - P.month()), D = P.clone().add(K, f), J = N - D < 0, ee = P.clone().add(K + (J ? -1 : 1), f);
      return +(-(K + (N - D) / (J ? D - ee : ee - D)) || 0);
    }, a: function(H) {
      return H < 0 ? Math.ceil(H) || 0 : Math.floor(H);
    }, p: function(H) {
      return { M: f, y: h, w: c, d: V, D: g, h: u, m: o, s, ms: i, Q: p }[H] || String(H || "").toLowerCase().replace(/s$/, "");
    }, u: function(H) {
      return H === void 0;
    } }, U = "en", y = {};
    y[U] = E;
    var j = function(H) {
      return H instanceof ie;
    }, q = function(H, P, N) {
      var K;
      if (!H)
        return U;
      if (typeof H == "string")
        y[H] && (K = H), P && (y[H] = P, K = H);
      else {
        var D = H.name;
        y[D] = H, K = D;
      }
      return !N && K && (U = K), K || !N && U;
    }, Q = function(H, P) {
      if (j(H))
        return H.clone();
      var N = typeof P == "object" ? P : {};
      return N.date = H, N.args = arguments, new ie(N);
    }, I = $;
    I.l = q, I.i = j, I.w = function(H, P) {
      return Q(H, { locale: P.$L, utc: P.$u, x: P.$x, $offset: P.$offset });
    };
    var ie = function() {
      function H(N) {
        this.$L = q(N.locale, null, !0), this.parse(N);
      }
      var P = H.prototype;
      return P.parse = function(N) {
        this.$d = function(K) {
          var D = K.date, J = K.utc;
          if (D === null)
            return /* @__PURE__ */ new Date(NaN);
          if (I.u(D))
            return /* @__PURE__ */ new Date();
          if (D instanceof Date)
            return new Date(D);
          if (typeof D == "string" && !/Z$/i.test(D)) {
            var ee = D.match(v);
            if (ee) {
              var C = ee[2] - 1 || 0, ge = (ee[7] || "0").substring(0, 3);
              return J ? new Date(Date.UTC(ee[1], C, ee[3] || 1, ee[4] || 0, ee[5] || 0, ee[6] || 0, ge)) : new Date(ee[1], C, ee[3] || 1, ee[4] || 0, ee[5] || 0, ee[6] || 0, ge);
            }
          }
          return new Date(D);
        }(N), this.$x = N.x || {}, this.init();
      }, P.init = function() {
        var N = this.$d;
        this.$y = N.getFullYear(), this.$M = N.getMonth(), this.$D = N.getDate(), this.$W = N.getDay(), this.$H = N.getHours(), this.$m = N.getMinutes(), this.$s = N.getSeconds(), this.$ms = N.getMilliseconds();
      }, P.$utils = function() {
        return I;
      }, P.isValid = function() {
        return this.$d.toString() !== b;
      }, P.isSame = function(N, K) {
        var D = Q(N);
        return this.startOf(K) <= D && D <= this.endOf(K);
      }, P.isAfter = function(N, K) {
        return Q(N) < this.startOf(K);
      }, P.isBefore = function(N, K) {
        return this.endOf(K) < Q(N);
      }, P.$g = function(N, K, D) {
        return I.u(N) ? this[K] : this.set(D, N);
      }, P.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, P.valueOf = function() {
        return this.$d.getTime();
      }, P.startOf = function(N, K) {
        var D = this, J = !!I.u(K) || K, ee = I.p(N), C = function(Ye, Oe) {
          var We = I.w(D.$u ? Date.UTC(D.$y, Oe, Ye) : new Date(D.$y, Oe, Ye), D);
          return J ? We : We.endOf(V);
        }, ge = function(Ye, Oe) {
          return I.w(D.toDate()[Ye].apply(D.toDate("s"), (J ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Oe)), D);
        }, pe = this.$W, w = this.$M, De = this.$D, $e = "set" + (this.$u ? "UTC" : "");
        switch (ee) {
          case h:
            return J ? C(1, 0) : C(31, 11);
          case f:
            return J ? C(1, w) : C(0, w + 1);
          case c:
            var Me = this.$locale().weekStart || 0, ct = (pe < Me ? pe + 7 : pe) - Me;
            return C(J ? De - ct : De + (6 - ct), w);
          case V:
          case g:
            return ge($e + "Hours", 0);
          case u:
            return ge($e + "Minutes", 1);
          case o:
            return ge($e + "Seconds", 2);
          case s:
            return ge($e + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, P.endOf = function(N) {
        return this.startOf(N, !1);
      }, P.$set = function(N, K) {
        var D, J = I.p(N), ee = "set" + (this.$u ? "UTC" : ""), C = (D = {}, D[V] = ee + "Date", D[g] = ee + "Date", D[f] = ee + "Month", D[h] = ee + "FullYear", D[u] = ee + "Hours", D[o] = ee + "Minutes", D[s] = ee + "Seconds", D[i] = ee + "Milliseconds", D)[J], ge = J === V ? this.$D + (K - this.$W) : K;
        if (J === f || J === h) {
          var pe = this.clone().set(g, 1);
          pe.$d[C](ge), pe.init(), this.$d = pe.set(g, Math.min(this.$D, pe.daysInMonth())).$d;
        } else
          C && this.$d[C](ge);
        return this.init(), this;
      }, P.set = function(N, K) {
        return this.clone().$set(N, K);
      }, P.get = function(N) {
        return this[I.p(N)]();
      }, P.add = function(N, K) {
        var D, J = this;
        N = Number(N);
        var ee = I.p(K), C = function(w) {
          var De = Q(J);
          return I.w(De.date(De.date() + Math.round(w * N)), J);
        };
        if (ee === f)
          return this.set(f, this.$M + N);
        if (ee === h)
          return this.set(h, this.$y + N);
        if (ee === V)
          return C(1);
        if (ee === c)
          return C(7);
        var ge = (D = {}, D[o] = r, D[u] = a, D[s] = n, D)[ee] || 1, pe = this.$d.getTime() + N * ge;
        return I.w(pe, this);
      }, P.subtract = function(N, K) {
        return this.add(-1 * N, K);
      }, P.format = function(N) {
        var K = this, D = this.$locale();
        if (!this.isValid())
          return D.invalidDate || b;
        var J = N || "YYYY-MM-DDTHH:mm:ssZ", ee = I.z(this), C = this.$H, ge = this.$m, pe = this.$M, w = D.weekdays, De = D.months, $e = function(Oe, We, At, xt) {
          return Oe && (Oe[We] || Oe(K, J)) || At[We].substr(0, xt);
        }, Me = function(Oe) {
          return I.s(C % 12 || 12, Oe, "0");
        }, ct = D.meridiem || function(Oe, We, At) {
          var xt = Oe < 12 ? "AM" : "PM";
          return At ? xt.toLowerCase() : xt;
        }, Ye = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: pe + 1, MM: I.s(pe + 1, 2, "0"), MMM: $e(D.monthsShort, pe, De, 3), MMMM: $e(De, pe), D: this.$D, DD: I.s(this.$D, 2, "0"), d: String(this.$W), dd: $e(D.weekdaysMin, this.$W, w, 2), ddd: $e(D.weekdaysShort, this.$W, w, 3), dddd: w[this.$W], H: String(C), HH: I.s(C, 2, "0"), h: Me(1), hh: Me(2), a: ct(C, ge, !0), A: ct(C, ge, !1), m: String(ge), mm: I.s(ge, 2, "0"), s: String(this.$s), ss: I.s(this.$s, 2, "0"), SSS: I.s(this.$ms, 3, "0"), Z: ee };
        return J.replace(x, function(Oe, We) {
          return We || Ye[Oe] || ee.replace(":", "");
        });
      }, P.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, P.diff = function(N, K, D) {
        var J, ee = I.p(K), C = Q(N), ge = (C.utcOffset() - this.utcOffset()) * r, pe = this - C, w = I.m(this, C);
        return w = (J = {}, J[h] = w / 12, J[f] = w, J[p] = w / 3, J[c] = (pe - ge) / 6048e5, J[V] = (pe - ge) / 864e5, J[u] = pe / a, J[o] = pe / r, J[s] = pe / n, J)[ee] || pe, D ? w : I.a(w);
      }, P.daysInMonth = function() {
        return this.endOf(f).$D;
      }, P.$locale = function() {
        return y[this.$L];
      }, P.locale = function(N, K) {
        if (!N)
          return this.$L;
        var D = this.clone(), J = q(N, K, !0);
        return J && (D.$L = J), D;
      }, P.clone = function() {
        return I.w(this.$d, this);
      }, P.toDate = function() {
        return new Date(this.valueOf());
      }, P.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, P.toISOString = function() {
        return this.$d.toISOString();
      }, P.toString = function() {
        return this.$d.toUTCString();
      }, H;
    }(), z = ie.prototype;
    return Q.prototype = z, [["$ms", i], ["$s", s], ["$m", o], ["$H", u], ["$W", V], ["$M", f], ["$y", h], ["$D", g]].forEach(function(H) {
      z[H[1]] = function(P) {
        return this.$g(P, H[0], H[1]);
      };
    }), Q.extend = function(H, P) {
      return H.$i || (H(P, ie, Q), H.$i = !0), Q;
    }, Q.locale = q, Q.isDayjs = j, Q.unix = function(H) {
      return Q(1e3 * H);
    }, Q.en = y[U], Q.Ls = y, Q.p = {}, Q;
  });
})(Pg);
var qw = Pg.exports;
const Ta = /* @__PURE__ */ pn(qw);
var Dg = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    return function(n, r, a) {
      var i = r.prototype, s = i.format;
      a.en.ordinal = function(o) {
        var u = ["th", "st", "nd", "rd"], V = o % 100;
        return "[" + o + (u[(V - 20) % 10] || u[V] || u[0]) + "]";
      }, i.format = function(o) {
        var u = this, V = this.$locale();
        if (!this.isValid())
          return s.bind(this)(o);
        var c = this.$utils(), f = (o || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(p) {
          switch (p) {
            case "Q":
              return Math.ceil((u.$M + 1) / 3);
            case "Do":
              return V.ordinal(u.$D);
            case "gggg":
              return u.weekYear();
            case "GGGG":
              return u.isoWeekYear();
            case "wo":
              return V.ordinal(u.week(), "W");
            case "w":
            case "ww":
              return c.s(u.week(), p === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return c.s(u.isoWeek(), p === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return c.s(String(u.$H === 0 ? 24 : u.$H), p === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(u.$d.getTime() / 1e3);
            case "x":
              return u.$d.getTime();
            case "z":
              return "[" + u.offsetName() + "]";
            case "zzz":
              return "[" + u.offsetName("long") + "]";
            default:
              return p;
          }
        });
        return s.bind(this)(f);
      };
    };
  });
})(Dg);
var Xw = Dg.exports;
const Kw = /* @__PURE__ */ pn(Xw);
var Mg = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, r = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, a = /\d\d/, i = /\d\d?/, s = /\d*[^\s\d-_:/()]+/, o = {}, u = function(b) {
      return (b = +b) + (b > 68 ? 1900 : 2e3);
    }, V = function(b) {
      return function(v) {
        this[b] = +v;
      };
    }, c = [/[+-]\d\d:?(\d\d)?|Z/, function(b) {
      (this.zone || (this.zone = {})).offset = function(v) {
        if (!v || v === "Z")
          return 0;
        var x = v.match(/([+-]|\d\d)/g), E = 60 * x[1] + (+x[2] || 0);
        return E === 0 ? 0 : x[0] === "+" ? -E : E;
      }(b);
    }], f = function(b) {
      var v = o[b];
      return v && (v.indexOf ? v : v.s.concat(v.f));
    }, p = function(b, v) {
      var x, E = o.meridiem;
      if (E) {
        for (var S = 1; S <= 24; S += 1)
          if (b.indexOf(E(S, 0, v)) > -1) {
            x = S > 12;
            break;
          }
      } else
        x = b === (v ? "pm" : "PM");
      return x;
    }, h = { A: [s, function(b) {
      this.afternoon = p(b, !1);
    }], a: [s, function(b) {
      this.afternoon = p(b, !0);
    }], S: [/\d/, function(b) {
      this.milliseconds = 100 * +b;
    }], SS: [a, function(b) {
      this.milliseconds = 10 * +b;
    }], SSS: [/\d{3}/, function(b) {
      this.milliseconds = +b;
    }], s: [i, V("seconds")], ss: [i, V("seconds")], m: [i, V("minutes")], mm: [i, V("minutes")], H: [i, V("hours")], h: [i, V("hours")], HH: [i, V("hours")], hh: [i, V("hours")], D: [i, V("day")], DD: [a, V("day")], Do: [s, function(b) {
      var v = o.ordinal, x = b.match(/\d+/);
      if (this.day = x[0], v)
        for (var E = 1; E <= 31; E += 1)
          v(E).replace(/\[|\]/g, "") === b && (this.day = E);
    }], M: [i, V("month")], MM: [a, V("month")], MMM: [s, function(b) {
      var v = f("months"), x = (f("monthsShort") || v.map(function(E) {
        return E.substr(0, 3);
      })).indexOf(b) + 1;
      if (x < 1)
        throw new Error();
      this.month = x % 12 || x;
    }], MMMM: [s, function(b) {
      var v = f("months").indexOf(b) + 1;
      if (v < 1)
        throw new Error();
      this.month = v % 12 || v;
    }], Y: [/[+-]?\d+/, V("year")], YY: [a, function(b) {
      this.year = u(b);
    }], YYYY: [/\d{4}/, V("year")], Z: c, ZZ: c };
    function g(b) {
      var v, x;
      v = b, x = o && o.formats;
      for (var E = (b = v.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(Q, I, ie) {
        var z = ie && ie.toUpperCase();
        return I || x[ie] || n[ie] || x[z].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(H, P, N) {
          return P || N.slice(1);
        });
      })).match(r), S = E.length, $ = 0; $ < S; $ += 1) {
        var U = E[$], y = h[U], j = y && y[0], q = y && y[1];
        E[$] = q ? { regex: j, parser: q } : U.replace(/^\[|\]$/g, "");
      }
      return function(Q) {
        for (var I = {}, ie = 0, z = 0; ie < S; ie += 1) {
          var H = E[ie];
          if (typeof H == "string")
            z += H.length;
          else {
            var P = H.regex, N = H.parser, K = Q.substr(z), D = P.exec(K)[0];
            N.call(I, D), Q = Q.replace(D, "");
          }
        }
        return function(J) {
          var ee = J.afternoon;
          if (ee !== void 0) {
            var C = J.hours;
            ee ? C < 12 && (J.hours += 12) : C === 12 && (J.hours = 0), delete J.afternoon;
          }
        }(I), I;
      };
    }
    return function(b, v, x) {
      x.p.customParseFormat = !0, b && b.parseTwoDigitYear && (u = b.parseTwoDigitYear);
      var E = v.prototype, S = E.parse;
      E.parse = function($) {
        var U = $.date, y = $.utc, j = $.args;
        this.$u = y;
        var q = j[1];
        if (typeof q == "string") {
          var Q = j[2] === !0, I = j[3] === !0, ie = Q || I, z = j[2];
          I && (z = j[2]), o = this.$locale(), !Q && z && (o = x.Ls[z]), this.$d = function(K, D, J) {
            try {
              if (["x", "X"].indexOf(D) > -1)
                return new Date((D === "X" ? 1e3 : 1) * K);
              var ee = g(D)(K), C = ee.year, ge = ee.month, pe = ee.day, w = ee.hours, De = ee.minutes, $e = ee.seconds, Me = ee.milliseconds, ct = ee.zone, Ye = /* @__PURE__ */ new Date(), Oe = pe || (C || ge ? 1 : Ye.getDate()), We = C || Ye.getFullYear(), At = 0;
              C && !ge || (At = ge > 0 ? ge - 1 : Ye.getMonth());
              var xt = w || 0, en = De || 0, tn = $e || 0, An = Me || 0;
              return ct ? new Date(Date.UTC(We, At, Oe, xt, en, tn, An + 60 * ct.offset * 1e3)) : J ? new Date(Date.UTC(We, At, Oe, xt, en, tn, An)) : new Date(We, At, Oe, xt, en, tn, An);
            } catch {
              return /* @__PURE__ */ new Date("");
            }
          }(U, q, y), this.init(), z && z !== !0 && (this.$L = this.locale(z).$L), ie && U != this.format(q) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
        } else if (q instanceof Array)
          for (var H = q.length, P = 1; P <= H; P += 1) {
            j[1] = q[P - 1];
            var N = x.apply(this, j);
            if (N.isValid()) {
              this.$d = N.$d, this.$L = N.$L, this.init();
              break;
            }
            P === H && (this.$d = /* @__PURE__ */ new Date(""));
          }
        else
          S.call(this, $);
      };
    };
  });
})(Mg);
var Zw = Mg.exports;
const Qw = /* @__PURE__ */ pn(Zw);
var Fg = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    var n, r, a = 1e3, i = 6e4, s = 36e5, o = 864e5, u = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, V = 31536e6, c = 2592e6, f = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, p = { years: V, months: c, days: o, hours: s, minutes: i, seconds: a, milliseconds: 1, weeks: 6048e5 }, h = function(U) {
      return U instanceof $;
    }, g = function(U, y, j) {
      return new $(U, j, y.$l);
    }, b = function(U) {
      return r.p(U) + "s";
    }, v = function(U) {
      return U < 0;
    }, x = function(U) {
      return v(U) ? Math.ceil(U) : Math.floor(U);
    }, E = function(U) {
      return Math.abs(U);
    }, S = function(U, y) {
      return U ? v(U) ? { negative: !0, format: "" + E(U) + y } : { negative: !1, format: "" + U + y } : { negative: !1, format: "" };
    }, $ = function() {
      function U(j, q, Q) {
        var I = this;
        if (this.$d = {}, this.$l = Q, j === void 0 && (this.$ms = 0, this.parseFromMilliseconds()), q)
          return g(j * p[b(q)], this);
        if (typeof j == "number")
          return this.$ms = j, this.parseFromMilliseconds(), this;
        if (typeof j == "object")
          return Object.keys(j).forEach(function(H) {
            I.$d[b(H)] = j[H];
          }), this.calMilliseconds(), this;
        if (typeof j == "string") {
          var ie = j.match(f);
          if (ie) {
            var z = ie.slice(2).map(function(H) {
              return H != null ? Number(H) : 0;
            });
            return this.$d.years = z[0], this.$d.months = z[1], this.$d.weeks = z[2], this.$d.days = z[3], this.$d.hours = z[4], this.$d.minutes = z[5], this.$d.seconds = z[6], this.calMilliseconds(), this;
          }
        }
        return this;
      }
      var y = U.prototype;
      return y.calMilliseconds = function() {
        var j = this;
        this.$ms = Object.keys(this.$d).reduce(function(q, Q) {
          return q + (j.$d[Q] || 0) * p[Q];
        }, 0);
      }, y.parseFromMilliseconds = function() {
        var j = this.$ms;
        this.$d.years = x(j / V), j %= V, this.$d.months = x(j / c), j %= c, this.$d.days = x(j / o), j %= o, this.$d.hours = x(j / s), j %= s, this.$d.minutes = x(j / i), j %= i, this.$d.seconds = x(j / a), j %= a, this.$d.milliseconds = j;
      }, y.toISOString = function() {
        var j = S(this.$d.years, "Y"), q = S(this.$d.months, "M"), Q = +this.$d.days || 0;
        this.$d.weeks && (Q += 7 * this.$d.weeks);
        var I = S(Q, "D"), ie = S(this.$d.hours, "H"), z = S(this.$d.minutes, "M"), H = this.$d.seconds || 0;
        this.$d.milliseconds && (H += this.$d.milliseconds / 1e3);
        var P = S(H, "S"), N = j.negative || q.negative || I.negative || ie.negative || z.negative || P.negative, K = ie.format || z.format || P.format ? "T" : "", D = (N ? "-" : "") + "P" + j.format + q.format + I.format + K + ie.format + z.format + P.format;
        return D === "P" || D === "-P" ? "P0D" : D;
      }, y.toJSON = function() {
        return this.toISOString();
      }, y.format = function(j) {
        var q = j || "YYYY-MM-DDTHH:mm:ss", Q = { Y: this.$d.years, YY: r.s(this.$d.years, 2, "0"), YYYY: r.s(this.$d.years, 4, "0"), M: this.$d.months, MM: r.s(this.$d.months, 2, "0"), D: this.$d.days, DD: r.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: r.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: r.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: r.s(this.$d.seconds, 2, "0"), SSS: r.s(this.$d.milliseconds, 3, "0") };
        return q.replace(u, function(I, ie) {
          return ie || String(Q[I]);
        });
      }, y.as = function(j) {
        return this.$ms / p[b(j)];
      }, y.get = function(j) {
        var q = this.$ms, Q = b(j);
        return Q === "milliseconds" ? q %= 1e3 : q = Q === "weeks" ? x(q / p[Q]) : this.$d[Q], q === 0 ? 0 : q;
      }, y.add = function(j, q, Q) {
        var I;
        return I = q ? j * p[b(q)] : h(j) ? j.$ms : g(j, this).$ms, g(this.$ms + I * (Q ? -1 : 1), this);
      }, y.subtract = function(j, q) {
        return this.add(j, q, !0);
      }, y.locale = function(j) {
        var q = this.clone();
        return q.$l = j, q;
      }, y.clone = function() {
        return g(this.$ms, this);
      }, y.humanize = function(j) {
        return n().add(this.$ms, "ms").locale(this.$l).fromNow(!j);
      }, y.milliseconds = function() {
        return this.get("milliseconds");
      }, y.asMilliseconds = function() {
        return this.as("milliseconds");
      }, y.seconds = function() {
        return this.get("seconds");
      }, y.asSeconds = function() {
        return this.as("seconds");
      }, y.minutes = function() {
        return this.get("minutes");
      }, y.asMinutes = function() {
        return this.as("minutes");
      }, y.hours = function() {
        return this.get("hours");
      }, y.asHours = function() {
        return this.as("hours");
      }, y.days = function() {
        return this.get("days");
      }, y.asDays = function() {
        return this.as("days");
      }, y.weeks = function() {
        return this.get("weeks");
      }, y.asWeeks = function() {
        return this.as("weeks");
      }, y.months = function() {
        return this.get("months");
      }, y.asMonths = function() {
        return this.as("months");
      }, y.years = function() {
        return this.get("years");
      }, y.asYears = function() {
        return this.as("years");
      }, U;
    }();
    return function(U, y, j) {
      n = j, r = j().$utils(), j.duration = function(I, ie) {
        var z = j.locale();
        return g(I, { $l: z }, ie);
      }, j.isDuration = h;
      var q = y.prototype.add, Q = y.prototype.subtract;
      y.prototype.add = function(I, ie) {
        return h(I) && (I = I.asMilliseconds()), q.bind(this)(I, ie);
      }, y.prototype.subtract = function(I, ie) {
        return h(I) && (I = I.asMilliseconds()), Q.bind(this)(I, ie);
      };
    };
  });
})(Fg);
var Jw = Fg.exports;
const eI = /* @__PURE__ */ pn(Jw);
var Bg = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    return function(n, r, a) {
      var i = function(s, o) {
        if (!o || !o.length || !o[0] || o.length === 1 && !o[0].length)
          return null;
        var u;
        o.length === 1 && o[0].length > 0 && (o = o[0]), u = o[0];
        for (var V = 1; V < o.length; V += 1)
          o[V].isValid() && !o[V][s](u) || (u = o[V]);
        return u;
      };
      a.max = function() {
        var s = [].slice.call(arguments, 0);
        return i("isAfter", s);
      }, a.min = function() {
        var s = [].slice.call(arguments, 0);
        return i("isBefore", s);
      };
    };
  });
})(Bg);
var tI = Bg.exports;
const nI = /* @__PURE__ */ pn(tI);
var $g = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    return function(n, r, a) {
      n = n || {};
      var i = r.prototype, s = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function o(V, c, f, p) {
        return i.fromToBase(V, c, f, p);
      }
      a.en.relativeTime = s, i.fromToBase = function(V, c, f, p, h) {
        for (var g, b, v, x = f.$locale().relativeTime || s, E = n.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], S = E.length, $ = 0; $ < S; $ += 1) {
          var U = E[$];
          U.d && (g = p ? a(V).diff(f, U.d, !0) : f.diff(V, U.d, !0));
          var y = (n.rounding || Math.round)(Math.abs(g));
          if (v = g > 0, y <= U.r || !U.r) {
            y <= 1 && $ > 0 && (U = E[$ - 1]);
            var j = x[U.l];
            h && (y = h("" + y)), b = typeof j == "string" ? j.replace("%d", y) : j(y, c, U.l, v);
            break;
          }
        }
        if (c)
          return b;
        var q = v ? x.future : x.past;
        return typeof q == "function" ? q(b) : q.replace("%s", b);
      }, i.to = function(V, c) {
        return o(V, c, this, !0);
      }, i.from = function(V, c) {
        return o(V, c, this);
      };
      var u = function(V) {
        return V.$u ? a.utc() : a();
      };
      i.toNow = function(V) {
        return this.to(u(this), V);
      }, i.fromNow = function(V) {
        return this.from(u(this), V);
      };
    };
  });
})($g);
var rI = $g.exports;
const aI = /* @__PURE__ */ pn(rI);
var Ug = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    return function(n, r, a) {
      a.updateLocale = function(i, s) {
        var o = a.Ls[i];
        if (o)
          return (s ? Object.keys(s) : []).forEach(function(u) {
            o[u] = s[u];
          }), o;
      };
    };
  });
})(Ug);
var iI = Ug.exports;
const sI = /* @__PURE__ */ pn(iI);
var Hg = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    var n = "minute", r = /[+-]\d\d(?::?\d\d)?/g, a = /([+-]|\d\d)/g;
    return function(i, s, o) {
      var u = s.prototype;
      o.utc = function(b) {
        var v = { date: b, utc: !0, args: arguments };
        return new s(v);
      }, u.utc = function(b) {
        var v = o(this.toDate(), { locale: this.$L, utc: !0 });
        return b ? v.add(this.utcOffset(), n) : v;
      }, u.local = function() {
        return o(this.toDate(), { locale: this.$L, utc: !1 });
      };
      var V = u.parse;
      u.parse = function(b) {
        b.utc && (this.$u = !0), this.$utils().u(b.$offset) || (this.$offset = b.$offset), V.call(this, b);
      };
      var c = u.init;
      u.init = function() {
        if (this.$u) {
          var b = this.$d;
          this.$y = b.getUTCFullYear(), this.$M = b.getUTCMonth(), this.$D = b.getUTCDate(), this.$W = b.getUTCDay(), this.$H = b.getUTCHours(), this.$m = b.getUTCMinutes(), this.$s = b.getUTCSeconds(), this.$ms = b.getUTCMilliseconds();
        } else
          c.call(this);
      };
      var f = u.utcOffset;
      u.utcOffset = function(b, v) {
        var x = this.$utils().u;
        if (x(b))
          return this.$u ? 0 : x(this.$offset) ? f.call(this) : this.$offset;
        if (typeof b == "string" && (b = function(U) {
          U === void 0 && (U = "");
          var y = U.match(r);
          if (!y)
            return null;
          var j = ("" + y[0]).match(a) || ["-", 0, 0], q = j[0], Q = 60 * +j[1] + +j[2];
          return Q === 0 ? 0 : q === "+" ? Q : -Q;
        }(b)) === null)
          return this;
        var E = Math.abs(b) <= 16 ? 60 * b : b, S = this;
        if (v)
          return S.$offset = E, S.$u = b === 0, S;
        if (b !== 0) {
          var $ = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (S = this.local().add(E + $, n)).$offset = E, S.$x.$localOffset = $;
        } else
          S = this.utc();
        return S;
      };
      var p = u.format;
      u.format = function(b) {
        var v = b || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return p.call(this, v);
      }, u.valueOf = function() {
        var b = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || (/* @__PURE__ */ new Date()).getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * b;
      }, u.isUTC = function() {
        return !!this.$u;
      }, u.toISOString = function() {
        return this.toDate().toISOString();
      }, u.toString = function() {
        return this.toDate().toUTCString();
      };
      var h = u.toDate;
      u.toDate = function(b) {
        return b === "s" && this.$offset ? o(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : h.call(this);
      };
      var g = u.diff;
      u.diff = function(b, v, x) {
        if (b && this.$u === b.$u)
          return g.call(this, b, v, x);
        var E = this.local(), S = o(b).local();
        return g.call(E, S, v, x);
      };
    };
  });
})(Hg);
var oI = Hg.exports;
const uI = /* @__PURE__ */ pn(oI);
Ta.extend(uI);
Ta.extend(eI);
Ta.extend(aI);
Ta.extend(Qw);
Ta.extend(nI);
Ta.extend(Kw);
Ta.extend(sI);
Ta.updateLocale("en", {
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
  }
});
const VI = [
  {
    group: "US (Common)",
    zones: [
      {
        value: "US/Puerto_Rico",
        name: "Puerto Rico (Atlantic)"
      },
      {
        value: "US/New_York",
        name: "New York (Eastern)"
      },
      {
        value: "US/Chicago",
        name: "Chicago (Central)"
      },
      {
        value: "US/Denver",
        name: "Denver (Mountain)"
      },
      {
        value: "US/Phoenix",
        name: "Phoenix (MST)"
      },
      {
        value: "US/Los_Angeles",
        name: "Los Angeles (Pacific)"
      },
      {
        value: "US/Anchorage",
        name: "Anchorage (Alaska)"
      },
      {
        value: "America Pacific/Honolulu",
        name: "Honolulu (Hawaii)"
      }
    ]
  },
  {
    group: "America",
    zones: [
      {
        value: "America/Adak",
        name: "Adak"
      },
      {
        value: "America/Anchorage",
        name: "Anchorage"
      },
      {
        value: "America/Anguilla",
        name: "Anguilla"
      },
      {
        value: "America/Antigua",
        name: "Antigua"
      },
      {
        value: "America/Araguaina",
        name: "Araguaina"
      },
      {
        value: "America/Argentina/Buenos_Aires",
        name: "Argentina - Buenos Aires"
      },
      {
        value: "America/Argentina/Catamarca",
        name: "Argentina - Catamarca"
      },
      {
        value: "America/Argentina/ComodRivadavia",
        name: "Argentina - ComodRivadavia"
      },
      {
        value: "America/Argentina/Cordoba",
        name: "Argentina - Cordoba"
      },
      {
        value: "America/Argentina/Jujuy",
        name: "Argentina - Jujuy"
      },
      {
        value: "America/Argentina/La_Rioja",
        name: "Argentina - La Rioja"
      },
      {
        value: "America/Argentina/Mendoza",
        name: "Argentina - Mendoza"
      },
      {
        value: "America/Argentina/Rio_Gallegos",
        name: "Argentina - Rio Gallegos"
      },
      {
        value: "America/Argentina/Salta",
        name: "Argentina - Salta"
      },
      {
        value: "America/Argentina/San_Juan",
        name: "Argentina - San Juan"
      },
      {
        value: "America/Argentina/San_Luis",
        name: "Argentina - San Luis"
      },
      {
        value: "America/Argentina/Tucuman",
        name: "Argentina - Tucuman"
      },
      {
        value: "America/Argentina/Ushuaia",
        name: "Argentina - Ushuaia"
      },
      {
        value: "America/Aruba",
        name: "Aruba"
      },
      {
        value: "America/Asuncion",
        name: "Asuncion"
      },
      {
        value: "America/Atikokan",
        name: "Atikokan"
      },
      {
        value: "America/Atka",
        name: "Atka"
      },
      {
        value: "America/Bahia",
        name: "Bahia"
      },
      {
        value: "America/Barbados",
        name: "Barbados"
      },
      {
        value: "America/Belem",
        name: "Belem"
      },
      {
        value: "America/Belize",
        name: "Belize"
      },
      {
        value: "America/Blanc-Sablon",
        name: "Blanc-Sablon"
      },
      {
        value: "America/Boa_Vista",
        name: "Boa Vista"
      },
      {
        value: "America/Bogota",
        name: "Bogota"
      },
      {
        value: "America/Boise",
        name: "Boise"
      },
      {
        value: "America/Buenos_Aires",
        name: "Buenos Aires"
      },
      {
        value: "America/Cambridge_Bay",
        name: "Cambridge Bay"
      },
      {
        value: "America/Campo_Grande",
        name: "Campo Grande"
      },
      {
        value: "America/Cancun",
        name: "Cancun"
      },
      {
        value: "America/Caracas",
        name: "Caracas"
      },
      {
        value: "America/Catamarca",
        name: "Catamarca"
      },
      {
        value: "America/Cayenne",
        name: "Cayenne"
      },
      {
        value: "America/Cayman",
        name: "Cayman"
      },
      {
        value: "America/Chicago",
        name: "Chicago"
      },
      {
        value: "America/Chihuahua",
        name: "Chihuahua"
      },
      {
        value: "America/Coral_Harbour",
        name: "Coral Harbour"
      },
      {
        value: "America/Cordoba",
        name: "Cordoba"
      },
      {
        value: "America/Costa_Rica",
        name: "Costa Rica"
      },
      {
        value: "America/Cuiaba",
        name: "Cuiaba"
      },
      {
        value: "America/Curacao",
        name: "Curacao"
      },
      {
        value: "America/Danmarkshavn",
        name: "Danmarkshavn"
      },
      {
        value: "America/Dawson",
        name: "Dawson"
      },
      {
        value: "America/Dawson_Creek",
        name: "Dawson Creek"
      },
      {
        value: "America/Denver",
        name: "Denver"
      },
      {
        value: "America/Detroit",
        name: "Detroit"
      },
      {
        value: "America/Dominica",
        name: "Dominica"
      },
      {
        value: "America/Edmonton",
        name: "Edmonton"
      },
      {
        value: "America/Eirunepe",
        name: "Eirunepe"
      },
      {
        value: "America/El_Salvador",
        name: "El Salvador"
      },
      {
        value: "America/Ensenada",
        name: "Ensenada"
      },
      {
        value: "America/Fortaleza",
        name: "Fortaleza"
      },
      {
        value: "America/Fort_Wayne",
        name: "Fort Wayne"
      },
      {
        value: "America/Glace_Bay",
        name: "Glace Bay"
      },
      {
        value: "America/Godthab",
        name: "Godthab"
      },
      {
        value: "America/Goose_Bay",
        name: "Goose Bay"
      },
      {
        value: "America/Grand_Turk",
        name: "Grand Turk"
      },
      {
        value: "America/Grenada",
        name: "Grenada"
      },
      {
        value: "America/Guadeloupe",
        name: "Guadeloupe"
      },
      {
        value: "America/Guatemala",
        name: "Guatemala"
      },
      {
        value: "America/Guayaquil",
        name: "Guayaquil"
      },
      {
        value: "America/Guyana",
        name: "Guyana"
      },
      {
        value: "America/Halifax",
        name: "Halifax"
      },
      {
        value: "America/Havana",
        name: "Havana"
      },
      {
        value: "America/Hermosillo",
        name: "Hermosillo"
      },
      {
        value: "America/Indiana/Indianapolis",
        name: "Indiana - Indianapolis"
      },
      {
        value: "America/Indiana/Knox",
        name: "Indiana - Knox"
      },
      {
        value: "America/Indiana/Marengo",
        name: "Indiana - Marengo"
      },
      {
        value: "America/Indiana/Petersburg",
        name: "Indiana - Petersburg"
      },
      {
        value: "America/Indiana/Tell_City",
        name: "Indiana - Tell City"
      },
      {
        value: "America/Indiana/Vevay",
        name: "Indiana - Vevay"
      },
      {
        value: "America/Indiana/Vincennes",
        name: "Indiana - Vincennes"
      },
      {
        value: "America/Indiana/Winamac",
        name: "Indiana - Winamac"
      },
      {
        value: "America/Indianapolis",
        name: "Indianapolis"
      },
      {
        value: "America/Inuvik",
        name: "Inuvik"
      },
      {
        value: "America/Iqaluit",
        name: "Iqaluit"
      },
      {
        value: "America/Jamaica",
        name: "Jamaica"
      },
      {
        value: "America/Jujuy",
        name: "Jujuy"
      },
      {
        value: "America/Juneau",
        name: "Juneau"
      },
      {
        value: "America/Kentucky/Louisville",
        name: "Kentucky - Louisville"
      },
      {
        value: "America/Kentucky/Monticello",
        name: "Kentucky - Monticello"
      },
      {
        value: "America/Knox_IN",
        name: "Knox IN"
      },
      {
        value: "America/La_Paz",
        name: "La Paz"
      },
      {
        value: "America/Lima",
        name: "Lima"
      },
      {
        value: "America/Los_Angeles",
        name: "Los Angeles"
      },
      {
        value: "America/Louisville",
        name: "Louisville"
      },
      {
        value: "America/Maceio",
        name: "Maceio"
      },
      {
        value: "America/Managua",
        name: "Managua"
      },
      {
        value: "America/Manaus",
        name: "Manaus"
      },
      {
        value: "America/Marigot",
        name: "Marigot"
      },
      {
        value: "America/Martinique",
        name: "Martinique"
      },
      {
        value: "America/Matamoros",
        name: "Matamoros"
      },
      {
        value: "America/Mazatlan",
        name: "Mazatlan"
      },
      {
        value: "America/Mendoza",
        name: "Mendoza"
      },
      {
        value: "America/Menominee",
        name: "Menominee"
      },
      {
        value: "America/Merida",
        name: "Merida"
      },
      {
        value: "America/Mexico_City",
        name: "Mexico City"
      },
      {
        value: "America/Miquelon",
        name: "Miquelon"
      },
      {
        value: "America/Moncton",
        name: "Moncton"
      },
      {
        value: "America/Monterrey",
        name: "Monterrey"
      },
      {
        value: "America/Montevideo",
        name: "Montevideo"
      },
      {
        value: "America/Montreal",
        name: "Montreal"
      },
      {
        value: "America/Montserrat",
        name: "Montserrat"
      },
      {
        value: "America/Nassau",
        name: "Nassau"
      },
      {
        value: "America/New_York",
        name: "New York"
      },
      {
        value: "America/Nipigon",
        name: "Nipigon"
      },
      {
        value: "America/Nome",
        name: "Nome"
      },
      {
        value: "America/Noronha",
        name: "Noronha"
      },
      {
        value: "America/North_Dakota/Center",
        name: "North Dakota - Center"
      },
      {
        value: "America/North_Dakota/New_Salem",
        name: "North Dakota - New Salem"
      },
      {
        value: "America/Ojinaga",
        name: "Ojinaga"
      },
      {
        value: "America/Panama",
        name: "Panama"
      },
      {
        value: "America/Pangnirtung",
        name: "Pangnirtung"
      },
      {
        value: "America/Paramaribo",
        name: "Paramaribo"
      },
      {
        value: "America/Phoenix",
        name: "Phoenix"
      },
      {
        value: "America/Port-au-Prince",
        name: "Port-au-Prince"
      },
      {
        value: "America/Porto_Acre",
        name: "Porto Acre"
      },
      {
        value: "America/Port_of_Spain",
        name: "Port of Spain"
      },
      {
        value: "America/Porto_Velho",
        name: "Porto Velho"
      },
      {
        value: "America/Puerto_Rico",
        name: "Puerto Rico"
      },
      {
        value: "America/Rainy_River",
        name: "Rainy River"
      },
      {
        value: "America/Rankin_Inlet",
        name: "Rankin Inlet"
      },
      {
        value: "America/Recife",
        name: "Recife"
      },
      {
        value: "America/Regina",
        name: "Regina"
      },
      {
        value: "America/Resolute",
        name: "Resolute"
      },
      {
        value: "America/Rio_Branco",
        name: "Rio Branco"
      },
      {
        value: "America/Rosario",
        name: "Rosario"
      },
      {
        value: "America/Santa_Isabel",
        name: "Santa Isabel"
      },
      {
        value: "America/Santarem",
        name: "Santarem"
      },
      {
        value: "America/Santiago",
        name: "Santiago"
      },
      {
        value: "America/Santo_Domingo",
        name: "Santo Domingo"
      },
      {
        value: "America/Sao_Paulo",
        name: "Sao Paulo"
      },
      {
        value: "America/Scoresbysund",
        name: "Scoresbysund"
      },
      {
        value: "America/Shiprock",
        name: "Shiprock"
      },
      {
        value: "America/St_Barthelemy",
        name: "St Barthelemy"
      },
      {
        value: "America/St_Johns",
        name: "St Johns"
      },
      {
        value: "America/St_Kitts",
        name: "St Kitts"
      },
      {
        value: "America/St_Lucia",
        name: "St Lucia"
      },
      {
        value: "America/St_Thomas",
        name: "St Thomas"
      },
      {
        value: "America/St_Vincent",
        name: "St Vincent"
      },
      {
        value: "America/Swift_Current",
        name: "Swift Current"
      },
      {
        value: "America/Tegucigalpa",
        name: "Tegucigalpa"
      },
      {
        value: "America/Thule",
        name: "Thule"
      },
      {
        value: "America/Thunder_Bay",
        name: "Thunder Bay"
      },
      {
        value: "America/Tijuana",
        name: "Tijuana"
      },
      {
        value: "America/Toronto",
        name: "Toronto"
      },
      {
        value: "America/Tortola",
        name: "Tortola"
      },
      {
        value: "America/Vancouver",
        name: "Vancouver"
      },
      {
        value: "America/Virgin",
        name: "Virgin"
      },
      {
        value: "America/Whitehorse",
        name: "Whitehorse"
      },
      {
        value: "America/Winnipeg",
        name: "Winnipeg"
      },
      {
        value: "America/Yakutat",
        name: "Yakutat"
      },
      {
        value: "America/Yellowknife",
        name: "Yellowknife"
      }
    ]
  },
  {
    group: "Europe",
    zones: [
      {
        value: "Europe/Amsterdam",
        name: "Amsterdam"
      },
      {
        value: "Europe/Andorra",
        name: "Andorra"
      },
      {
        value: "Europe/Athens",
        name: "Athens"
      },
      {
        value: "Europe/Belfast",
        name: "Belfast"
      },
      {
        value: "Europe/Belgrade",
        name: "Belgrade"
      },
      {
        value: "Europe/Berlin",
        name: "Berlin"
      },
      {
        value: "Europe/Bratislava",
        name: "Bratislava"
      },
      {
        value: "Europe/Brussels",
        name: "Brussels"
      },
      {
        value: "Europe/Bucharest",
        name: "Bucharest"
      },
      {
        value: "Europe/Budapest",
        name: "Budapest"
      },
      {
        value: "Europe/Chisinau",
        name: "Chisinau"
      },
      {
        value: "Europe/Copenhagen",
        name: "Copenhagen"
      },
      {
        value: "Europe/Dublin",
        name: "Dublin"
      },
      {
        value: "Europe/Gibraltar",
        name: "Gibraltar"
      },
      {
        value: "Europe/Guernsey",
        name: "Guernsey"
      },
      {
        value: "Europe/Helsinki",
        name: "Helsinki"
      },
      {
        value: "Europe/Isle_of_Man",
        name: "Isle of Man"
      },
      {
        value: "Europe/Istanbul",
        name: "Istanbul"
      },
      {
        value: "Europe/Jersey",
        name: "Jersey"
      },
      {
        value: "Europe/Kaliningrad",
        name: "Kaliningrad"
      },
      {
        value: "Europe/Kiev",
        name: "Kiev"
      },
      {
        value: "Europe/Lisbon",
        name: "Lisbon"
      },
      {
        value: "Europe/Ljubljana",
        name: "Ljubljana"
      },
      {
        value: "Europe/London",
        name: "London"
      },
      {
        value: "Europe/Luxembourg",
        name: "Luxembourg"
      },
      {
        value: "Europe/Madrid",
        name: "Madrid"
      },
      {
        value: "Europe/Malta",
        name: "Malta"
      },
      {
        value: "Europe/Mariehamn",
        name: "Mariehamn"
      },
      {
        value: "Europe/Minsk",
        name: "Minsk"
      },
      {
        value: "Europe/Monaco",
        name: "Monaco"
      },
      {
        value: "Europe/Moscow",
        name: "Moscow"
      },
      {
        value: "Europe/Nicosia",
        name: "Nicosia"
      },
      {
        value: "Europe/Oslo",
        name: "Oslo"
      },
      {
        value: "Europe/Paris",
        name: "Paris"
      },
      {
        value: "Europe/Podgorica",
        name: "Podgorica"
      },
      {
        value: "Europe/Prague",
        name: "Prague"
      },
      {
        value: "Europe/Riga",
        name: "Riga"
      },
      {
        value: "Europe/Rome",
        name: "Rome"
      },
      {
        value: "Europe/Samara",
        name: "Samara"
      },
      {
        value: "Europe/San_Marino",
        name: "San Marino"
      },
      {
        value: "Europe/Sarajevo",
        name: "Sarajevo"
      },
      {
        value: "Europe/Simferopol",
        name: "Simferopol"
      },
      {
        value: "Europe/Skopje",
        name: "Skopje"
      },
      {
        value: "Europe/Sofia",
        name: "Sofia"
      },
      {
        value: "Europe/Stockholm",
        name: "Stockholm"
      },
      {
        value: "Europe/Tallinn",
        name: "Tallinn"
      },
      {
        value: "Europe/Tirane",
        name: "Tirane"
      },
      {
        value: "Europe/Tiraspol",
        name: "Tiraspol"
      },
      {
        value: "Europe/Uzhgorod",
        name: "Uzhgorod"
      },
      {
        value: "Europe/Vaduz",
        name: "Vaduz"
      },
      {
        value: "Europe/Vatican",
        name: "Vatican"
      },
      {
        value: "Europe/Vienna",
        name: "Vienna"
      },
      {
        value: "Europe/Vilnius",
        name: "Vilnius"
      },
      {
        value: "Europe/Volgograd",
        name: "Volgograd"
      },
      {
        value: "Europe/Warsaw",
        name: "Warsaw"
      },
      {
        value: "Europe/Zagreb",
        name: "Zagreb"
      },
      {
        value: "Europe/Zaporozhye",
        name: "Zaporozhye"
      },
      {
        value: "Europe/Zurich",
        name: "Zurich"
      }
    ]
  },
  {
    group: "Asia",
    zones: [
      {
        value: "Asia/Aden",
        name: "Aden"
      },
      {
        value: "Asia/Almaty",
        name: "Almaty"
      },
      {
        value: "Asia/Amman",
        name: "Amman"
      },
      {
        value: "Asia/Anadyr",
        name: "Anadyr"
      },
      {
        value: "Asia/Aqtau",
        name: "Aqtau"
      },
      {
        value: "Asia/Aqtobe",
        name: "Aqtobe"
      },
      {
        value: "Asia/Ashgabat",
        name: "Ashgabat"
      },
      {
        value: "Asia/Ashkhabad",
        name: "Ashkhabad"
      },
      {
        value: "Asia/Baghdad",
        name: "Baghdad"
      },
      {
        value: "Asia/Bahrain",
        name: "Bahrain"
      },
      {
        value: "Asia/Baku",
        name: "Baku"
      },
      {
        value: "Asia/Bangkok",
        name: "Bangkok"
      },
      {
        value: "Asia/Beirut",
        name: "Beirut"
      },
      {
        value: "Asia/Bishkek",
        name: "Bishkek"
      },
      {
        value: "Asia/Brunei",
        name: "Brunei"
      },
      {
        value: "Asia/Calcutta",
        name: "Calcutta"
      },
      {
        value: "Asia/Choibalsan",
        name: "Choibalsan"
      },
      {
        value: "Asia/Chongqing",
        name: "Chongqing"
      },
      {
        value: "Asia/Chungking",
        name: "Chungking"
      },
      {
        value: "Asia/Colombo",
        name: "Colombo"
      },
      {
        value: "Asia/Dacca",
        name: "Dacca"
      },
      {
        value: "Asia/Damascus",
        name: "Damascus"
      },
      {
        value: "Asia/Dhaka",
        name: "Dhaka"
      },
      {
        value: "Asia/Dili",
        name: "Dili"
      },
      {
        value: "Asia/Dubai",
        name: "Dubai"
      },
      {
        value: "Asia/Dushanbe",
        name: "Dushanbe"
      },
      {
        value: "Asia/Gaza",
        name: "Gaza"
      },
      {
        value: "Asia/Harbin",
        name: "Harbin"
      },
      {
        value: "Asia/Ho_Chi_Minh",
        name: "Ho Chi Minh"
      },
      {
        value: "Asia/Hong_Kong",
        name: "Hong Kong"
      },
      {
        value: "Asia/Hovd",
        name: "Hovd"
      },
      {
        value: "Asia/Irkutsk",
        name: "Irkutsk"
      },
      {
        value: "Asia/Istanbul",
        name: "Istanbul"
      },
      {
        value: "Asia/Jakarta",
        name: "Jakarta"
      },
      {
        value: "Asia/Jayapura",
        name: "Jayapura"
      },
      {
        value: "Asia/Jerusalem",
        name: "Jerusalem"
      },
      {
        value: "Asia/Kabul",
        name: "Kabul"
      },
      {
        value: "Asia/Kamchatka",
        name: "Kamchatka"
      },
      {
        value: "Asia/Karachi",
        name: "Karachi"
      },
      {
        value: "Asia/Kashgar",
        name: "Kashgar"
      },
      {
        value: "Asia/Kathmandu",
        name: "Kathmandu"
      },
      {
        value: "Asia/Katmandu",
        name: "Katmandu"
      },
      {
        value: "Asia/Kolkata",
        name: "Kolkata"
      },
      {
        value: "Asia/Krasnoyarsk",
        name: "Krasnoyarsk"
      },
      {
        value: "Asia/Kuala_Lumpur",
        name: "Kuala Lumpur"
      },
      {
        value: "Asia/Kuching",
        name: "Kuching"
      },
      {
        value: "Asia/Kuwait",
        name: "Kuwait"
      },
      {
        value: "Asia/Macao",
        name: "Macao"
      },
      {
        value: "Asia/Macau",
        name: "Macau"
      },
      {
        value: "Asia/Magadan",
        name: "Magadan"
      },
      {
        value: "Asia/Makassar",
        name: "Makassar"
      },
      {
        value: "Asia/Manila",
        name: "Manila"
      },
      {
        value: "Asia/Muscat",
        name: "Muscat"
      },
      {
        value: "Asia/Nicosia",
        name: "Nicosia"
      },
      {
        value: "Asia/Novokuznetsk",
        name: "Novokuznetsk"
      },
      {
        value: "Asia/Novosibirsk",
        name: "Novosibirsk"
      },
      {
        value: "Asia/Omsk",
        name: "Omsk"
      },
      {
        value: "Asia/Oral",
        name: "Oral"
      },
      {
        value: "Asia/Phnom_Penh",
        name: "Phnom Penh"
      },
      {
        value: "Asia/Pontianak",
        name: "Pontianak"
      },
      {
        value: "Asia/Pyongyang",
        name: "Pyongyang"
      },
      {
        value: "Asia/Qatar",
        name: "Qatar"
      },
      {
        value: "Asia/Qyzylorda",
        name: "Qyzylorda"
      },
      {
        value: "Asia/Rangoon",
        name: "Rangoon"
      },
      {
        value: "Asia/Riyadh",
        name: "Riyadh"
      },
      {
        value: "Asia/Saigon",
        name: "Saigon"
      },
      {
        value: "Asia/Sakhalin",
        name: "Sakhalin"
      },
      {
        value: "Asia/Samarkand",
        name: "Samarkand"
      },
      {
        value: "Asia/Seoul",
        name: "Seoul"
      },
      {
        value: "Asia/Shanghai",
        name: "Shanghai"
      },
      {
        value: "Asia/Singapore",
        name: "Singapore"
      },
      {
        value: "Asia/Taipei",
        name: "Taipei"
      },
      {
        value: "Asia/Tashkent",
        name: "Tashkent"
      },
      {
        value: "Asia/Tbilisi",
        name: "Tbilisi"
      },
      {
        value: "Asia/Tehran",
        name: "Tehran"
      },
      {
        value: "Asia/Tel_Aviv",
        name: "Tel Aviv"
      },
      {
        value: "Asia/Thimbu",
        name: "Thimbu"
      },
      {
        value: "Asia/Thimphu",
        name: "Thimphu"
      },
      {
        value: "Asia/Tokyo",
        name: "Tokyo"
      },
      {
        value: "Asia/Ujung_Pandang",
        name: "Ujung Pandang"
      },
      {
        value: "Asia/Ulaanbaatar",
        name: "Ulaanbaatar"
      },
      {
        value: "Asia/Ulan_Bator",
        name: "Ulan Bator"
      },
      {
        value: "Asia/Urumqi",
        name: "Urumqi"
      },
      {
        value: "Asia/Vientiane",
        name: "Vientiane"
      },
      {
        value: "Asia/Vladivostok",
        name: "Vladivostok"
      },
      {
        value: "Asia/Yakutsk",
        name: "Yakutsk"
      },
      {
        value: "Asia/Yekaterinburg",
        name: "Yekaterinburg"
      },
      {
        value: "Asia/Yerevan",
        name: "Yerevan"
      }
    ]
  },
  {
    group: "Africa",
    zones: [
      {
        value: "Africa/Abidjan",
        name: "Abidjan"
      },
      {
        value: "Africa/Accra",
        name: "Accra"
      },
      {
        value: "Africa/Addis_Ababa",
        name: "Addis Ababa"
      },
      {
        value: "Africa/Algiers",
        name: "Algiers"
      },
      {
        value: "Africa/Asmara",
        name: "Asmara"
      },
      {
        value: "Africa/Asmera",
        name: "Asmera"
      },
      {
        value: "Africa/Bamako",
        name: "Bamako"
      },
      {
        value: "Africa/Bangui",
        name: "Bangui"
      },
      {
        value: "Africa/Banjul",
        name: "Banjul"
      },
      {
        value: "Africa/Bissau",
        name: "Bissau"
      },
      {
        value: "Africa/Blantyre",
        name: "Blantyre"
      },
      {
        value: "Africa/Brazzaville",
        name: "Brazzaville"
      },
      {
        value: "Africa/Bujumbura",
        name: "Bujumbura"
      },
      {
        value: "Africa/Cairo",
        name: "Cairo"
      },
      {
        value: "Africa/Casablanca",
        name: "Casablanca"
      },
      {
        value: "Africa/Ceuta",
        name: "Ceuta"
      },
      {
        value: "Africa/Conakry",
        name: "Conakry"
      },
      {
        value: "Africa/Dakar",
        name: "Dakar"
      },
      {
        value: "Africa/Dar_es_Salaam",
        name: "Dar es Salaam"
      },
      {
        value: "Africa/Djibouti",
        name: "Djibouti"
      },
      {
        value: "Africa/Douala",
        name: "Douala"
      },
      {
        value: "Africa/El_Aaiun",
        name: "El Aaiun"
      },
      {
        value: "Africa/Freetown",
        name: "Freetown"
      },
      {
        value: "Africa/Gaborone",
        name: "Gaborone"
      },
      {
        value: "Africa/Harare",
        name: "Harare"
      },
      {
        value: "Africa/Johannesburg",
        name: "Johannesburg"
      },
      {
        value: "Africa/Kampala",
        name: "Kampala"
      },
      {
        value: "Africa/Khartoum",
        name: "Khartoum"
      },
      {
        value: "Africa/Kigali",
        name: "Kigali"
      },
      {
        value: "Africa/Kinshasa",
        name: "Kinshasa"
      },
      {
        value: "Africa/Lagos",
        name: "Lagos"
      },
      {
        value: "Africa/Libreville",
        name: "Libreville"
      },
      {
        value: "Africa/Lome",
        name: "Lome"
      },
      {
        value: "Africa/Luanda",
        name: "Luanda"
      },
      {
        value: "Africa/Lubumbashi",
        name: "Lubumbashi"
      },
      {
        value: "Africa/Lusaka",
        name: "Lusaka"
      },
      {
        value: "Africa/Malabo",
        name: "Malabo"
      },
      {
        value: "Africa/Maputo",
        name: "Maputo"
      },
      {
        value: "Africa/Maseru",
        name: "Maseru"
      },
      {
        value: "Africa/Mbabane",
        name: "Mbabane"
      },
      {
        value: "Africa/Mogadishu",
        name: "Mogadishu"
      },
      {
        value: "Africa/Monrovia",
        name: "Monrovia"
      },
      {
        value: "Africa/Nairobi",
        name: "Nairobi"
      },
      {
        value: "Africa/Ndjamena",
        name: "Ndjamena"
      },
      {
        value: "Africa/Niamey",
        name: "Niamey"
      },
      {
        value: "Africa/Nouakchott",
        name: "Nouakchott"
      },
      {
        value: "Africa/Ouagadougou",
        name: "Ouagadougou"
      },
      {
        value: "Africa/Porto-Novo",
        name: "Porto-Novo"
      },
      {
        value: "Africa/Sao_Tome",
        name: "Sao Tome"
      },
      {
        value: "Africa/Timbuktu",
        name: "Timbuktu"
      },
      {
        value: "Africa/Tripoli",
        name: "Tripoli"
      },
      {
        value: "Africa/Tunis",
        name: "Tunis"
      },
      {
        value: "Africa/Windhoek",
        name: "Windhoek"
      }
    ]
  },
  {
    group: "Australia",
    zones: [
      {
        value: "Australia/ACT",
        name: "ACT"
      },
      {
        value: "Australia/Adelaide",
        name: "Adelaide"
      },
      {
        value: "Australia/Brisbane",
        name: "Brisbane"
      },
      {
        value: "Australia/Broken_Hill",
        name: "Broken Hill"
      },
      {
        value: "Australia/Canberra",
        name: "Canberra"
      },
      {
        value: "Australia/Currie",
        name: "Currie"
      },
      {
        value: "Australia/Darwin",
        name: "Darwin"
      },
      {
        value: "Australia/Eucla",
        name: "Eucla"
      },
      {
        value: "Australia/Hobart",
        name: "Hobart"
      },
      {
        value: "Australia/LHI",
        name: "LHI"
      },
      {
        value: "Australia/Lindeman",
        name: "Lindeman"
      },
      {
        value: "Australia/Lord_Howe",
        name: "Lord Howe"
      },
      {
        value: "Australia/Melbourne",
        name: "Melbourne"
      },
      {
        value: "Australia/North",
        name: "North"
      },
      {
        value: "Australia/NSW",
        name: "NSW"
      },
      {
        value: "Australia/Perth",
        name: "Perth"
      },
      {
        value: "Australia/Queensland",
        name: "Queensland"
      },
      {
        value: "Australia/South",
        name: "South"
      },
      {
        value: "Australia/Sydney",
        name: "Sydney"
      },
      {
        value: "Australia/Tasmania",
        name: "Tasmania"
      },
      {
        value: "Australia/Victoria",
        name: "Victoria"
      },
      {
        value: "Australia/West",
        name: "West"
      },
      {
        value: "Australia/Yancowinna",
        name: "Yancowinna"
      }
    ]
  },
  {
    group: "Indian",
    zones: [
      {
        value: "Indian/Antananarivo",
        name: "Antananarivo"
      },
      {
        value: "Indian/Chagos",
        name: "Chagos"
      },
      {
        value: "Indian/Christmas",
        name: "Christmas"
      },
      {
        value: "Indian/Cocos",
        name: "Cocos"
      },
      {
        value: "Indian/Comoro",
        name: "Comoro"
      },
      {
        value: "Indian/Kerguelen",
        name: "Kerguelen"
      },
      {
        value: "Indian/Mahe",
        name: "Mahe"
      },
      {
        value: "Indian/Maldives",
        name: "Maldives"
      },
      {
        value: "Indian/Mauritius",
        name: "Mauritius"
      },
      {
        value: "Indian/Mayotte",
        name: "Mayotte"
      },
      {
        value: "Indian/Reunion",
        name: "Reunion"
      }
    ]
  },
  {
    group: "Atlantic",
    zones: [
      {
        value: "Atlantic/Azores",
        name: "Azores"
      },
      {
        value: "Atlantic/Bermuda",
        name: "Bermuda"
      },
      {
        value: "Atlantic/Canary",
        name: "Canary"
      },
      {
        value: "Atlantic/Cape_Verde",
        name: "Cape Verde"
      },
      {
        value: "Atlantic/Faeroe",
        name: "Faeroe"
      },
      {
        value: "Atlantic/Faroe",
        name: "Faroe"
      },
      {
        value: "Atlantic/Jan_Mayen",
        name: "Jan Mayen"
      },
      {
        value: "Atlantic/Madeira",
        name: "Madeira"
      },
      {
        value: "Atlantic/Reykjavik",
        name: "Reykjavik"
      },
      {
        value: "Atlantic/South_Georgia",
        name: "South Georgia"
      },
      {
        value: "Atlantic/Stanley",
        name: "Stanley"
      },
      {
        value: "Atlantic/St_Helena",
        name: "St Helena"
      }
    ]
  },
  {
    group: "Pacific",
    zones: [
      {
        value: "Pacific/Apia",
        name: "Apia"
      },
      {
        value: "Pacific/Auckland",
        name: "Auckland"
      },
      {
        value: "Pacific/Chatham",
        name: "Chatham"
      },
      {
        value: "Pacific/Easter",
        name: "Easter"
      },
      {
        value: "Pacific/Efate",
        name: "Efate"
      },
      {
        value: "Pacific/Enderbury",
        name: "Enderbury"
      },
      {
        value: "Pacific/Fakaofo",
        name: "Fakaofo"
      },
      {
        value: "Pacific/Fiji",
        name: "Fiji"
      },
      {
        value: "Pacific/Funafuti",
        name: "Funafuti"
      },
      {
        value: "Pacific/Galapagos",
        name: "Galapagos"
      },
      {
        value: "Pacific/Gambier",
        name: "Gambier"
      },
      {
        value: "Pacific/Guadalcanal",
        name: "Guadalcanal"
      },
      {
        value: "Pacific/Guam",
        name: "Guam"
      },
      {
        value: "Pacific/Honolulu",
        name: "Honolulu"
      },
      {
        value: "Pacific/Johnston",
        name: "Johnston"
      },
      {
        value: "Pacific/Kiritimati",
        name: "Kiritimati"
      },
      {
        value: "Pacific/Kosrae",
        name: "Kosrae"
      },
      {
        value: "Pacific/Kwajalein",
        name: "Kwajalein"
      },
      {
        value: "Pacific/Majuro",
        name: "Majuro"
      },
      {
        value: "Pacific/Marquesas",
        name: "Marquesas"
      },
      {
        value: "Pacific/Midway",
        name: "Midway"
      },
      {
        value: "Pacific/Nauru",
        name: "Nauru"
      },
      {
        value: "Pacific/Niue",
        name: "Niue"
      },
      {
        value: "Pacific/Norfolk",
        name: "Norfolk"
      },
      {
        value: "Pacific/Noumea",
        name: "Noumea"
      },
      {
        value: "Pacific/Pago_Pago",
        name: "Pago Pago"
      },
      {
        value: "Pacific/Palau",
        name: "Palau"
      },
      {
        value: "Pacific/Pitcairn",
        name: "Pitcairn"
      },
      {
        value: "Pacific/Ponape",
        name: "Ponape"
      },
      {
        value: "Pacific/Port_Moresby",
        name: "Port Moresby"
      },
      {
        value: "Pacific/Rarotonga",
        name: "Rarotonga"
      },
      {
        value: "Pacific/Saipan",
        name: "Saipan"
      },
      {
        value: "Pacific/Samoa",
        name: "Samoa"
      },
      {
        value: "Pacific/Tahiti",
        name: "Tahiti"
      },
      {
        value: "Pacific/Tarawa",
        name: "Tarawa"
      },
      {
        value: "Pacific/Tongatapu",
        name: "Tongatapu"
      },
      {
        value: "Pacific/Truk",
        name: "Truk"
      },
      {
        value: "Pacific/Wake",
        name: "Wake"
      },
      {
        value: "Pacific/Wallis",
        name: "Wallis"
      },
      {
        value: "Pacific/Yap",
        name: "Yap"
      }
    ]
  },
  {
    group: "Antarctica",
    zones: [
      {
        value: "Antarctica/Casey",
        name: "Casey"
      },
      {
        value: "Antarctica/Davis",
        name: "Davis"
      },
      {
        value: "Antarctica/DumontDUrville",
        name: "DumontDUrville"
      },
      {
        value: "Antarctica/Macquarie",
        name: "Macquarie"
      },
      {
        value: "Antarctica/Mawson",
        name: "Mawson"
      },
      {
        value: "Antarctica/McMurdo",
        name: "McMurdo"
      },
      {
        value: "Antarctica/Palmer",
        name: "Palmer"
      },
      {
        value: "Antarctica/Rothera",
        name: "Rothera"
      },
      {
        value: "Antarctica/South_Pole",
        name: "South Pole"
      },
      {
        value: "Antarctica/Syowa",
        name: "Syowa"
      },
      {
        value: "Antarctica/Vostok",
        name: "Vostok"
      }
    ]
  },
  {
    group: "Arctic",
    zones: [
      {
        value: "Arctic/Longyearbyen",
        name: "Longyearbyen"
      }
    ]
  },
  {
    group: "UTC",
    zones: [
      {
        value: "UTC",
        name: "UTC"
      }
    ]
  },
  {
    group: "Manual Offsets",
    zones: [
      {
        value: "UTC-12",
        name: "UTC-12"
      },
      {
        value: "UTC-11",
        name: "UTC-11"
      },
      {
        value: "UTC-10",
        name: "UTC-10"
      },
      {
        value: "UTC-9",
        name: "UTC-9"
      },
      {
        value: "UTC-8",
        name: "UTC-8"
      },
      {
        value: "UTC-7",
        name: "UTC-7"
      },
      {
        value: "UTC-6",
        name: "UTC-6"
      },
      {
        value: "UTC-5",
        name: "UTC-5"
      },
      {
        value: "UTC-4",
        name: "UTC-4"
      },
      {
        value: "UTC-3",
        name: "UTC-3"
      },
      {
        value: "UTC-2",
        name: "UTC-2"
      },
      {
        value: "UTC-1",
        name: "UTC-1"
      },
      {
        value: "UTC+0",
        name: "UTC+0"
      },
      {
        value: "UTC+1",
        name: "UTC+1"
      },
      {
        value: "UTC+2",
        name: "UTC+2"
      },
      {
        value: "UTC+3",
        name: "UTC+3"
      },
      {
        value: "UTC+4",
        name: "UTC+4"
      },
      {
        value: "UTC+5",
        name: "UTC+5"
      },
      {
        value: "UTC+6",
        name: "UTC+6"
      },
      {
        value: "UTC+7",
        name: "UTC+7"
      },
      {
        value: "UTC+8",
        name: "UTC+8"
      },
      {
        value: "UTC+9",
        name: "UTC+9"
      },
      {
        value: "UTC+10",
        name: "UTC+10"
      },
      {
        value: "UTC+11",
        name: "UTC+11"
      },
      {
        value: "UTC+12",
        name: "UTC+12"
      },
      {
        value: "UTC+13",
        name: "UTC+13"
      },
      {
        value: "UTC+14",
        name: "UTC+14"
      }
    ]
  }
], lI = () => VI.flatMap((e) => e.zones.map((t) => t.value));
lI();
const cI = () => (e) => (t) => !!t && (Array.isArray(e) ? e.includes(t) : e === t), jg = () => (e) => (t) => Array.isArray(e) ? e.includes(t.type) : t.type === e, pt = jg(), fI = (e) => dx(e, "_v") && e._v === 1, dI = pt(ne.IF), hI = pt(ne.URL), mI = pt(ne.SET), pI = pt(ne.TEXT), gI = pt(ne.GOTO), bI = pt(ne.CARD), AI = pt(ne.IF_V2), EI = pt(ne.FLOW), vI = pt(ne.CODE), TI = pt(ne.EXIT), yI = pt(ne.SPEAK), _I = pt(ne.START), CI = pt(ne.SET_V2), SI = pt(ne.VISUAL), xI = pt(ne.STREAM), OI = pt(ne.RANDOM), wI = pt(ne.CARD_V2), II = pt(ne.CAPTURE), RI = pt(ne.GENERAL), NI = pt(ne.CAROUSEL), kI = pt(ne.RANDOM_V2), LI = pt(ne.GOTO_NODE), PI = pt(ne.DIRECTIVE), DI = pt(ne.CAPTURE_V2), MI = pt(ne.INTERACTION), FI = pt(ne.INTEGRATIONS), BI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createNodeTypeguard: pt,
  isCapture: II,
  isCaptureV2: DI,
  isCard: bI,
  isCardV2: wI,
  isCarousel: NI,
  isCode: vI,
  isDirective: PI,
  isExit: TI,
  isFlow: EI,
  isGeneral: RI,
  isGoTo: gI,
  isGoToNode: LI,
  isIf: dI,
  isIfV2: AI,
  isIntegrations: FI,
  isInteraction: MI,
  isRandom: OI,
  isRandomV2: kI,
  isSet: mI,
  isSetV2: CI,
  isSpeak: yI,
  isStart: _I,
  isStream: xI,
  isText: pI,
  isUrl: hI,
  isV1: fI,
  isVisual: SI
}, Symbol.toStringTag, { value: "Module" })), tt = cI(), $I = tt(ne.IF), UI = tt(ne.URL), HI = tt(ne.SET), jI = tt(ne.API), zI = tt(ne.GOTO), GI = tt(ne.TEXT), YI = tt(ne.CARD), WI = tt(ne.IF_V2), qI = tt(ne.FLOW), XI = tt(ne.CODE), KI = tt(ne.EXIT), ZI = tt(ne.SPEAK), QI = tt(ne.START), JI = tt(ne.SET_V2), eR = tt(ne.CAROUSEL), tR = tt(ne.PROMPT), nR = tt(ne.VISUAL), rR = tt(ne.INTENT), aR = tt(ne.STREAM), iR = tt(ne.ZAPIER), sR = tt(ne.RANDOM), oR = tt(ne.RANDOM_V2), uR = tt(ne.COMMAND), VR = tt(ne.BUTTONS), lR = tt(ne.CAPTURE), cR = tt(ne.GENERAL), fR = tt(ne.GOTO_NODE), dR = tt(ne.DIRECTIVE), hR = tt(ne.COMPONENT), mR = tt(ne.CAPTURE_V2), pR = tt(ne.GOTO_DOMAIN), gR = tt(ne.DEPRECATED), bR = tt(ne.INTERACTION), AR = tt(ne.INTEGRATIONS), ER = tt(ne.GOOGLE_SHEETS), vR = tt(Eg), TR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createNodeTypeTypeguard: tt,
  isApi: jI,
  isButtons: VR,
  isCapture: lR,
  isCaptureV2: mR,
  isCard: YI,
  isCarousel: eR,
  isCode: XI,
  isCommand: uR,
  isComponent: hR,
  isDeprecated: gR,
  isDirective: dR,
  isExit: KI,
  isFlow: qI,
  isGeneral: cR,
  isGoTo: zI,
  isGoToDomain: pR,
  isGoToNode: fR,
  isGoogleSheets: ER,
  isIf: $I,
  isIfV2: WI,
  isIntegrations: AR,
  isIntent: rR,
  isInteraction: bR,
  isPrompt: tR,
  isRandom: sR,
  isRandomV2: oR,
  isRuntimeOnly: vR,
  isSet: HI,
  isSetV2: JI,
  isSpeak: ZI,
  isStart: QI,
  isStream: aR,
  isText: GI,
  isUrl: UI,
  isVisual: nR,
  isZapier: iR
}, Symbol.toStringTag, { value: "Module" })), Ge = jg(), yR = Ge(ne.IF), _R = Ge(ne.URL), CR = Ge(ne.SET), SR = Ge(ne.API), xR = Ge(ne.TEXT), OR = Ge(ne.CARD), wR = Ge(ne.CARD_V2), IR = Ge(ne.IF_V2), RR = Ge(ne.FLOW), NR = Ge(ne.GOTO), kR = Ge(ne.CODE), LR = Ge(ne.EXIT), PR = Ge(ne.SPEAK), DR = Ge(ne.START), MR = Ge(ne.SET_V2), FR = Ge(ne.PROMPT), BR = Ge(ne.CAROUSEL), $R = Ge(ne.VISUAL), UR = Ge(ne.INTENT), HR = Ge(ne.STREAM), jR = Ge(ne.ZAPIER), zR = Ge(ne.RANDOM), GR = Ge(ne.RANDOM_V2), YR = Ge(ne.COMMAND), WR = Ge(ne.BUTTONS), qR = Ge(ne.CAPTURE), XR = Ge(ne.GENERAL), KR = Ge(ne.GOTO_NODE), ZR = Ge(ne.DIRECTIVE), QR = Ge(ne.COMPONENT), JR = Ge(ne.CAPTURE_V2), eN = Ge(ne.GOTO_DOMAIN), tN = Ge(ne.DEPRECATED), nN = Ge(ne.INTERACTION), rN = Ge(ne.GOOGLE_SHEETS), aN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createStepTypeguard: Ge,
  isApi: SR,
  isButtons: WR,
  isCapture: qR,
  isCaptureV2: JR,
  isCard: OR,
  isCardV2: wR,
  isCarousel: BR,
  isCode: kR,
  isCommand: YR,
  isComponent: QR,
  isDeprecated: tN,
  isDirective: ZR,
  isExit: LR,
  isFlow: RR,
  isGeneral: XR,
  isGoTo: NR,
  isGoToDomain: eN,
  isGoToNode: KR,
  isGoogleSheets: rN,
  isIf: yR,
  isIfV2: IR,
  isIntent: UR,
  isInteraction: nN,
  isPrompt: FR,
  isRandom: zR,
  isRandomV2: GR,
  isSet: CR,
  isSetV2: MR,
  isSpeak: PR,
  isStart: DR,
  isStream: HR,
  isText: xR,
  isUrl: _R,
  isVisual: $R,
  isZapier: jR
}, Symbol.toStringTag, { value: "Module" })), u0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ai: P3,
  node: BI,
  nodeType: TR,
  step: aN
}, Symbol.toStringTag, { value: "Module" }));
var Qo;
(function(e) {
  e.OFF = "OFF", e.ALL = "ALL", e.DIALOG = "DIALOG";
})(Qo || (Qo = {}));
var Jo;
(function(e) {
  e.RESUME = "resume", e.RESTART = "restart";
})(Jo || (Jo = {}));
var eu;
(function(e) {
  e.STATIC = "static", e.GENERATIVE = "generative";
})(eu || (eu = {}));
const hf = ({ error: e = null, repeat: t = Qo.ALL, session: n = { type: Jo.RESTART }, defaultVoice: r = null, defaultCanvasNodeVisibility: a = null, defaultCarouselLayout: i = null, globalNoMatch: s = { type: eu.STATIC, prompt: void 0 }, globalNoReply: o = { delay: void 0, prompt: void 0 }, intentConfidence: u = 0.6 } = {}) => ({
  error: e,
  repeat: t,
  session: n,
  defaultVoice: r,
  defaultCanvasNodeVisibility: a,
  defaultCarouselLayout: i,
  globalNoMatch: s,
  globalNoReply: o,
  intentConfidence: u
});
var gc;
(function(e) {
  e.PRODUCTION = "production", e.DEVELOPMENT = "development";
})(gc || (gc = {}));
const zg = ({ slots: e = [], intents: t = [], settings: n = {}, publishing: r = {} }) => ({
  slots: e,
  intents: t,
  settings: hf(n),
  publishing: r
}), SV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get GlobalNoMatchType() {
    return eu;
  },
  get RepeatType() {
    return Qo;
  },
  get SessionType() {
    return Jo;
  },
  get VersionTag() {
    return gc;
  },
  defaultPlatformData: zg,
  defaultSettings: hf
}, Symbol.toStringTag, { value: "Module" })), iN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseButton: Nh,
  BaseModels: kh,
  BaseNode: Lh,
  BaseProject: Ph,
  BaseRequest: Dh,
  BaseText: Fh,
  BaseTrace: Bh,
  BaseUtils: u0,
  BaseVersion: SV,
  Button: Nh,
  Models: kh,
  Node: Lh,
  Project: Ph,
  Request: Dh,
  RuntimeLogs: I3,
  Text: Fh,
  Trace: Bh,
  Utils: u0,
  VariableState: SV,
  Version: SV
}, Symbol.toStringTag, { value: "Module" })), sN = (e = {}) => ({
  ...vg(e)
}), oN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultPlatformData: sN
}, Symbol.toStringTag, { value: "Module" })), uN = pt(ne.CAPTURE), VN = pt(ne.CAPTURE_V2), lN = pt(ne.INTERACTION), cN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isCapture: uN,
  isCaptureV2: VN,
  isInteraction: lN
}, Symbol.toStringTag, { value: "Module" })), Gg = (e) => e != null && e.content ? {
  id: e.id,
  content: e.content
} : null, fN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultPrompt: Gg
}, Symbol.toStringTag, { value: "Module" })), dN = Ge(ne.PROMPT), hN = Ge(ne.BUTTONS), mN = Ge(ne.CAPTURE), pN = Ge(ne.CAPTURE_V2), gN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isButtons: hN,
  isCapture: mN,
  isCaptureV2: pN,
  isPrompt: dN
}, Symbol.toStringTag, { value: "Module" })), bN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  node: cN,
  prompt: fN,
  step: gN
}, Symbol.toStringTag, { value: "Module" })), Yg = ({ durationMilliseconds: e = 1e3 } = {}) => ({
  durationMilliseconds: e
}), Wg = ({ error: e, messageDelay: t, ...n } = {}) => ({
  ...hf(n),
  error: Gg(e),
  messageDelay: Yg(t)
}), AN = ({ intents: e = [], settings: t = {}, ...n }) => ({
  ...zg(n),
  intents: e,
  settings: Wg(t)
}), EN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultMessageDelay: Yg,
  defaultPlatformData: AN,
  defaultSettings: Wg
}, Symbol.toStringTag, { value: "Module" })), vN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ChatModels: eS,
  ChatNode: VS,
  ChatProject: oN,
  ChatUtils: bN,
  ChatVersion: EN
}, Symbol.toStringTag, { value: "Module" })), qg = /* @__PURE__ */ Zc(vN);
var bc = {}, Cu = {}, Xg = {}, Su = {};
Object.defineProperty(Su, "__esModule", { value: !0 });
Su.AZURE_LOCALE_VOICE_META = void 0;
Su.AZURE_LOCALE_VOICE_META = {
  "ar-EG": {
    language: "Arabic (Arabic )",
    locale: "ar-EG",
    voices: [{ gender: "Female", voiceID: "ar-EG-SalmaNeural" }]
  },
  "ar-SA": {
    language: "Arabic (Saudi Arabia)",
    locale: "ar-SA",
    voices: [{ gender: "Male", voiceID: "ar-SA-HamedNeural" }]
  },
  "bg-BG": {
    language: "Bulgarian (Bulgaria)",
    locale: "bg-BG",
    voices: [{ gender: "Male", voiceID: "bg-BG-KalinaNeural" }]
  },
  "ca-ES": {
    language: "Catalan (Spain)",
    locale: "ca-ES",
    voices: [{ gender: "Female", voiceID: "ca-ES-AlbaNeural" }]
  },
  "zh-HK": {
    language: "Chinese (Cantonese, Traditional)",
    locale: "zh-HK",
    voices: [
      { gender: "Male", voiceID: "zh-HK-WanLungNeural" },
      { gender: "Female", voiceID: "zh-HK-HiuGaaiNeural" }
    ]
  },
  "zh-CN": {
    language: "Chinese (Mandarin, Simplified)",
    locale: "zh-CN",
    voices: [
      { gender: "Female", voiceID: "zh-CN-XiaochenNeural" },
      { gender: "Male", voiceID: "zh-CN-YunxiNeural" },
      { gender: "Female", voiceID: "zh-CN-XiaohanNeural" }
    ]
  },
  "zh-TW": {
    language: "Chinese (Taiwanese Mandarin)",
    locale: "zh-TW",
    voices: [
      { gender: "Female", voiceID: "zh-TW-HsiaoChenNeural" },
      { gender: "Female", voiceID: "zh-TW-HsiaoYuNeural" },
      { gender: "Male", voiceID: "zh-TW-YunJheNeural" }
    ]
  },
  "hr-HR": {
    language: "Croatian (Croatia)",
    locale: "hr-HR",
    voices: [{ gender: "Male", voiceID: "hr-HR-SreckoNeural" }]
  },
  "cs-CZ": {
    language: "Czech (Czech Republic)",
    locale: "cs-CZ",
    voices: [{ gender: "Male", voiceID: "cs-CZ-AntoninNeural" }]
  },
  "da-DK": {
    language: "Danish (Denmark)",
    locale: "da-DK",
    voices: [{ gender: "Female", voiceID: "da-DK-ChristelNeural" }]
  },
  "nl-NL": {
    language: "Dutch (Netherlands)",
    locale: "nl-NL",
    voices: [{ gender: "Female", voiceID: "nl-NL-ColetteNeural" }]
  },
  "en-AU": {
    language: "English (Australia)",
    locale: "en-AU",
    voices: [
      { gender: "Female", voiceID: "en-AU-NatashaNeural" },
      { gender: "Male", voiceID: "en-AU-WilliamNeural" }
    ]
  },
  "en-CA": {
    language: "English (Canada)",
    locale: "en-CA",
    voices: [
      { gender: "Female", voiceID: "en-CA-ClaraNeural" },
      { gender: "Male", voiceID: "en-CA-LiamNeural" }
    ]
  },
  "en-IN": {
    language: "English (India)",
    locale: "en-IN",
    voices: [
      { gender: "Female", voiceID: "en-IN-NeerjaNeural" },
      { gender: "Male", voiceID: "en-IN-PrabhatNeural" }
    ]
  },
  "en-IE": {
    language: "English (Ireland)",
    locale: "en-IE",
    voices: [{ gender: "Male", voiceID: "en-IE-ConnorNeural" }]
  },
  "en-GB": {
    language: "English (United Kingdom)",
    locale: "en-GB",
    voices: [
      { gender: "Male", voiceID: "en-GB-RyanNeural" },
      { gender: "Female", voiceID: "en-GB-LibbyNeural" },
      { gender: "Female", voiceID: "en-GB-SoniaNeural" }
    ]
  },
  "en-US": {
    language: "English (United States)",
    locale: "en-US",
    voices: [
      { gender: "Male", voiceID: "en-US-SaraNeural" },
      { gender: "Male", voiceID: "en-US-ElizabethNeural" },
      { gender: "Female", voiceID: "en-US-BrandonNeural" },
      { gender: "Female", voiceID: "en-US-ChristopherNeural" }
    ]
  },
  "fi-FI": {
    language: "Finnish (Finland)",
    locale: "fi-FI",
    voices: [{ gender: "Female", voiceID: "fi-FI-NooraNeural" }]
  },
  "fr-CA": {
    language: "French (Canada)",
    locale: "fr-CA",
    voices: [
      { gender: "Female", voiceID: "fr-CA-SylvieNeural" },
      { gender: "Male", voiceID: "fr-CA-AntoineNeural" }
    ]
  },
  "fr-FR": {
    language: "French (France)",
    locale: "fr-FR",
    voices: [
      { gender: "Female", voiceID: "fr-FR-DeniseNeural" },
      { gender: "Male", voiceID: "fr-FR-HenriNeural" }
    ]
  },
  "fr-CH": {
    language: "French (Switzerland)",
    locale: "fr-CH",
    voices: [{ gender: "Male", voiceID: "fr-CH-FabriceNeural" }]
  },
  "de-AT": {
    language: "German (Austria)",
    locale: "de-AT",
    voices: [{ gender: "Male", voiceID: "de-AT-JonasNeural" }]
  },
  "de-DE": {
    language: "German (Germany)",
    locale: "de-DE",
    voices: [
      { gender: "Female", voiceID: "de-DE-KatjaNeural" },
      { gender: "Male", voiceID: "de-DE-ConradNeural" }
    ]
  },
  "de-CH": {
    language: "German (Switzerland)",
    locale: "de-CH",
    voices: [{ gender: "Male", voiceID: "de-CH-JanNeural" }]
  },
  "el-GR": {
    language: "Greek (Greece)",
    locale: "el-GR",
    voices: [{ gender: "Male", voiceID: "el-GR-NestorasNeural" }]
  },
  "he-IL": { language: "Hebrew (Israel)", locale: "he-IL", voices: [{ gender: "Male", voiceID: "he-IL-AvriNeural" }] },
  "hi-IN": {
    language: "Hindi (India)",
    locale: "hi-IN",
    voices: [
      { gender: "Male", voiceID: "hi-IN-MadhurNeural" },
      { gender: "Female", voiceID: "hi-IN-SwaraNeural" }
    ]
  },
  "hu-HU": {
    language: "Hungarian (Hungary)",
    locale: "hu-HU",
    voices: [{ gender: "Male", voiceID: "hu-HU-TamasNeural" }]
  },
  "id-ID": {
    language: "Indonesian (Indonesia)",
    locale: "id-ID",
    voices: [{ gender: "Male", voiceID: "id-ID-ArdiNeural" }]
  },
  "it-IT": {
    language: "Italian (Italy)",
    locale: "it-IT",
    voices: [
      { gender: "Male", voiceID: "it-IT-DiegoNeural" },
      { gender: "Female", voiceID: "it-IT-ElsaNeural" }
    ]
  },
  "ja-JP": {
    language: "Japanese (Japan)",
    locale: "ja-JP",
    voices: [
      { gender: "Female", voiceID: "ja-JP-NanamiNeural" },
      { gender: "Male", voiceID: "ja-JP-KeitaNeural" }
    ]
  },
  "ko-KR": {
    language: "Korean (Korea)",
    locale: "ko-KR",
    voices: [{ gender: "Female", voiceID: "ko-KR-SunHiNeural" }]
  },
  "ms-MY": {
    language: "Malay (Malaysia)",
    locale: "ms-MY",
    voices: [{ gender: "Male", voiceID: "ms-MY-OsmanNeural" }]
  },
  "nb-NO": {
    language: "Norwegian (Bokml, Norway)",
    locale: "nb-NO",
    voices: [{ gender: "Female", voiceID: "nb-NO-IselinNeural" }]
  },
  "pl-PL": {
    language: "Polish (Poland)",
    locale: "pl-PL",
    voices: [{ gender: "Female", voiceID: "pl-PL-AgnieszkaNeural" }]
  },
  "pt-BR": {
    language: "Portuguese (Brazil)",
    locale: "pt-BR",
    voices: [
      { gender: "Male", voiceID: "pt-BR-AntonioNeural" },
      { gender: "Female", voiceID: "pt-BR-FranciscaNeural" }
    ]
  },
  "pt-PT": {
    language: "Portuguese (Portugal)",
    locale: "pt-PT",
    voices: [{ gender: "Female", voiceID: "pt-PT-FernandaNeural" }]
  },
  "ro-RO": {
    language: "Romanian (Romania)",
    locale: "ro-RO",
    voices: [{ gender: "Male", voiceID: "ro-RO-EmilNeural" }]
  },
  "ru-RU": {
    language: "Russian (Russia)",
    locale: "ru-RU",
    voices: [
      { gender: "Female", voiceID: "ru-RU-DariyaNeural" },
      { gender: "Female", voiceID: "ru-RU-SvetlanaNeural" },
      { gender: "Male", voiceID: "ru-RU-DmitryNeural" }
    ]
  },
  "sk-SK": {
    language: "Slovak (Slovakia)",
    locale: "sk-SK",
    voices: [{ gender: "Male", voiceID: "sk-SK-ViktoriaNeural" }]
  },
  "sl-SI": {
    language: "Slovenian (Slovenia)",
    locale: "sl-SI",
    voices: [{ gender: "Male", voiceID: "sl-SI-RokNeural" }]
  },
  "es-MX": {
    language: "Spanish (Mexico)",
    locale: "es-MX",
    voices: [
      { gender: "Female", voiceID: "es-MX-DaliaNeural" },
      { gender: "Male", voiceID: "es-MX-JorgeNeural" }
    ]
  },
  "es-ES": {
    language: "Spanish (Spain)",
    locale: "es-ES",
    voices: [
      { gender: "Female", voiceID: "es-ES-ElviraNeural" },
      { gender: "Male", voiceID: "es-ES-AlvaroNeural" }
    ]
  },
  "sv-SE": {
    language: "Swedish (Sweden)",
    locale: "sv-SE",
    voices: [{ gender: "Female", voiceID: "sv-SE-HilleviNeural" }]
  },
  "ta-IN": {
    language: "Tamil (India)",
    locale: "ta-IN",
    voices: [{ gender: "Male", voiceID: "ta-IN-ValluvarNeural" }]
  },
  "te-IN": {
    language: "Telugu (India)",
    locale: "te-IN",
    voices: [{ gender: "Female", voiceID: "te-IN-ShrutiNeural" }]
  },
  "th-TH": { language: "Thai (Thailand)", locale: "th-TH", voices: [{ gender: "Male", voiceID: "th-TH-NiwatNeural" }] },
  "tr-TR": {
    language: "Turkish (Turkey)",
    locale: "tr-TR",
    voices: [{ gender: "Female", voiceID: "tr-TR-EmelNeural" }]
  },
  "vi-VN": {
    language: "Vietnamese (Vietnam)",
    locale: "vi-VN",
    voices: [{ gender: "Male", voiceID: "vi-VN-NamMinhNeural" }]
  }
};
var er = {};
Object.defineProperty(er, "__esModule", { value: !0 });
er.isVoiceflowLanguage = er.Language = er.Locale = er.Voice = void 0;
var V0;
(function(e) {
  e.AUDIO = "audio", e.DEFAULT = "default";
})(V0 || (er.Voice = V0 = {}));
var l0;
(function(e) {
  e.EN_US = "en-US", e.AR_AR = "ar-AR", e.BG_BG = "bg-BG", e.CA_ES = "ca-ES", e.CS_CZ = "cs-CZ", e.ZH_CN = "zh-CN", e.ZH_TW = "zh-TW", e.DA_DK = "da-DK", e.NL_NL = "nl-NL", e.NL_BE = "nl-BE", e.ET_EE = "et-EE", e.FR_FR = "fr-FR", e.FR_CA = "fr-CA", e.DE_DE = "de-DE", e.HE_IL = "he-IL", e.HU_HU = "hu-HU", e.GU_IN = "gu-IN", e.HI_IN = "hi-IN", e.IT_IT = "it-IT", e.JA_JP = "ja-JP", e.KO_KR = "ko-KR", e.MR_IN = "mr-IN", e.PL_PL = "pl-PL", e.PT_PT = "pt-PT", e.PT_BR = "pt-BR", e.RO_RO = "ro-RO", e.RU_RU = "ru-RU", e.ES_ES = "es-ES", e.ES_MX = "es-MX", e.TA_IN = "ta-IN", e.TE_IN = "te-IN", e.TR_TR = "tr-TR", e.UK_UA = "uk-UA", e.VI_VN = "vi-VN";
})(l0 || (er.Locale = l0 = {}));
var Ac;
(function(e) {
  e.EN = "en", e.AR = "ar", e.BG = "bg", e.CA = "ca", e.CS = "cs", e.ZH = "zh", e.DA = "da", e.NL = "nl", e.ET = "et", e.FR = "fr", e.DE = "de", e.GU = "gu", e.HE = "he", e.HI = "hi", e.HU = "hu", e.IT = "it", e.JA = "ja", e.KO = "ko", e.MR = "mr", e.PL = "pl", e.PT = "pt", e.RO = "ro", e.RU = "ru", e.ES = "es", e.TA = "ta", e.TE = "te", e.TR = "tr", e.UK = "uk", e.VI = "vi";
})(Ac || (er.Language = Ac = {}));
const TN = new Set(Object.values(Ac)), yN = (e) => TN.has(e);
er.isVoiceflowLanguage = yN;
var xu = {};
const _N = /* @__PURE__ */ Zc(iN);
Object.defineProperty(xu, "__esModule", { value: !0 });
xu.DEVICE_SIZE_MAP = void 0;
const Bn = _N;
xu.DEVICE_SIZE_MAP = {
  [Bn.BaseNode.Visual.DeviceType.MOBILE]: { width: 375, height: 812 },
  [Bn.BaseNode.Visual.DeviceType.TABLET]: { width: 1024, height: 1366 },
  [Bn.BaseNode.Visual.DeviceType.DESKTOP]: { width: 1440, height: 900 },
  [Bn.BaseNode.Visual.DeviceType.SMART_WATCH]: { width: 184, height: 224 },
  [Bn.BaseNode.Visual.DeviceType.TELEVISION]: { width: 1920, height: 1200 },
  [Bn.BaseNode.Visual.DeviceType.IN_CAR_DISPLAY]: { width: 1200, height: 800 },
  [Bn.BaseNode.Visual.DeviceType.ECHO_SPOT]: { width: 480, height: 480 },
  [Bn.BaseNode.Visual.DeviceType.ECHO_SHOW_8]: { width: 1280, height: 800 },
  [Bn.BaseNode.Visual.DeviceType.ECHO_SHOW_10]: { width: 1280, height: 800 },
  [Bn.BaseNode.Visual.DeviceType.FIRE_HD_8]: { width: 1280, height: 800 },
  [Bn.BaseNode.Visual.DeviceType.FIRE_HD_10]: { width: 1920, height: 1200 },
  [Bn.BaseNode.Visual.DeviceType.FIRE_TV_CUBE]: { width: 1920, height: 1080 },
  [Bn.BaseNode.Visual.DeviceType.GOOGLE_NEST_HUB]: { width: 1280, height: 730 }
};
var Kg = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DEFAULT_INTENTS_MAP = e.findDefaultIntent = e.IntentName = void 0;
  const t = er;
  var n;
  (function(a) {
    a.NO = "VF.NO", a.YES = "VF.YES", a.STOP = "VF.STOP", a.NEXT = "VF.NEXT", a.HELP = "VF.HELP", a.PAUSE = "VF.PAUSE", a.CANCEL = "VF.CANCEL", a.RESUME = "VF.RESUME", a.REPEAT = "VF.REPEAT", a.PREVIOUS = "VF.PREVIOUS", a.START_OVER = "VF.START_OVER", a.NONE = "None";
  })(n || (e.IntentName = n = {}));
  const r = (a, i) => {
    var s, o;
    return (o = (s = e.DEFAULT_INTENTS_MAP) == null ? void 0 : s[a]) == null ? void 0 : o.find((u) => u.name === i);
  };
  e.findDefaultIntent = r, e.DEFAULT_INTENTS_MAP = {
    // English (AU,CA,US,UK,IN)
    [t.Language.EN]: [
      {
        name: n.NO,
        samples: ["no", "nope", "nay", "nah", "no way", "negative"]
      },
      {
        name: n.YES,
        samples: ["yes", "yea", "ok", "okay", "yup", "ya", "sure"]
      },
      {
        name: n.STOP,
        samples: ["stop"]
      },
      {
        name: n.NEXT,
        samples: ["next"]
      },
      {
        name: n.HELP,
        samples: ["help", "help me", "i need help"]
      },
      {
        name: n.PAUSE,
        samples: ["pause"]
      },
      {
        name: n.CANCEL,
        samples: ["cancel"]
      },
      {
        name: n.RESUME,
        samples: ["resume"]
      },
      {
        name: n.REPEAT,
        samples: ["repeat", "again", "say again"]
      },
      {
        name: n.PREVIOUS,
        samples: ["previous"]
      },
      {
        name: n.START_OVER,
        samples: ["start over", "restart"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // French (CA,FR)
    [t.Language.FR]: [
      {
        name: n.NO,
        samples: ["non", "nan", "absolument pas", "hors de question", "bien sr que non"]
      },
      {
        name: n.YES,
        samples: ["oui", "yep", "ok", "bien sr", "ouais", "ouaip", "exactement", "correct", "okay", "d'accord"]
      },
      {
        name: n.STOP,
        samples: [
          "s'arrter",
          "arrter",
          "arrte",
          "stop",
          "fin",
          "cesser",
          "mettre fin",
          "stopper",
          "mettre un terme",
          "interrompre"
        ]
      },
      {
        name: n.HELP,
        samples: ["aidez-moi", "l'assistance", "aider"]
      },
      {
        name: n.NEXT,
        samples: ["prochaine", "prochain", "suivant"]
      },
      {
        name: n.PAUSE,
        samples: ["pause"]
      },
      {
        name: n.CANCEL,
        samples: ["annuler", "annule"]
      },
      {
        name: n.RESUME,
        samples: ["reprendre"]
      },
      {
        name: n.REPEAT,
        samples: [
          "repeat",
          "est-ce que tu peux rpter",
          "rpte",
          "tu peux rpter",
          "dis-le  nouveau",
          "tu peux le redire",
          "redire a",
          "rpter a"
        ]
      },
      {
        name: n.PREVIOUS,
        samples: ["prcdente", "prcdent"]
      },
      {
        name: n.START_OVER,
        samples: ["recommencer", "redmarrer"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // Japanese (JA)
    [t.Language.JA]: [
      {
        name: n.NO,
        samples: ["no", "", "", "", "", "", ""]
      },
      {
        name: n.YES,
        samples: ["yes", "", "", ""]
      },
      {
        name: n.STOP,
        samples: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ]
      },
      {
        name: n.NEXT,
        samples: ["", ""]
      },
      {
        name: n.HELP,
        samples: ["", "", ""]
      },
      {
        name: n.PAUSE,
        samples: ["", ""]
      },
      {
        name: n.CANCEL,
        samples: ["", "", "", ""]
      },
      {
        name: n.RESUME,
        samples: [""]
      },
      {
        name: n.REPEAT,
        samples: ["repeat", "", "", "", ""]
      },
      {
        name: n.PREVIOUS,
        samples: ["", ""]
      },
      {
        name: n.START_OVER,
        samples: ["", ""]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // Italian (IT)
    [t.Language.IT]: [
      {
        name: n.NO,
        samples: ["no", "il no", "il rifiuto", "la negazione", "nessuno"]
      },
      {
        name: n.YES,
        samples: ["yes", "si", "certo"]
      },
      {
        name: n.STOP,
        samples: [
          "stop",
          "la fermata",
          "il fermo",
          "lo stop",
          "la sosta",
          "la tappa",
          "fermare",
          "interrompere",
          "smettere",
          "fermarsi",
          "arrestare",
          "cessare",
          "sostare",
          "finire",
          "stoppare",
          "fare una fermata"
        ]
      },
      {
        name: n.NEXT,
        samples: ["prossimo", "seguente", "succesivo"]
      },
      {
        name: n.HELP,
        samples: ["aiuto", "la assistenza", "aiutami"]
      },
      {
        name: n.PAUSE,
        samples: ["pausa", "la pausa"]
      },
      {
        name: n.CANCEL,
        samples: ["cancellare", "annullare", "disdire", "sopprimere", "rescindre", "chiudere", "abrogare", "obliterare"]
      },
      {
        name: n.RESUME,
        samples: ["riprendere"]
      },
      {
        name: n.REPEAT,
        samples: ["ripetere", "la ripetizione"]
      },
      {
        name: n.PREVIOUS,
        samples: ["precedente"]
      },
      {
        name: n.START_OVER,
        samples: ["ricominciare", "ricomincia"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // Spanish (ES,MX)
    [t.Language.ES]: [
      {
        name: n.NO,
        samples: ["no", "ninguno", "imposible", "prohibido", "la negativa", "el voto negativo", "el voto en contra"]
      },
      {
        name: n.YES,
        samples: ["yes", "si", "s", "decir si"]
      },
      {
        name: n.STOP,
        samples: ["detener", "dejar", "parar", "suspender", "cesar", "pararse", "terminar", "de alto"]
      },
      {
        name: n.NEXT,
        samples: ["siguiente", "prximo"]
      },
      {
        name: n.HELP,
        samples: ["ayuda", "ayuadame"]
      },
      {
        name: n.PAUSE,
        samples: ["pausa", "la pausa"]
      },
      {
        name: n.CANCEL,
        samples: [
          "cancelar",
          "anular",
          "suprimir",
          "abolir",
          "dar anulacin",
          "realizar anulacin",
          "hacer anulacin",
          "hacer dar anulacin",
          "noun la cancelacin",
          "la anulacin"
        ]
      },
      {
        name: n.RESUME,
        samples: ["reanudar"]
      },
      {
        name: n.REPEAT,
        samples: ["repeat", "repetir", "repetirse", "reiterar", "recitar", "volver a dar"]
      },
      {
        name: n.PREVIOUS,
        samples: ["previa", "previo"]
      },
      {
        name: n.START_OVER,
        samples: ["reiniciar"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // German (DE)
    [t.Language.DE]: [
      {
        name: n.NO,
        samples: ["no", "nein", "kein", "nicht"]
      },
      {
        name: n.YES,
        samples: ["yes", "ja", "doch", "jawohl"]
      },
      {
        name: n.STOP,
        samples: [
          "der stopp",
          "der anschlag",
          "die haltestelle",
          "der registerzug",
          "stoppen",
          "aufhren",
          "beenden",
          "anhalten",
          "halten",
          "verhindern",
          "aufhalten",
          "unterbrechen",
          "abbrechen",
          "unterbinden",
          "einstellen",
          "abbestellen",
          "absetzen"
        ]
      },
      {
        name: n.NEXT,
        samples: ["nchster", "nchste", "neben"]
      },
      {
        name: n.HELP,
        samples: ["hilfe", "hilf mir", "helfen"]
      },
      {
        name: n.PAUSE,
        samples: ["pause", "pausieren", "die pause"]
      },
      {
        name: n.CANCEL,
        samples: [
          "stornieren",
          "aufheben",
          "kndigen",
          "annullieren",
          "beenden",
          "absagen",
          "abbestellen",
          "abmelden",
          "auflsen",
          "zurcknehmen"
        ]
      },
      {
        name: n.RESUME,
        samples: ["wieder aufnehmen", "fortsetzen", "fortfahren"]
      },
      {
        name: n.REPEAT,
        samples: ["repeat", "wiederholen", "wiedergeben", "repetieren", "weitersagen"]
      },
      {
        name: n.PREVIOUS,
        samples: ["bisherige", "frher"]
      },
      {
        name: n.START_OVER,
        samples: ["Von vorn anfangen", "Neustart", "wieder starten"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // Portuguese (PT)
    [t.Language.PT]: [
      {
        name: n.NO,
        samples: ["no", "no", "negativa"]
      },
      {
        name: n.YES,
        samples: ["yes", "sim", "o sim", "dizer sim"]
      },
      {
        name: n.STOP,
        samples: ["parar", "terminar", "impedir", "fazer parar"]
      },
      {
        name: n.NEXT,
        samples: ["prxima", "prximo", "seguinte", "seguida"]
      },
      {
        name: n.HELP,
        samples: ["socorro", "me ajude"]
      },
      {
        name: n.PAUSE,
        samples: ["pausa", "pausar"]
      },
      {
        name: n.CANCEL,
        samples: ["cancelar", "anular", "suspender"]
      },
      {
        name: n.RESUME,
        samples: ["retomar"]
      },
      {
        name: n.REPEAT,
        samples: ["repeat", "repetir", "reiterar", "refazer", "amiudar", "recitar de cor"]
      },
      {
        name: n.PREVIOUS,
        samples: ["anterior"]
      },
      {
        name: n.START_OVER,
        samples: ["recomear", "reiniciar"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // Hindi (IN)
    [t.Language.HI]: [
      {
        name: n.NO,
        samples: ["", "", "", "", ""]
      },
      {
        name: n.YES,
        samples: [
          "",
          "",
          "",
          "",
          " ",
          "",
          " ",
          "",
          " ",
          "",
          "  ",
          "",
          "",
          " ",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ]
      },
      {
        name: n.STOP,
        samples: [
          "",
          "",
          "",
          "",
          "",
          "",
          " ",
          "",
          " ",
          "  ",
          " ",
          ""
        ]
      },
      {
        name: n.NEXT,
        samples: ["", "", "", ""]
      },
      {
        name: n.HELP,
        samples: ["", "  "]
      },
      {
        name: n.PAUSE,
        samples: ["", ""]
      },
      {
        name: n.CANCEL,
        samples: [
          " ",
          " ",
          "  ",
          " ",
          " ",
          "  ",
          " ",
          " ",
          " ",
          " ",
          " ",
          " ",
          "",
          " ",
          " ",
          "  "
        ]
      },
      {
        name: n.RESUME,
        samples: ["  ", "   ", "     "]
      },
      {
        name: n.REPEAT,
        samples: [
          " ",
          " ",
          "  ",
          " ",
          "  ",
          " ",
          "  ",
          " ",
          " ",
          "  ",
          " ",
          "  ",
          " ",
          "  ",
          " ",
          "  ",
          "",
          "  ",
          "",
          " "
        ]
      },
      {
        name: n.PREVIOUS,
        samples: ["", ""]
      },
      {
        name: n.START_OVER,
        samples: [" ", " "]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    [t.Language.BG]: [
      { name: n.NO, samples: ["", "", "", " ", ""] },
      {
        name: n.YES,
        samples: ["", "", "", "", "", " "]
      },
      {
        name: n.STOP,
        samples: ["", ""]
      },
      {
        name: n.NEXT,
        samples: ["", "", ""]
      },
      {
        name: n.HELP,
        samples: ["", " ", "  "]
      },
      {
        name: n.PAUSE,
        samples: ["", ""]
      },
      {
        name: n.CANCEL,
        samples: ["", ""]
      },
      {
        name: n.RESUME,
        samples: ["", ""]
      },
      {
        name: n.REPEAT,
        samples: ["", "", " "]
      },
      {
        name: n.PREVIOUS,
        samples: ["", "", ""]
      },
      {
        name: n.START_OVER,
        samples: [" ", ""]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // ca-ES
    [t.Language.CA]: [
      { name: n.NO, samples: ["no", "no", "no", "no", "de cap manera", "negatiu"] },
      {
        name: n.YES,
        samples: ["s", "s", "d'acord", "d'acord", "s", "s", "clar"]
      },
      {
        name: n.STOP,
        samples: ["atura"]
      },
      {
        name: n.NEXT,
        samples: ["segent"]
      },
      {
        name: n.HELP,
        samples: ["ajuda", "ajuda", "necessito ajuda"]
      },
      {
        name: n.PAUSE,
        samples: ["pausa"]
      },
      {
        name: n.CANCEL,
        samples: ["cancella"]
      },
      {
        name: n.RESUME,
        samples: ["continua"]
      },
      {
        name: n.REPEAT,
        samples: ["repeteix", "una altra vegada", "digues-ho una altra vegada"]
      },
      {
        name: n.PREVIOUS,
        samples: ["anterior"]
      },
      {
        name: n.START_OVER,
        samples: ["comena de nou", "reinicia"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // 'cs-CZ'
    [t.Language.CS]: [
      {
        name: n.NO,
        samples: ["ne", "nechci", "nic", "nikoliv", "nebylo by vhodn"]
      },
      {
        name: n.YES,
        samples: ["ano", "jist", "dobe", "jo", "urit"]
      },
      {
        name: n.STOP,
        samples: ["zastavit", "pestat", "skonit"]
      },
      {
        name: n.NEXT,
        samples: ["dal", "dl", "pokraovat"]
      },
      {
        name: n.HELP,
        samples: ["pomoc", "potebuji pomoc", "npovda"]
      },
      {
        name: n.PAUSE,
        samples: ["pauza", "pozastavit", "zastavit na chvli"]
      },
      {
        name: n.CANCEL,
        samples: ["zruit", "zruen", "odvolat"]
      },
      {
        name: n.RESUME,
        samples: ["obnovit", "pokraovat", "znovu spustit"]
      },
      {
        name: n.REPEAT,
        samples: ["opakovat", "znovu", "ci znovu"]
      },
      {
        name: n.PREVIOUS,
        samples: ["pedchoz", "zpt", "zpt na pedchoz"]
      },
      {
        name: n.START_OVER,
        samples: ["zat znovu", "restartovat"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // 'da-DK'
    [t.Language.DA]: [
      {
        name: n.NO,
        samples: ["nej", "n", "nej tak", "negative"]
      },
      {
        name: n.YES,
        samples: ["ja", "jo", "okay", "selvflgelig"]
      },
      {
        name: n.STOP,
        samples: ["stop"]
      },
      {
        name: n.NEXT,
        samples: ["nste"]
      },
      {
        name: n.HELP,
        samples: ["hjlp", "hjlp mig", "jeg har brug for hjlp"]
      },
      {
        name: n.PAUSE,
        samples: ["pause"]
      },
      {
        name: n.CANCEL,
        samples: ["annuller"]
      },
      {
        name: n.RESUME,
        samples: ["genoptag", "fortst"]
      },
      {
        name: n.REPEAT,
        samples: ["gentag", "igen", "sig det igen"]
      },
      {
        name: n.PREVIOUS,
        samples: ["forrige"]
      },
      {
        name: n.START_OVER,
        samples: ["start forfra", "genstart"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // et-EE
    [t.Language.ET]: [
      {
        name: n.NO,
        samples: ["ei", "ei ole", "ei taha", "mitte", "negatiivne"]
      },
      {
        name: n.YES,
        samples: ["jah", "okei", "ok", "kindlasti", "jah-jah", "jah, muidugi"]
      },
      {
        name: n.STOP,
        samples: ["peata", "lpeta", "stopp"]
      },
      {
        name: n.NEXT,
        samples: ["jrgmine", "edasi"]
      },
      {
        name: n.HELP,
        samples: ["abi", "aita mind", "vajan abi"]
      },
      {
        name: n.PAUSE,
        samples: ["paus", "peatus"]
      },
      {
        name: n.CANCEL,
        samples: ["thista", "katkesta"]
      },
      {
        name: n.RESUME,
        samples: ["jtka", "taasalusta"]
      },
      {
        name: n.REPEAT,
        samples: ["korda", "uuesti", "tle uuesti"]
      },
      {
        name: n.PREVIOUS,
        samples: ["eelmine", "tagasi"]
      },
      {
        name: n.START_OVER,
        samples: ["alusta otsast", "alusta uuesti"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // he-IL
    [t.Language.HE]: [
      {
        name: n.NO,
        samples: ["", " ", " ", "", " ", ""]
      },
      {
        name: n.YES,
        samples: ["", " ", "", "", "", " ", ""]
      },
      {
        name: n.STOP,
        samples: ["", ""]
      },
      {
        name: n.NEXT,
        samples: ["", " ", ""]
      },
      {
        name: n.HELP,
        samples: ["", " ", "  "]
      },
      {
        name: n.PAUSE,
        samples: ["", ""]
      },
      {
        name: n.CANCEL,
        samples: ["", "  "]
      },
      {
        name: n.RESUME,
        samples: ["", " "]
      },
      {
        name: n.REPEAT,
        samples: ["", "", " "]
      },
      {
        name: n.PREVIOUS,
        samples: ["", " ", " "]
      },
      {
        name: n.START_OVER,
        samples: [" ", " ", ""]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // hu-HU
    [t.Language.HU]: [
      {
        name: n.NO,
        samples: ["nem", "nincs", "nem", "nem", "nincs md", "negatv"]
      },
      {
        name: n.YES,
        samples: ["igen", "igen", "rendben", "ok", "igen", "igen", "biztos"]
      },
      {
        name: n.STOP,
        samples: ["llj", "llj le", "meglls"]
      },
      {
        name: n.NEXT,
        samples: ["kvetkez"]
      },
      {
        name: n.HELP,
        samples: ["segtsg", "segts nekem", "segtsg kell"]
      },
      {
        name: n.PAUSE,
        samples: ["sznet", "szneteltets"]
      },
      {
        name: n.CANCEL,
        samples: ["mgse", "mgsem", "megszntets"]
      },
      {
        name: n.RESUME,
        samples: ["folytats", "folytat", "jrakezds"]
      },
      {
        name: n.REPEAT,
        samples: ["ismteld", "mg egyszer", "ismteld meg"]
      },
      {
        name: n.PREVIOUS,
        samples: ["elz"]
      },
      {
        name: n.START_OVER,
        samples: ["jrakezds", "jraindts"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // pl-PL
    [t.Language.PL]: [
      {
        name: n.NO,
        samples: ["nie", "nie ma", "nigdy", "niech", "nie moliwe", "negatywne"]
      },
      {
        name: n.YES,
        samples: ["tak", "take", "ok", "dobrze", "oczywicie", "jasne", "pewnie"]
      },
      {
        name: n.STOP,
        samples: ["stop", "zatrzymaj"]
      },
      {
        name: n.NEXT,
        samples: ["nastpne", "dalej"]
      },
      {
        name: n.HELP,
        samples: ["pomoc", "pom mi", "potrzebuj pomocy"]
      },
      {
        name: n.PAUSE,
        samples: ["pauza", "zatrzymaj"]
      },
      {
        name: n.CANCEL,
        samples: ["anuluj"]
      },
      {
        name: n.RESUME,
        samples: ["wznw", "kontynuuj"]
      },
      {
        name: n.REPEAT,
        samples: ["powtrz", "ponw", "powiedz ponownie"]
      },
      {
        name: n.PREVIOUS,
        samples: ["poprzednie", "co byo wczeniej"]
      },
      {
        name: n.START_OVER,
        samples: ["zacznij od nowa", "zrestartuj"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // ro-RO
    [t.Language.RO]: [
      {
        name: n.NO,
        samples: ["nu", "niciun fel", "nici o ans", "negativ"]
      },
      {
        name: n.YES,
        samples: ["da", "bine", "ok", "bineneles", "sigur"]
      },
      {
        name: n.STOP,
        samples: ["oprete", "stop"]
      },
      {
        name: n.NEXT,
        samples: ["urmtorul", "urmtor"]
      },
      {
        name: n.HELP,
        samples: ["ajutor", "ajut-m", "am nevoie de ajutor"]
      },
      {
        name: n.PAUSE,
        samples: ["pauz", "oprete"]
      },
      {
        name: n.CANCEL,
        samples: ["anuleaz", "renun", "cancel"]
      },
      {
        name: n.RESUME,
        samples: ["continu", "reluare"]
      },
      {
        name: n.REPEAT,
        samples: ["repet", "iari", "spune din nou"]
      },
      {
        name: n.PREVIOUS,
        samples: ["anteriorul", "precedent"]
      },
      {
        name: n.START_OVER,
        samples: ["ncepe din nou", "restarteaz", "reia de la nceput"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // ru-RU
    [t.Language.RU]: [
      {
        name: n.NO,
        samples: ["", "", "", "", "", ""]
      },
      {
        name: n.YES,
        samples: ["", "", "", "", "", "", ""]
      },
      {
        name: n.STOP,
        samples: ["", ""]
      },
      {
        name: n.NEXT,
        samples: ["", "", " "]
      },
      {
        name: n.HELP,
        samples: ["", "", "  "]
      },
      {
        name: n.PAUSE,
        samples: ["", "  "]
      },
      {
        name: n.CANCEL,
        samples: ["", ""]
      },
      {
        name: n.RESUME,
        samples: ["", ""]
      },
      {
        name: n.REPEAT,
        samples: ["", " ", " "]
      },
      {
        name: n.PREVIOUS,
        samples: ["", " "]
      },
      {
        name: n.START_OVER,
        samples: [" ", ""]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // uk-UA
    [t.Language.UK]: [
      {
        name: n.NO,
        samples: ["", "", "", "", "   ", ""]
      },
      {
        name: n.YES,
        samples: ["", "", "", "", "", "", ""]
      },
      {
        name: n.STOP,
        samples: [""]
      },
      {
        name: n.NEXT,
        samples: [""]
      },
      {
        name: n.HELP,
        samples: ["", " ", "  "]
      },
      {
        name: n.PAUSE,
        samples: [""]
      },
      {
        name: n.CANCEL,
        samples: [""]
      },
      {
        name: n.RESUME,
        samples: [""]
      },
      {
        name: n.REPEAT,
        samples: ["", "", "  "]
      },
      {
        name: n.PREVIOUS,
        samples: [""]
      },
      {
        name: n.START_OVER,
        samples: ["  ", ""]
      },
      {
        name: n.NONE,
        samples: []
      }
    ],
    // vi-VN
    [t.Language.VI]: [
      {
        name: n.NO,
        samples: ["khng", "ko", "hng", "khng phi", "no way", "ph nh"]
      },
      {
        name: n.YES,
        samples: ["c", "", "c", "ng", "yup", "vng", "chc"]
      },
      {
        name: n.STOP,
        samples: ["dng", "stop"]
      },
      {
        name: n.NEXT,
        samples: ["tip theo", "next"]
      },
      {
        name: n.HELP,
        samples: ["gip ", "gip ti", "ti cn gip "]
      },
      {
        name: n.PAUSE,
        samples: ["tm dng", "pause"]
      },
      {
        name: n.CANCEL,
        samples: ["hy b", "cancel"]
      },
      {
        name: n.RESUME,
        samples: ["tip tc", "resume"]
      },
      {
        name: n.REPEAT,
        samples: ["lp li", "li", "ni li"]
      },
      {
        name: n.PREVIOUS,
        samples: ["trc ", "previous"]
      },
      {
        name: n.START_OVER,
        samples: ["bt u li", "khi u li"]
      },
      {
        name: n.NONE,
        samples: []
      }
    ]
  };
})(Kg);
var Ou = {};
Object.defineProperty(Ou, "__esModule", { value: !0 });
Ou.defaultMessages = void 0;
Ou.defaultMessages = {
  globalNoReply: "Are you still there?",
  globalNoMatch: "Sorry, I didnt get that. Please try again."
};
var pa = {};
Object.defineProperty(pa, "__esModule", { value: !0 });
pa.TTSPlatformType = pa.ProjectType = pa.PlatformType = void 0;
var c0;
(function(e) {
  e.ALEXA = "alexa", e.GOOGLE = "google", e.VOICEFLOW = "voiceflow", e.DIALOGFLOW_ES = "df-es", e.DIALOGFLOW_CX = "df-cx", e.RASA = "rasa", e.WATSON = "watson", e.LEX = "lex", e.EINSTEIN = "einstein", e.NUANCE_MIX = "nuance-mix", e.WEBCHAT = "webchat", e.MICROSOFT_TEAMS = "microsoft_teams", e.WHATSAPP = "whatsapp", e.SMS = "sms", e.LUIS = "luis", e.IVR = "ivr", e.CHATBOT = "chatbot", e.DIALOGFLOW_ES_CHAT = "dialogflow_es_chat", e.DIALOGFLOW_ES_VOICE = "dialogflow_es_voice", e.GENERAL = "general", e.MOBILE_APP = "mobile_app";
})(c0 || (pa.PlatformType = c0 = {}));
var f0;
(function(e) {
  e.CHAT = "chat", e.VOICE = "voice";
})(f0 || (pa.ProjectType = f0 = {}));
var d0;
(function(e) {
  e.ALEXA = "alexa", e.AZURE = "azure", e.GOOGLE = "google", e.ELEVENLABS = "elevenlabs";
})(d0 || (pa.TTSPlatformType = d0 = {}));
var ki = {};
Object.defineProperty(ki, "__esModule", { value: !0 });
ki.SlotTypes = ki.SlotType = void 0;
const cr = er;
var we;
(function(e) {
  e.CUSTOM = "VF.CUSTOM", e.AGE = "VF.AGE", e.CURRENCY = "VF.CURRENCY", e.DATETIME = "VF.DATETIME", e.DIMENSION = "VF.DIMENSION", e.EMAIL = "VF.EMAIL", e.GEOGRAPHY = "VF.GEOGRAPHY", e.KEY_PHRASE = "VF.KEY_PHRASE", e.NAME = "VF.NAME", e.NATOAPCO = "VF.NATOAPCO", e.NUMBER = "VF.NUMBER", e.ORDINAL = "VF.ORDINAL", e.PERCENTAGE = "VF.PERCENTAGE", e.PHONENUMBER = "VF.PHONENUMBER", e.TEMPERATURE = "VF.TEMPERATURE", e.URL = "VF.URL";
})(we || (ki.SlotType = we = {}));
const fr = {
  name: we.EMAIL,
  label: "Email",
  values: [
    "user@voiceflow.com",
    "professor@utoronto.edu",
    "person_name@gmail.com",
    "username123.signature@hotmail.com",
    "researcher@charity.org"
  ],
  regex: "^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$"
}, Sr = {
  name: we.PHONENUMBER,
  label: "Phone Number",
  values: [
    "1 (800) 642-7676",
    "123-456-7890",
    "647 126 3928",
    "360 392-1293",
    "906-459-2349",
    "2018073710",
    "4791945491"
  ]
}, xr = (e) => ({
  name: we.NUMBER,
  label: e,
  values: ["-43", "0", "35.5", "8", "520", "23599", "325", "15", "84730909029", "6947"]
}), jr = (e) => ({
  name: we.PERCENTAGE,
  label: e,
  values: ["3 1/2", "2%", "5 %"]
}), zr = (e) => ({
  name: we.ORDINAL,
  label: e,
  values: ["first", "second", "third", "next", "last", "previous"]
}), dr = (e) => ({
  name: we.URL,
  label: e,
  values: ["https://www.luis.ai", "www.google.ca", "voiceflow.com", "dev.voiceflow.com", "http://www.something.io"]
}), Or = (e) => ({
  name: we.KEY_PHRASE,
  label: e,
  values: ["educational requirements", "development", "food", "wonderful staff", "extravagant"]
});
ki.SlotTypes = {
  [cr.Language.EN]: [
    {
      name: we.NAME,
      label: "Name",
      values: [
        "john",
        "james",
        "robert",
        "michael",
        "william",
        "david",
        "tyler",
        "roy",
        "andrew",
        "richard",
        "thomas",
        "daniel",
        "anthony",
        "mary",
        "jennifer",
        "emily",
        "susan",
        "valerie",
        "amanda",
        "sam"
      ]
    },
    {
      name: we.GEOGRAPHY,
      label: "Geography",
      values: ["the sphinx", "gizah", "egypt", "africa", "texas"]
    },
    fr,
    Sr,
    xr("Number"),
    jr("Percentage"),
    zr("Ordinal"),
    dr("URL"),
    Or("Key Phrase"),
    {
      name: we.NATOAPCO,
      label: "NATO/APCO",
      values: [],
      list: [
        { canonicalForm: "Alfa", list: ["Adam", "Alpha"] },
        { canonicalForm: "Bravo", list: ["Boy", "Baker"] },
        { canonicalForm: "Charlie", list: ["Charles"] },
        { canonicalForm: "Delta", list: ["David"] },
        { canonicalForm: "Echo", list: ["Edward", "Easy"] },
        { canonicalForm: "Foxtrot", list: ["Frank"] },
        { canonicalForm: "Golf", list: ["George"] },
        { canonicalForm: "Hotel", list: ["Henry"] },
        { canonicalForm: "India", list: ["Ida"] },
        { canonicalForm: "Juliett", list: ["John"] },
        { canonicalForm: "Kilo", list: ["King"] },
        { canonicalForm: "Lima", list: ["Lincoln"] },
        { canonicalForm: "Mike", list: ["Mary"] },
        { canonicalForm: "November", list: ["Nora"] },
        { canonicalForm: "Oscar", list: ["Ocean"] },
        { canonicalForm: "Papa", list: ["Paul"] },
        { canonicalForm: "Quebec", list: ["Queen"] },
        { canonicalForm: "Romeo", list: ["Robert"] },
        { canonicalForm: "Sierra", list: ["Sam"] },
        { canonicalForm: "Tango", list: ["Tom"] },
        { canonicalForm: "Uniform", list: ["Union"] },
        { canonicalForm: "Victor", list: [] },
        { canonicalForm: "Whiskey", list: ["William"] },
        { canonicalForm: "X-ray", list: ["Xray"] },
        { canonicalForm: "Yankee", list: ["Young", "Yellow"] },
        { canonicalForm: "Zulu", list: ["Zebra"] },
        { canonicalForm: "0", list: ["Zero", "Nadazero"] },
        { canonicalForm: "1", list: ["One", "Wun", "Unaone"] },
        { canonicalForm: "2", list: ["Two", "Too", "Bissotwo"] },
        { canonicalForm: "3", list: ["Three", "Tree", "Terrathree"] },
        { canonicalForm: "4", list: ["Four", "Fower", "Kartefour"] },
        { canonicalForm: "5", list: ["Five", "Fife", "Pantafive"] },
        { canonicalForm: "6", list: ["Six", "Soxisix"] },
        { canonicalForm: "7", list: ["Seven", "Setteseven"] },
        { canonicalForm: "8", list: ["Eight", "Oktoeight"] },
        { canonicalForm: "9", list: ["Nine", "Niner", "Novenine"] },
        { canonicalForm: "00", list: ["Hundred"] },
        { canonicalForm: "000", list: ["Thousand"] },
        { canonicalForm: "-", list: ["Dash", "Hyphen"] },
        { canonicalForm: ".", list: ["Decimal", "Point", "Stop"] }
      ]
    },
    {
      name: we.AGE,
      label: "Age",
      values: ["20 days old", "nineteen years old", "4 weeks old", "8 months old", "45 years-old", "one month old"]
    },
    {
      name: we.CURRENCY,
      label: "Currency",
      values: [
        "5 dollars",
        "1 dollar",
        "one dollar",
        "$8",
        "6 canadian dollars",
        "seven pennies",
        "9 pounds",
        "15 pesos",
        "Four para",
        "87 ruples",
        "thirty rupees",
        "12.34",
        "34.2$"
      ]
    },
    {
      name: we.DATETIME,
      label: "Datetime",
      values: [
        "May 2nd",
        "May 25th, 2025",
        "Tuesday to Thursday",
        "From 6pm to 7pm",
        "6:30 pm to 7 pm",
        "8am",
        "8:30 pm",
        "9 am",
        "10:12 am"
      ]
    },
    {
      name: we.DIMENSION,
      label: "Dimension",
      values: ["10 1/2 miles", "10.5 kilometers", "0.3 mm", "5 feet", "6 yards", "10m", "25 m/s"]
    },
    {
      name: we.TEMPERATURE,
      label: "Temperature",
      values: ["30 degrees", "215 kelvin", "56 f", "33f", "22 degrees celsius", "102 degs farenheit"]
    }
  ],
  [cr.Language.DE]: [
    fr,
    Sr,
    {
      name: we.AGE,
      label: "Alter",
      values: ["7 Jahre alt", "acht Mondate alt", "3 wochen alt", "neun Tage alt", "einen tag alt", "1 Jahr alt"]
    },
    xr("Nummer"),
    jr("Prozentsatz"),
    zr("Ordinalzahl"),
    dr("URL"),
    Or("Schlsselsatz"),
    {
      name: we.CURRENCY,
      label: "Whrung",
      values: ["7 $", "23 Dollar", "dreiig USD", "87 yuan", "11 pfund", "55", "5.99", "neunzehn Pesos"]
    },
    {
      name: we.DATETIME,
      label: "Datum (und Uhrzeit",
      values: ["2. Mai", "25. Mai 2025", "Dienstag bis Donnerstag", "Von 18 bis 19 Uhr", "8 Uhr morgens", "20:30 Uhr"]
    },
    {
      name: we.DIMENSION,
      label: "Dimension",
      values: ["10 1/2 Meilen", "10,5 Kilometer", "0,3 mm", "5 Fu", "6 Yards", "6m", "25 m/s"]
    },
    {
      name: we.TEMPERATURE,
      label: "Temperatur",
      values: ["30 Grad", "215 Kelvin", "56 f", "33f", "22 Grad Celsius", "102 Grad Fahrenheit"]
    }
  ],
  [cr.Language.FR]: [
    fr,
    Sr,
    {
      name: we.AGE,
      label: "ge",
      values: [
        "3 ans",
        "Trois ans",
        "2 mois d'ge",
        "six mois d'age",
        "8 mois",
        "huit mois",
        "une semaine",
        "1 semaine",
        "3 semaines",
        "sept semaines d'ge",
        "9 semaines d'age",
        "18 jours",
        "quarante jours",
        "un jour"
      ]
    },
    xr("Nombre"),
    jr("Pourcentage"),
    zr("Nombre ordinal"),
    dr("URL"),
    Or("Phrase cl"),
    {
      name: we.CURRENCY,
      label: "Monnaie",
      values: [
        "un dollar",
        "3 dollars",
        "5$",
        "12.09",
        "33 pence",
        "Sept sou",
        "6 livres",
        "douze pesos",
        "trois francs",
        "7 dollars canadien"
      ]
    },
    {
      name: we.DATETIME,
      label: "Date et l'Heure",
      values: ["2 mai", "2 mai 2025", "du mardi au jeudi", "De 18h  19h", "8h00", "20h30"]
    },
    {
      name: we.DIMENSION,
      label: "Dimension",
      values: ["10 1/2 miles", "10,5 kilomtres", "0,3 mm", "5 pieds", "6 yards", "6m", "25 m/s"]
    },
    {
      name: we.TEMPERATURE,
      label: "Temprature",
      values: ["30 degrs", "215 kelvin", "56 f", "33f", "22 degrs Celsius", "102 degs farenheit"]
    }
  ],
  [cr.Language.PT]: [
    fr,
    Sr,
    {
      name: we.AGE,
      label: "Idade",
      values: [
        "3 anos",
        "3 anos de idade",
        "1 ano",
        "uma ano",
        "6 meses",
        "1 mes",
        "um ms",
        "7 semanas",
        "uma semana",
        "1 semana",
        "quatro dias",
        "15 dias",
        "1 dia"
      ]
    },
    xr("Nmero"),
    jr("Porcentagem"),
    zr("Nmero ordinal"),
    dr("URL"),
    Or("Frase chave"),
    {
      name: we.CURRENCY,
      label: "Monnaie",
      values: ["1 dlar", "quatro pesos", "6.01", "5", "11.02 francos"]
    },
    {
      name: we.DATETIME,
      label: "Data e Hora",
      values: ["2 de maio", "2 de maio de 2015", "Tera a quinta", "Das 18h s 19h", "8 horas da manh", "20:30"]
    },
    {
      name: we.DIMENSION,
      label: "Dimenso",
      values: ["10 1/2 milhas ", "10,5 quilmetros", "0,3 mm", "5 ps", "6 jardas", "6m", "25 m/s"]
    },
    {
      name: we.TEMPERATURE,
      label: "Temperatura",
      values: ["30 graus", " 215 Kelvin", "56 f", "33  f", "22 graus Celsius", "102 degs farenheit"]
    }
  ],
  [cr.Language.ES]: [
    fr,
    Sr,
    {
      name: we.AGE,
      label: "Edad",
      values: [
        "3 aos",
        "1 ao",
        "un ao",
        "6 meses",
        "6 meses de edad",
        "1 mes",
        "um ms",
        "7 semanas",
        "un semana",
        "1 semana",
        "quatro dias",
        "15 das",
        "1 dia de edad",
        "un da"
      ]
    },
    xr("Nmero"),
    jr("Porcentaje"),
    zr("Nmero ordinal"),
    dr("URL"),
    Or("Frase clave"),
    {
      name: we.CURRENCY,
      label: "Moneda",
      values: [
        "5 dlares",
        "1 peso",
        "3.2 libras",
        "Tres rublos",
        "1 peso dominicano",
        "4.5 dlares canadienses",
        "3.5",
        "9",
        "tres euros"
      ]
    },
    {
      name: we.DATETIME,
      label: "Fecha y Hora",
      values: ["2 de Mayo", "2 de mayo de 2015", "Martes a jueves", "De 18h a 19h", "8:00AM", "8:30 PM"]
    },
    {
      name: we.DIMENSION,
      label: "Dimensin",
      values: ["10 1/2 millas", "10.5 kilmetros", "0,3 mm", "5 pies", "6 yardas", "10 m", "25 m/s"]
    },
    {
      name: we.TEMPERATURE,
      label: "Temperatura",
      values: ["30 grados", "215 kelvin", "56 f", "33f", "22 grados celsius", "102 grados farenheit"]
    }
  ],
  [cr.Language.ZH]: [
    fr,
    Sr,
    {
      name: we.AGE,
      label: "",
      values: ["", "3", "5", "7", "9", "8", "21", "1"]
    },
    xr(""),
    jr(""),
    zr(""),
    dr(""),
    {
      name: we.CURRENCY,
      label: "",
      values: ["5 ", "1", "9", "", "8 ", "8", "12 "]
    },
    {
      name: we.DATETIME,
      label: "",
      values: ["May 2nd", "2015  5  2 ", "", " 6  7 ", "", " 8:30"]
    },
    {
      name: we.DIMENSION,
      label: "",
      values: ["10 1/2 ", "10.5 ", "0.3 ", "5 ", "6 ", "7"]
    },
    {
      name: we.TEMPERATURE,
      label: "",
      values: ["30 ", "215 ", "56 f", "33f", "22 ", " 102 ", "34.1"]
    }
  ],
  [cr.Language.JA]: [
    fr,
    Sr,
    {
      name: we.AGE,
      label: "",
      values: ["1", "", "2", "4", "3", "6", "5", "9", "10"]
    },
    xr(""),
    jr(""),
    zr(""),
    dr("URL"),
    Or(""),
    {
      name: we.CURRENCY,
      label: "",
      values: ["88", "123", "7", "87", "5", "44"]
    },
    {
      name: we.DIMENSION,
      label: "",
      values: ["101/2", "10.5", "0.3 mm", "5", "6"]
    },
    {
      name: we.TEMPERATURE,
      label: "",
      values: ["30", "215", "56 f", "33f", "22", "102"]
    }
  ],
  [cr.Language.NL]: [
    fr,
    Sr,
    {
      name: we.AGE,
      label: "Leeftijd",
      values: [
        "twintig jaar oud",
        "19 dagen old",
        "negentien dagen oud",
        "4 week oud",
        "8 maand oud",
        "1 jaar oud",
        "3 jaar",
        "4 levensjaren",
        "30 jarige leeftijd",
        "45-jarige leeftijd",
        "2-jarige",
        "5 jarige",
        "6 maand oud",
        "twee maanden",
        "vier weken oud",
        "5 week",
        "zeven weken",
        "6 dag oud",
        "7 dag",
        "negen dagen"
      ]
    },
    xr("Aantal"),
    jr("Percentage"),
    zr("Rangtelwoord"),
    dr("URL"),
    Or("Sleutelwoord"),
    {
      name: we.CURRENCY,
      label: "Valuta",
      values: [
        "8 euro",
        "negen cent",
        "4 japanse yen",
        "vier pesos",
        "11 centen",
        "33 pence",
        "5 dollar",
        "0.12 bitcoin",
        "drientwintig pond"
      ]
    },
    {
      name: we.DIMENSION,
      label: "Afmeting",
      values: ["10 1/2 mijl", "10,5 kilometer", "0,3 mm", "5 voet", "6 yards", "7m", "25 m/s"]
    },
    {
      name: we.TEMPERATURE,
      label: "Temperatuur",
      values: ["30 graden", "215 kelvin", "56 f", "33f", "22 graden Celsius", "102 graden farenheit"]
    }
  ],
  [cr.Language.IT]: [
    fr,
    Sr,
    {
      name: we.AGE,
      label: "Et",
      values: [
        "8 anni di et",
        "sette anni",
        "un anno di et",
        "11 anni d'et",
        "1 anno d'et",
        "di nove anni d'et",
        "4 anni",
        "1 anno",
        "8 mesi di et",
        "sette mesi",
        "un mese di et",
        "11 mesi d'et",
        "1 mese d'et",
        "di nove mesi d'et",
        "1 mese",
        "8 settimane di et",
        "sette settimane",
        "un settimana di et",
        "11 settimane d'et",
        "1 settimana d'et",
        "di nove settimane d'et",
        "1 settimana",
        "8 giorni di et",
        "sette giorni",
        "un giorno di et",
        "11 giorni d'et",
        "1 giorno d'et",
        "di nove giorni d'et",
        "1 giorno"
      ]
    },
    xr("Numero"),
    jr("Percentuale"),
    zr("Numero ordinale"),
    dr("URL"),
    Or("Frase chiave"),
    {
      name: we.CURRENCY,
      label: "Valuta",
      values: [
        "5 dollari",
        "9.10 dollari canadesi",
        "6 sterline",
        "$4.1",
        "quattro pence",
        "24 pesos",
        "84 ",
        "99.12"
      ]
    },
    {
      name: we.DIMENSION,
      label: "Dimensione",
      values: ["10 1/2 miglia", "10,5 chilometri", "0,3 mm", "5 piedi", "6 iarde", "8m", "25 m/s"]
    },
    {
      name: we.TEMPERATURE,
      label: "Temperatura",
      values: ["30 gradi", "215 kelvin", "56 f", "33f", "22 gradi Celsius", "102 gradi fanheit"]
    }
  ],
  [cr.Language.KO]: [fr, Sr, dr("URL"), Or(" ")],
  // Mexico Spanish has much less built in entities than Spain Spanish.
  // There is a case in getSlotTypes in realtime-sdk for this
  [cr.Locale.ES_MX]: [fr, xr("Nmero"), dr("URL"), Or("Frase clave")]
};
var wu = {};
Object.defineProperty(wu, "__esModule", { value: !0 });
wu.BuiltInVariable = void 0;
var h0;
(function(e) {
  e.LOCALE = "locale", e.CHANNEL = "channel", e.USER_ID = "user_id", e.SESSIONS = "sessions", e.PLATFORM = "platform", e.TIMESTAMP = "timestamp", e.INTENT_CONFIDENCE = "intent_confidence", e.LAST_UTTERANCE = "last_utterance", e.LAST_RESPONSE = "last_response", e.LAST_EVENT = "last_event", e.VF_MEMORY = "vf_memory", e.VF_CHUNKS = "vf_chunks";
})(h0 || (wu.BuiltInVariable = h0 = {}));
(function(e) {
  var t = bt && bt.__createBinding || (Object.create ? function(r, a, i, s) {
    s === void 0 && (s = i);
    var o = Object.getOwnPropertyDescriptor(a, i);
    (!o || ("get" in o ? !a.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
      return a[i];
    } }), Object.defineProperty(r, s, o);
  } : function(r, a, i, s) {
    s === void 0 && (s = i), r[s] = a[i];
  }), n = bt && bt.__exportStar || function(r, a) {
    for (var i in r)
      i !== "default" && !Object.prototype.hasOwnProperty.call(a, i) && t(a, r, i);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(Su, e), n(er, e), n(xu, e), n(Kg, e), n(Ou, e), n(pa, e), n(ki, e), n(wu, e);
})(Xg);
Object.defineProperty(Cu, "__esModule", { value: !0 });
Cu.defaultBaseSettings = void 0;
const CN = Xg, SN = ({ locales: e = [CN.Locale.EN_US] } = {}) => ({
  locales: e
});
Cu.defaultBaseSettings = SN;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultChatSettings = e.defaultSharedChatSettings = void 0;
  const t = qg, n = Cu, r = (i = {}) => ({
    ...t.ChatVersion.defaultSettings(i)
  });
  e.defaultSharedChatSettings = r;
  const a = (i = {}) => ({
    ...(0, e.defaultSharedChatSettings)(i),
    ...(0, n.defaultBaseSettings)(i)
  });
  e.defaultChatSettings = a;
})(bc);
var Li = {};
Object.defineProperty(Li, "__esModule", { value: !0 });
Li.ChatPosition = Li.ChatPersistence = void 0;
var m0;
(function(e) {
  e.MEMORY = "memory", e.LOCAL_STORAGE = "localStorage", e.SESSION_STORAGE = "sessionStorage";
})(m0 || (Li.ChatPersistence = m0 = {}));
var p0;
(function(e) {
  e.LEFT = "left", e.RIGHT = "right";
})(p0 || (Li.ChatPosition = p0 = {}));
(function(e) {
  var t = bt && bt.__createBinding || (Object.create ? function(o, u, V, c) {
    c === void 0 && (c = V);
    var f = Object.getOwnPropertyDescriptor(u, V);
    (!f || ("get" in f ? !u.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return u[V];
    } }), Object.defineProperty(o, c, f);
  } : function(o, u, V, c) {
    c === void 0 && (c = V), o[c] = u[V];
  }), n = bt && bt.__exportStar || function(o, u) {
    for (var V in o)
      V !== "default" && !Object.prototype.hasOwnProperty.call(u, V) && t(u, o, V);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultChatPlatformData = e.defaultSharedChatPlatformData = void 0;
  const r = qg, a = bc;
  n(Li, e), n(bc, e);
  const i = ({ settings: o, ...u }) => ({
    ...r.ChatVersion.defaultPlatformData(u),
    settings: (0, a.defaultSharedChatSettings)(o)
  });
  e.defaultSharedChatPlatformData = i;
  const s = ({ settings: o, ...u }) => ({
    ...(0, e.defaultSharedChatPlatformData)(u),
    settings: (0, a.defaultChatSettings)(o)
  });
  e.defaultChatPlatformData = s;
})(jn);
var pr = /* @__PURE__ */ ((e) => (e.IDLE = "IDLE", e.ACTIVE = "ACTIVE", e.ENDED = "ENDED", e))(pr || {}), ja = /* @__PURE__ */ ((e) => (e.USER = "user", e.SYSTEM = "system", e))(ja || {});
const xN = /^about:[\w#%+.:=@~-]{2,256}\b([\w#%&+./:=?@~-]*)$/, ON = /^bitcoin:[\dA-Za-z]{26,35}([\w#%&+./:=?@~-]*)$/, wN = /^callto:[+\d-\s()]+$/, IN = /^tel:[+\d-\s()]+$/, RN = /^sms:[+\d-\s()]+$/, NN = /^mailto:([^\s?]+)\b([\w#%&+./:=?@~-]*)$/, kN = /^im:([^\s?]+)\b([\w#%&+./:=?@~-]*)$/, LN = /^facetime(-(audio|group))?:([^\s?]+|([+\d-()]+))$/, PN = /^skype:(\S+)\b$/, DN = /^webcal:(\S+)\b$/, MN = [
  xN,
  ON,
  wN,
  IN,
  RN,
  NN,
  kN,
  LN,
  PN,
  DN
], FN = (e) => !!MN.some((t) => e.match(t)), BN = (e) => e.startsWith("//") || e.includes("://") || FN(e) ? e : `//${e}`, $N = (e, t = "noopener=true,noreferrer=true") => {
  var n;
  return (n = window.open(BN(e), "_blank", t)) == null ? void 0 : n.focus();
}, UN = (e) => !!e.payload && typeof e.payload == "object" && Array.isArray(e.payload.actions), HN = (e) => {
  var t, n;
  UN(e) && ((n = (t = e.payload) == null ? void 0 : t.actions) == null || n.forEach((r) => {
    Tg(r) && r.payload.url && $N(r.payload.url);
  }));
};
var As = /* @__PURE__ */ ((e) => (e.SAVE_SESSION = "voiceflow:save_session", e.INTERACT = "voiceflow:interact", e.OPEN = "voiceflow:open", e.CLOSE = "voiceflow:close", e))(As || {});
const wo = (e) => {
  const t = JSON.stringify(e);
  window.postMessage(t);
}, jN = "voiceflow-session", tu = (e) => `${jN}-${e}`, zN = (e, t) => {
  try {
    return JSON.parse(e.getItem(tu(t)));
  } catch {
    return null;
  }
}, Ec = (e, t, n) => (e.setItem(tu(t), JSON.stringify(n)), n), g0 = (e, t, n) => {
  const r = zN(e, t);
  return !r || n && r.userID !== n ? Ec(e, t, { userID: n || Hs() }) : r;
}, GN = (e, t, n) => {
  switch (e) {
    case jn.ChatPersistence.MEMORY:
      return { userID: n || Hs() };
    case jn.ChatPersistence.LOCAL_STORAGE:
      return g0(localStorage, t, n);
    case jn.ChatPersistence.SESSION_STORAGE:
    default:
      return g0(sessionStorage, t, n);
  }
}, b0 = (e, t, n) => {
  wo({ type: As.SAVE_SESSION, payload: n }), e === jn.ChatPersistence.LOCAL_STORAGE ? Ec(localStorage, t, n) : e === jn.ChatPersistence.SESSION_STORAGE && Ec(sessionStorage, t, n), e !== jn.ChatPersistence.LOCAL_STORAGE && localStorage.removeItem(tu(t)), e !== jn.ChatPersistence.SESSION_STORAGE && sessionStorage.removeItem(tu(t));
};
class YN {
  constructor() {
    this.audio = new Audio(), this.reject = null;
  }
  pause() {
    this.audio.pause();
  }
  continue() {
    this.audio.play();
  }
  async play(t) {
    return this.stop(), t ? new Promise((n, r) => {
      this.reject = r, this.audio.onended = () => n(), this.audio.onerror = () => r(), this.audio.src = t, this.audio.currentTime = 0, this.audio.play();
    }) : Promise.resolve();
  }
  stop() {
    var t;
    (t = this.reject) == null || t.call(this), this.audio.pause(), this.audio.onended = null, this.audio.onerror = null, this.audio.currentTime = 0;
  }
}
const WN = (e) => {
  for (let t = e.length - 1; t >= 0; t--) {
    const n = e[t];
    if (n.type === ja.SYSTEM)
      return n;
  }
  return null;
}, qN = (e, t) => e.trim().toLowerCase() === t.trim().toLowerCase(), XN = (e, t) => {
  var n, r;
  if (lg(e)) {
    const a = WN(t), i = (r = (n = a == null ? void 0 : a.actions) == null ? void 0 : n.find((s) => qN(s.name, e.payload))) == null ? void 0 : r.request;
    if (i)
      return i;
  }
  return e;
}, KN = "data:audio/mpeg;base64,SUQzBAAAAAACPFRYWFgAAAAXAAADVFNTAEdhcmFnZUJhbmQgMTAuMy4zAFRYWFgAAABlAAADaVR1bk5PUk0AIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwAFRYWFgAAAB/AAADaVR1blNNUEIAIDAwMDAwMDAwIDAwMDAwMjEwIDAwMDAwODU4IDAwMDAwMDAwMDAwNDA5OTggMDAwMDAwMDAgMDAwMEI2REMgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAAVFNTRQAAAA8AAANMYXZmNTguMjkuMTAwAAAAAAAAAAAAAAD/+5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJbmZvAAAADwAAACgAAELvAAwMEhIYGBgfHyUlJSsrMTExODg+Pj5EREpKSlFRV1dXXV1jY2NqanBwcHZ2fHx8g4OJiYmPj5WVlZycoqKiqKiurq61tbu7u8HBx8fHzs7U1NTa2uDg4Ofn7e3t8/P5+fn//wAAAABMYXZjNTguNTQAAAAAAAAAAAAAAAAkBXwAAAAAAABC78H9CuUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+5BkAA/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5BkQQ/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==";
var mf = /* @__PURE__ */ ((e) => (e.EFFECT = "effect", e.RESPONSE = "response", e))(mf || {});
const Zg = (e) => F.object({
  name: F.string(),
  type: F.literal(e),
  match: F.function().transform((t) => t)
}), ZN = Zg(
  "effect"
  /* EFFECT */
).extend({
  effect: F.function().transform((e) => e).optional()
}), QN = Zg(
  "response"
  /* RESPONSE */
).extend({
  render: F.function().transform((e) => e).optional()
}), JN = F.discriminatedUnion("type", [ZN, QN]), e4 = (e) => e.filter((t) => t.type === mf.EFFECT).map((t) => ({
  canHandle: (n) => t.match({ trace: n }),
  handle: ({ context: n }, r) => ((async () => {
    var a;
    try {
      await ((a = t.effect) == null ? void 0 : a.call(t, { trace: r }));
    } catch (i) {
      console.error(`Extension '${t.name}' threw an error: ${i}`);
    }
  })(), n)
})), t4 = (e) => {
  var t;
  return !!((t = e == null ? void 0 : e.verify) != null && t.authorization);
}, n4 = (e) => {
  var t;
  return typeof ((t = e == null ? void 0 : e.verify) == null ? void 0 : t.projectID) == "string";
}, r4 = (e) => {
  var t, n, r;
  return ((t = e == null ? void 0 : e.verify) == null ? void 0 : t.prototype) === !0 && typeof ((n = e == null ? void 0 : e.verify) == null ? void 0 : n.versionID) == "string" && typeof ((r = e == null ? void 0 : e.verify) == null ? void 0 : r.projectID) == "string";
}, a4 = Tr;
var Qg = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var i4 = s4;
function s4(e) {
  if (!e)
    throw new TypeError("argument namespace is required");
  function t(n) {
  }
  return t._file = void 0, t._ignored = !0, t._namespace = e, t._traced = !1, t._warned = /* @__PURE__ */ Object.create(null), t.function = o4, t.property = u4, t;
}
function o4(e, t) {
  if (typeof e != "function")
    throw new TypeError("argument fn must be a function");
  return e;
}
function u4(e, t, n) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new TypeError("argument obj must be object");
  var r = Object.getOwnPropertyDescriptor(e, t);
  if (!r)
    throw new TypeError("must call property on owner object");
  if (!r.configurable)
    throw new TypeError("property must be configurable");
}
var V4 = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? l4 : c4);
function l4(e, t) {
  return e.__proto__ = t, e;
}
function c4(e, t) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(e, n) || (e[n] = t[n]);
  return e;
}
const f4 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a Teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Too Early",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var pf = f4, d4 = yr;
yr.message = pf;
yr.code = h4(pf);
yr.codes = m4(pf);
yr.redirect = {
  300: !0,
  301: !0,
  302: !0,
  303: !0,
  305: !0,
  307: !0,
  308: !0
};
yr.empty = {
  204: !0,
  205: !0,
  304: !0
};
yr.retry = {
  502: !0,
  503: !0,
  504: !0
};
function h4(e) {
  var t = {};
  return Object.keys(e).forEach(function(r) {
    var a = e[r], i = Number(r);
    t[a.toLowerCase()] = i;
  }), t;
}
function m4(e) {
  return Object.keys(e).map(function(n) {
    return Number(n);
  });
}
function p4(e) {
  var t = e.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(yr.code, t))
    throw new Error('invalid status message: "' + e + '"');
  return yr.code[t];
}
function A0(e) {
  if (!Object.prototype.hasOwnProperty.call(yr.message, e))
    throw new Error("invalid status code: " + e);
  return yr.message[e];
}
function yr(e) {
  if (typeof e == "number")
    return A0(e);
  if (typeof e != "string")
    throw new TypeError("code must be a number or string");
  var t = parseInt(e, 10);
  return isNaN(t) ? p4(e) : A0(t);
}
var vc = { exports: {} };
typeof Object.create == "function" ? vc.exports = function(t, n) {
  n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : vc.exports = function(t, n) {
  if (n) {
    t.super_ = n;
    var r = function() {
    };
    r.prototype = n.prototype, t.prototype = new r(), t.prototype.constructor = t;
  }
};
var g4 = vc.exports;
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var b4 = A4;
function A4(e) {
  return e.split(" ").map(function(t) {
    return t.slice(0, 1).toUpperCase() + t.slice(1);
  }).join("").replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(e) {
  i4("http-errors");
  var t = V4, n = d4, r = g4, a = b4;
  e.exports = s, e.exports.HttpError = o(), e.exports.isHttpError = V(e.exports.HttpError), p(e.exports, n.codes, e.exports.HttpError);
  function i(g) {
    return +(String(g).charAt(0) + "00");
  }
  function s() {
    for (var g, b, v = 500, x = {}, E = 0; E < arguments.length; E++) {
      var S = arguments[E], $ = typeof S;
      if ($ === "object" && S instanceof Error)
        g = S, v = g.status || g.statusCode || v;
      else if ($ === "number" && E === 0)
        v = S;
      else if ($ === "string")
        b = S;
      else if ($ === "object")
        x = S;
      else
        throw new TypeError("argument #" + (E + 1) + " unsupported type " + $);
    }
    (typeof v != "number" || !n.message[v] && (v < 400 || v >= 600)) && (v = 500);
    var U = s[v] || s[i(v)];
    g || (g = U ? new U(b) : new Error(b || n.message[v]), Error.captureStackTrace(g, s)), (!U || !(g instanceof U) || g.status !== v) && (g.expose = v < 500, g.status = g.statusCode = v);
    for (var y in x)
      y !== "status" && y !== "statusCode" && (g[y] = x[y]);
    return g;
  }
  function o() {
    function g() {
      throw new TypeError("cannot construct abstract class");
    }
    return r(g, Error), g;
  }
  function u(g, b, v) {
    var x = h(b);
    function E(S) {
      var $ = S ?? n.message[v], U = new Error($);
      return Error.captureStackTrace(U, E), t(U, E.prototype), Object.defineProperty(U, "message", {
        enumerable: !0,
        configurable: !0,
        value: $,
        writable: !0
      }), Object.defineProperty(U, "name", {
        enumerable: !1,
        configurable: !0,
        value: x,
        writable: !0
      }), U;
    }
    return r(E, g), f(E, x), E.prototype.status = v, E.prototype.statusCode = v, E.prototype.expose = !0, E;
  }
  function V(g) {
    return function(v) {
      return !v || typeof v != "object" ? !1 : v instanceof g ? !0 : v instanceof Error && typeof v.expose == "boolean" && typeof v.statusCode == "number" && v.status === v.statusCode;
    };
  }
  function c(g, b, v) {
    var x = h(b);
    function E(S) {
      var $ = S ?? n.message[v], U = new Error($);
      return Error.captureStackTrace(U, E), t(U, E.prototype), Object.defineProperty(U, "message", {
        enumerable: !0,
        configurable: !0,
        value: $,
        writable: !0
      }), Object.defineProperty(U, "name", {
        enumerable: !1,
        configurable: !0,
        value: x,
        writable: !0
      }), U;
    }
    return r(E, g), f(E, x), E.prototype.status = v, E.prototype.statusCode = v, E.prototype.expose = !1, E;
  }
  function f(g, b) {
    var v = Object.getOwnPropertyDescriptor(g, "name");
    v && v.configurable && (v.value = b, Object.defineProperty(g, "name", v));
  }
  function p(g, b, v) {
    b.forEach(function(E) {
      var S, $ = a(n.message[E]);
      switch (i(E)) {
        case 400:
          S = u(v, $, E);
          break;
        case 500:
          S = c(v, $, E);
          break;
      }
      S && (g[E] = S, g[$] = S);
    });
  }
  function h(g) {
    return g.substr(-5) !== "Error" ? g + "Error" : g;
  }
})(Qg);
var E4 = Qg.exports;
const v4 = /* @__PURE__ */ pn(E4);
class gf {
  constructor(t) {
    var n;
    if (this.options = t, this.fetch = t.fetchPonyfill ?? ((n = globalThis.fetch) == null ? void 0 : n.bind(globalThis)), !this.fetch)
      throw new TypeError("fetch implementation was not provided and a global fetch was not available");
  }
  async send(t, n = {}) {
    const r = new URL(t, this.options.url);
    n.params && (r.search = n.params.toString());
    const a = await this.fetch(r, {
      method: n.method ?? "GET",
      body: n.body ? JSON.stringify(n.body) : void 0,
      headers: {
        "content-type": "application/json",
        ...n.headers ?? {}
      }
    }), i = await a.json().catch(() => null);
    if (!a.ok)
      throw v4(a.status, a.statusText, i);
    return i;
  }
}
class T4 extends gf {
  constructor(t) {
    super(t), this.authorization = t.verify.authorization;
  }
  async interact(t) {
    const { action: n, config: r, sessionID: a, versionID: i } = t;
    return this.send(`state/user/${encodeURIComponent(a)}/interact`, {
      method: "POST",
      body: { action: n, config: r },
      headers: {
        authorization: this.authorization,
        sessionID: a,
        ...i ? { versionID: i } : {}
      },
      params: new URLSearchParams({ verbose: "true" })
    });
  }
  async feedback() {
    return Promise.reject(new Error("not implemented"));
  }
  // TODO: expose authenticated publishing
  getPublishing() {
    return Promise.reject(new Error("not implemented"));
  }
  // TODO: expose authenticated createTranscript
  createTranscript() {
    return Promise.reject(new Error("not implemented"));
  }
}
class y4 extends gf {
  constructor(t) {
    super(t), this.state = {
      turn: {},
      storage: {},
      variables: {}
    }, this.versionID = t.verify.versionID;
  }
  async interact(t) {
    const { action: n, config: r, sessionID: a } = t, i = await this.send(`interact/${this.versionID}`, {
      body: { state: this.state, request: n, config: r },
      method: "POST",
      headers: { sessionID: a, platform: "chat-prototype" }
    });
    return this.state = i.state, i;
  }
  async feedback() {
    return Promise.reject(new Error("not implemented"));
  }
  // TODO: expose authenticated publishing
  getPublishing() {
    return Promise.reject(new Error("not implemented"));
  }
  // TODO: expose authenticated createTranscript
  createTranscript() {
    return Promise.reject(new Error("not implemented"));
  }
}
class _4 extends gf {
  constructor(t) {
    super(t), this.projectID = t.verify.projectID;
  }
  async interact(t) {
    const { action: n, config: r, sessionID: a, versionID: i } = t;
    return this.send(`public/${this.projectID}/state/user/${encodeURIComponent(a)}/interact`, {
      method: "POST",
      body: { action: n, config: r },
      headers: {
        ...i && { versionID: i }
      }
    });
  }
  async feedback(t) {
    const { versionID: n, sessionID: r, ...a } = t;
    await this.send(`feedback/${this.projectID}/user/${encodeURIComponent(r)}`, {
      method: "POST",
      body: a,
      headers: {
        ...n && { versionID: n }
      }
    });
  }
  async getPublishing(t) {
    const { versionID: n } = t;
    return this.send(`public/${this.projectID}/publishing`, {
      method: "GET",
      headers: {
        ...n ? { versionID: n } : {}
      }
    });
  }
  async createTranscript(t, n) {
    return this.send(`public/${this.projectID}/transcripts`, {
      method: "POST",
      body: { ...n, sessionID: t }
    });
  }
}
class C4 {
  constructor(t = {}) {
    this.traces = [], this.registerTraces(t.traces ?? []);
  }
  registerTrace(t) {
    return this.traces.push(t), this;
  }
  registerTraces(t) {
    return t.forEach((n) => this.registerTrace(n)), this;
  }
  async processTrace(t, n) {
    const r = { context: t };
    for (const a of n.trace) {
      const i = this.traces.find((s) => s.canHandle(a));
      i && (r.context = await i.handle(r, a));
    }
    return r.context;
  }
}
class S4 {
  constructor(t) {
    if (this.trace = new C4(t), r4(t))
      this.runtime = new y4(t);
    else if (t4(t))
      this.runtime = new T4(t);
    else if (n4(t))
      this.runtime = new _4(t);
    else
      throw new Error("invalid runtime options");
  }
  registerStep(t) {
    return this.trace.registerTrace(t), this;
  }
  async interact(t, n) {
    const r = await this.runtime.interact(n);
    return this.trace.processTrace(t, r);
  }
  async feedback(t) {
    return this.runtime.feedback(t);
  }
  async getPublishing(...t) {
    return this.runtime.getPublishing(...t);
  }
  async createTranscript(...t) {
    return this.runtime.createTranscript(...t);
  }
}
const ti = (e) => (t) => typeof t == "function" ? {
  canHandle: (n) => n.type === e,
  handle: t
} : t, x4 = ti(Dn.CARD_V2), O4 = ti(Dn.CHOICE);
ti(Dn.END);
ti(Dn.SPEAK);
ti(Dn.STREAM);
const w4 = ti(Dn.TEXT), I4 = ti(Dn.VISUAL), R4 = (e) => ({
  canHandle: ({ type: t }) => t === a4.NO_REPLY,
  handle: ({ context: t }, n) => {
    var r;
    if ((r = n.payload) != null && r.timeout) {
      const a = t.messages.reduce(
        (s, o) => s + (o.delay ?? 1e3) + js,
        0
      ), i = n.payload.timeout * 1e3 + a;
      e(i);
    }
    return t;
  }
}), N4 = (e) => e.filter((t) => t.type === mf.RESPONSE).map((t) => ({
  canHandle: (n) => t.match({ trace: n }),
  handle: ({ context: n }, r) => (n.messages.push({ type: cn.EXTENSION, payload: { trace: r, extension: t } }), n)
})), k4 = (e) => {
  const t = un(null), n = qr(() => {
    t.current && (clearTimeout(t.current), t.current = null);
  }, []);
  return { setNoReplyTimeout: qr((a) => {
    n(), t.current = setTimeout(() => {
      e().isStatus(pr.ACTIVE) && e().interact({ type: Tr.NO_REPLY, payload: null });
    }, a);
  }, []), clearNoReplyTimeout: n };
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function E0(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function fn(e) {
  var t, n;
  return E0(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(E0(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Pi = {};
function on(e) {
  for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  if (Pi.NODE_ENV !== "production") {
    var a = U4[e], i = a ? typeof a == "function" ? a.apply(null, n) : a : "unknown error nr: " + e;
    throw Error("[Immer] " + i);
  }
  throw Error("[Immer] minified error nr: " + e + (n.length ? " " + n.map(function(s) {
    return "'" + s + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function Xa(e) {
  return !!e && !!e[Wn];
}
function Ka(e) {
  return !!e && (function(t) {
    if (!t || typeof t != "object")
      return !1;
    var n = Object.getPrototypeOf(t);
    if (n === null)
      return !0;
    var r = Object.hasOwnProperty.call(n, "constructor") && n.constructor;
    return r === Object || typeof r == "function" && Function.toString.call(r) === H4;
  }(e) || Array.isArray(e) || !!e[O0] || !!e.constructor[O0] || bf(e) || Af(e));
}
function Ws(e, t, n) {
  n === void 0 && (n = !1), Gi(e) === 0 ? (n ? Object.keys : _f)(e).forEach(function(r) {
    n && typeof r == "symbol" || t(r, e[r], e);
  }) : e.forEach(function(r, a) {
    return t(a, r, e);
  });
}
function Gi(e) {
  var t = e[Wn];
  return t ? t.i > 3 ? t.i - 4 : t.i : Array.isArray(e) ? 1 : bf(e) ? 2 : Af(e) ? 3 : 0;
}
function Tc(e, t) {
  return Gi(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function L4(e, t) {
  return Gi(e) === 2 ? e.get(t) : e[t];
}
function Jg(e, t, n) {
  var r = Gi(e);
  r === 2 ? e.set(t, n) : r === 3 ? (e.delete(t), e.add(n)) : e[t] = n;
}
function P4(e, t) {
  return e === t ? e !== 0 || 1 / e == 1 / t : e != e && t != t;
}
function bf(e) {
  return B4 && e instanceof Map;
}
function Af(e) {
  return $4 && e instanceof Set;
}
function La(e) {
  return e.o || e.t;
}
function Ef(e) {
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  var t = j4(e);
  delete t[Wn];
  for (var n = _f(t), r = 0; r < n.length; r++) {
    var a = n[r], i = t[a];
    i.writable === !1 && (i.writable = !0, i.configurable = !0), (i.get || i.set) && (t[a] = { configurable: !0, writable: !0, enumerable: i.enumerable, value: e[a] });
  }
  return Object.create(Object.getPrototypeOf(e), t);
}
function vf(e, t) {
  return t === void 0 && (t = !1), Tf(e) || Xa(e) || !Ka(e) || (Gi(e) > 1 && (e.set = e.add = e.clear = e.delete = D4), Object.freeze(e), t && Ws(e, function(n, r) {
    return vf(r, !0);
  }, !0)), e;
}
function D4() {
  on(2);
}
function Tf(e) {
  return e == null || typeof e != "object" || Object.isFrozen(e);
}
function kr(e) {
  var t = z4[e];
  return t || on(18, e), t;
}
function v0() {
  return Pi.NODE_ENV === "production" || Di || on(0), Di;
}
function xV(e, t) {
  t && (kr("Patches"), e.u = [], e.s = [], e.v = t);
}
function nu(e) {
  yc(e), e.p.forEach(M4), e.p = null;
}
function yc(e) {
  e === Di && (Di = e.l);
}
function T0(e) {
  return Di = { p: [], l: Di, h: e, m: !0, _: 0 };
}
function M4(e) {
  var t = e[Wn];
  t.i === 0 || t.i === 1 ? t.j() : t.O = !0;
}
function OV(e, t) {
  t._ = t.p.length;
  var n = t.p[0], r = e !== void 0 && e !== n;
  return t.h.g || kr("ES5").S(t, e, r), r ? (n[Wn].P && (nu(t), on(4)), Ka(e) && (e = ru(t, e), t.l || au(t, e)), t.u && kr("Patches").M(n[Wn].t, e, t.u, t.s)) : e = ru(t, n, []), nu(t), t.u && t.v(t.u, t.s), e !== e1 ? e : void 0;
}
function ru(e, t, n) {
  if (Tf(t))
    return t;
  var r = t[Wn];
  if (!r)
    return Ws(t, function(i, s) {
      return y0(e, r, t, i, s, n);
    }, !0), t;
  if (r.A !== e)
    return t;
  if (!r.P)
    return au(e, r.t, !0), r.t;
  if (!r.I) {
    r.I = !0, r.A._--;
    var a = r.i === 4 || r.i === 5 ? r.o = Ef(r.k) : r.o;
    Ws(r.i === 3 ? new Set(a) : a, function(i, s) {
      return y0(e, r, a, i, s, n);
    }), au(e, a, !1), n && e.u && kr("Patches").R(r, n, e.u, e.s);
  }
  return r.o;
}
function y0(e, t, n, r, a, i) {
  if (Pi.NODE_ENV !== "production" && a === n && on(5), Xa(a)) {
    var s = ru(e, a, i && t && t.i !== 3 && !Tc(t.D, r) ? i.concat(r) : void 0);
    if (Jg(n, r, s), !Xa(s))
      return;
    e.m = !1;
  }
  if (Ka(a) && !Tf(a)) {
    if (!e.h.F && e._ < 1)
      return;
    ru(e, a), t && t.A.l || au(e, a);
  }
}
function au(e, t, n) {
  n === void 0 && (n = !1), e.h.F && e.m && vf(t, n);
}
function wV(e, t) {
  var n = e[Wn];
  return (n ? La(n) : e)[t];
}
function _0(e, t) {
  if (t in e)
    for (var n = Object.getPrototypeOf(e); n; ) {
      var r = Object.getOwnPropertyDescriptor(n, t);
      if (r)
        return r;
      n = Object.getPrototypeOf(n);
    }
}
function _c(e) {
  e.P || (e.P = !0, e.l && _c(e.l));
}
function IV(e) {
  e.o || (e.o = Ef(e.t));
}
function Cc(e, t, n) {
  var r = bf(t) ? kr("MapSet").N(t, n) : Af(t) ? kr("MapSet").T(t, n) : e.g ? function(a, i) {
    var s = Array.isArray(a), o = { i: s ? 1 : 0, A: i ? i.A : v0(), P: !1, I: !1, D: {}, l: i, t: a, k: null, o: null, j: null, C: !1 }, u = o, V = Sc;
    s && (u = [o], V = ms);
    var c = Proxy.revocable(u, V), f = c.revoke, p = c.proxy;
    return o.k = p, o.j = f, p;
  }(t, n) : kr("ES5").J(t, n);
  return (n ? n.A : v0()).p.push(r), r;
}
function F4(e) {
  return Xa(e) || on(22, e), function t(n) {
    if (!Ka(n))
      return n;
    var r, a = n[Wn], i = Gi(n);
    if (a) {
      if (!a.P && (a.i < 4 || !kr("ES5").K(a)))
        return a.t;
      a.I = !0, r = C0(n, i), a.I = !1;
    } else
      r = C0(n, i);
    return Ws(r, function(s, o) {
      a && L4(a.t, s) === o || Jg(r, s, t(o));
    }), i === 3 ? new Set(r) : r;
  }(e);
}
function C0(e, t) {
  switch (t) {
    case 2:
      return new Map(e);
    case 3:
      return Array.from(e);
  }
  return Ef(e);
}
var S0, Di, yf = typeof Symbol < "u" && typeof Symbol("x") == "symbol", B4 = typeof Map < "u", $4 = typeof Set < "u", x0 = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", e1 = yf ? Symbol.for("immer-nothing") : ((S0 = {})["immer-nothing"] = !0, S0), O0 = yf ? Symbol.for("immer-draftable") : "__$immer_draftable", Wn = yf ? Symbol.for("immer-state") : "__$immer_state", U4 = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(e) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(e) {
  return "Cannot apply patch, path doesn't resolve: " + e;
}, 16: 'Sets cannot have "replace" patches.', 17: function(e) {
  return "Unsupported patch operation: " + e;
}, 18: function(e) {
  return "The plugin for '" + e + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + e + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(e) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + e + "'";
}, 22: function(e) {
  return "'current' expects a draft, got: " + e;
}, 23: function(e) {
  return "'original' expects a draft, got: " + e;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" }, H4 = "" + Object.prototype.constructor, _f = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Object.getOwnPropertyNames, j4 = Object.getOwnPropertyDescriptors || function(e) {
  var t = {};
  return _f(e).forEach(function(n) {
    t[n] = Object.getOwnPropertyDescriptor(e, n);
  }), t;
}, z4 = {}, Sc = { get: function(e, t) {
  if (t === Wn)
    return e;
  var n = La(e);
  if (!Tc(n, t))
    return function(a, i, s) {
      var o, u = _0(i, s);
      return u ? "value" in u ? u.value : (o = u.get) === null || o === void 0 ? void 0 : o.call(a.k) : void 0;
    }(e, n, t);
  var r = n[t];
  return e.I || !Ka(r) ? r : r === wV(e.t, t) ? (IV(e), e.o[t] = Cc(e.A.h, r, e)) : r;
}, has: function(e, t) {
  return t in La(e);
}, ownKeys: function(e) {
  return Reflect.ownKeys(La(e));
}, set: function(e, t, n) {
  var r = _0(La(e), t);
  if (r != null && r.set)
    return r.set.call(e.k, n), !0;
  if (!e.P) {
    var a = wV(La(e), t), i = a == null ? void 0 : a[Wn];
    if (i && i.t === n)
      return e.o[t] = n, e.D[t] = !1, !0;
    if (P4(n, a) && (n !== void 0 || Tc(e.t, t)))
      return !0;
    IV(e), _c(e);
  }
  return e.o[t] === n && typeof n != "number" && (n !== void 0 || t in e.o) || (e.o[t] = n, e.D[t] = !0, !0);
}, deleteProperty: function(e, t) {
  return wV(e.t, t) !== void 0 || t in e.t ? (e.D[t] = !1, IV(e), _c(e)) : delete e.D[t], e.o && delete e.o[t], !0;
}, getOwnPropertyDescriptor: function(e, t) {
  var n = La(e), r = Reflect.getOwnPropertyDescriptor(n, t);
  return r && { writable: !0, configurable: e.i !== 1 || t !== "length", enumerable: r.enumerable, value: n[t] };
}, defineProperty: function() {
  on(11);
}, getPrototypeOf: function(e) {
  return Object.getPrototypeOf(e.t);
}, setPrototypeOf: function() {
  on(12);
} }, ms = {};
Ws(Sc, function(e, t) {
  ms[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
}), ms.deleteProperty = function(e, t) {
  return Pi.NODE_ENV !== "production" && isNaN(parseInt(t)) && on(13), ms.set.call(this, e, t, void 0);
}, ms.set = function(e, t, n) {
  return Pi.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && on(14), Sc.set.call(this, e[0], t, n, e[0]);
};
var G4 = function() {
  function e(n) {
    var r = this;
    this.g = x0, this.F = !0, this.produce = function(a, i, s) {
      if (typeof a == "function" && typeof i != "function") {
        var o = i;
        i = a;
        var u = r;
        return function(b) {
          var v = this;
          b === void 0 && (b = o);
          for (var x = arguments.length, E = Array(x > 1 ? x - 1 : 0), S = 1; S < x; S++)
            E[S - 1] = arguments[S];
          return u.produce(b, function($) {
            var U;
            return (U = i).call.apply(U, [v, $].concat(E));
          });
        };
      }
      var V;
      if (typeof i != "function" && on(6), s !== void 0 && typeof s != "function" && on(7), Ka(a)) {
        var c = T0(r), f = Cc(r, a, void 0), p = !0;
        try {
          V = i(f), p = !1;
        } finally {
          p ? nu(c) : yc(c);
        }
        return typeof Promise < "u" && V instanceof Promise ? V.then(function(b) {
          return xV(c, s), OV(b, c);
        }, function(b) {
          throw nu(c), b;
        }) : (xV(c, s), OV(V, c));
      }
      if (!a || typeof a != "object") {
        if ((V = i(a)) === void 0 && (V = a), V === e1 && (V = void 0), r.F && vf(V, !0), s) {
          var h = [], g = [];
          kr("Patches").M(a, V, h, g), s(h, g);
        }
        return V;
      }
      on(21, a);
    }, this.produceWithPatches = function(a, i) {
      if (typeof a == "function")
        return function(V) {
          for (var c = arguments.length, f = Array(c > 1 ? c - 1 : 0), p = 1; p < c; p++)
            f[p - 1] = arguments[p];
          return r.produceWithPatches(V, function(h) {
            return a.apply(void 0, [h].concat(f));
          });
        };
      var s, o, u = r.produce(a, i, function(V, c) {
        s = V, o = c;
      });
      return typeof Promise < "u" && u instanceof Promise ? u.then(function(V) {
        return [V, s, o];
      }) : [u, s, o];
    }, typeof (n == null ? void 0 : n.useProxies) == "boolean" && this.setUseProxies(n.useProxies), typeof (n == null ? void 0 : n.autoFreeze) == "boolean" && this.setAutoFreeze(n.autoFreeze);
  }
  var t = e.prototype;
  return t.createDraft = function(n) {
    Ka(n) || on(8), Xa(n) && (n = F4(n));
    var r = T0(this), a = Cc(this, n, void 0);
    return a[Wn].C = !0, yc(r), a;
  }, t.finishDraft = function(n, r) {
    var a = n && n[Wn];
    Pi.NODE_ENV !== "production" && (a && a.C || on(9), a.I && on(10));
    var i = a.A;
    return xV(i, r), OV(void 0, i);
  }, t.setAutoFreeze = function(n) {
    this.F = n;
  }, t.setUseProxies = function(n) {
    n && !x0 && on(20), this.g = n;
  }, t.applyPatches = function(n, r) {
    var a;
    for (a = r.length - 1; a >= 0; a--) {
      var i = r[a];
      if (i.path.length === 0 && i.op === "replace") {
        n = i.value;
        break;
      }
    }
    a > -1 && (r = r.slice(a + 1));
    var s = kr("Patches").$;
    return Xa(n) ? s(n, r) : this.produce(n, function(o) {
      return s(o, r);
    });
  }, e;
}(), qn = new G4(), Cf = qn.produce;
qn.produceWithPatches.bind(qn);
qn.setAutoFreeze.bind(qn);
qn.setUseProxies.bind(qn);
qn.applyPatches.bind(qn);
var w0 = qn.createDraft.bind(qn), I0 = qn.finishDraft.bind(qn), fe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = fe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var a = e[r], i = t[r];
      if (a !== i)
        break;
      n.push(a);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r])
        return -1;
      if (e[r] > t[r])
        return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), a = t.slice(0, n), i = e[n], s = t[n];
    return fe.equals(r, a) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), a = t.slice(0, n);
    return fe.equals(r, a);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), a = t.slice(0, n), i = e[n], s = t[n];
    return fe.equals(r, a) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return fe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && fe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return fe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && fe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && fe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && fe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && fe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), a = e[e.length - 1], i = t[t.length - 1];
    return a !== i && fe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], a = 0; a <= e.length; a++)
      r.push(e.slice(0, a));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!fe.isAncestor(t, e) && !fe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e)
      return null;
    var r = [...e], {
      affinity: a = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (fe.equals(i, r) || fe.endsBefore(i, r) || fe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (fe.equals(s, r) || fe.isAncestor(s, r))
          return null;
        fe.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: o,
          position: u
        } = t;
        fe.equals(o, r) || fe.endsBefore(o, r) ? r[o.length - 1] -= 1 : fe.isAncestor(o, r) && (r[o.length - 1] -= 1, r[o.length] += u);
        break;
      }
      case "split_node": {
        var {
          path: V,
          position: c
        } = t;
        if (fe.equals(V, r)) {
          if (a === "forward")
            r[r.length - 1] += 1;
          else if (a !== "backward")
            return null;
        } else
          fe.endsBefore(V, r) ? r[V.length - 1] += 1 : fe.isAncestor(V, r) && e[V.length] >= c && (r[V.length - 1] += 1, r[V.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: f,
          newPath: p
        } = t;
        if (fe.equals(f, p))
          return r;
        if (fe.isAncestor(f, r) || fe.equals(f, r)) {
          var h = p.slice();
          return fe.endsBefore(f, p) && f.length < p.length && (h[f.length - 1] -= 1), h.concat(r.slice(f.length));
        } else
          fe.isSibling(f, p) && (fe.isAncestor(p, r) || fe.equals(p, r)) ? fe.endsBefore(f, r) ? r[f.length - 1] -= 1 : r[f.length - 1] += 1 : fe.endsBefore(p, r) || fe.equals(p, r) || fe.isAncestor(p, r) ? (fe.endsBefore(f, r) && (r[f.length - 1] -= 1), r[p.length - 1] += 1) : fe.endsBefore(f, r) && (fe.equals(p, r) && (r[p.length - 1] += 1), r[f.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Yi(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function R0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R0(Object(n), !0).forEach(function(r) {
      Yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Y4 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: a
      } = n, i = Fe.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, a), t)
        for (var [o, u] of it.points(t))
          t[u] = It.transform(o, n);
      break;
    }
    case "insert_text": {
      var {
        path: V,
        offset: c,
        text: f
      } = n;
      if (f.length === 0)
        break;
      var p = Fe.leaf(e, V), h = p.text.slice(0, c), g = p.text.slice(c);
      if (p.text = h + f + g, t)
        for (var [b, v] of it.points(t))
          t[v] = It.transform(b, n);
      break;
    }
    case "merge_node": {
      var {
        path: x
      } = n, E = Fe.get(e, x), S = fe.previous(x), $ = Fe.get(e, S), U = Fe.parent(e, x), y = x[x.length - 1];
      if ($t.isText(E) && $t.isText($))
        $.text += E.text;
      else if (!$t.isText(E) && !$t.isText($))
        $.children.push(...E.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(x, "] to nodes of different interfaces: ").concat(Ir.stringify(E), " ").concat(Ir.stringify($)));
      if (U.children.splice(y, 1), t)
        for (var [j, q] of it.points(t))
          t[q] = It.transform(j, n);
      break;
    }
    case "move_node": {
      var {
        path: Q,
        newPath: I
      } = n;
      if (fe.isAncestor(Q, I))
        throw new Error("Cannot move a path [".concat(Q, "] to new path [").concat(I, "] because the destination is inside itself."));
      var ie = Fe.get(e, Q), z = Fe.parent(e, Q), H = Q[Q.length - 1];
      z.children.splice(H, 1);
      var P = fe.transform(Q, n), N = Fe.get(e, fe.parent(P)), K = P[P.length - 1];
      if (N.children.splice(K, 0, ie), t)
        for (var [D, J] of it.points(t))
          t[J] = It.transform(D, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, C = ee[ee.length - 1], ge = Fe.parent(e, ee);
      if (ge.children.splice(C, 1), t)
        for (var [pe, w] of it.points(t)) {
          var De = It.transform(pe, n);
          if (t != null && De != null)
            t[w] = De;
          else {
            var $e = void 0, Me = void 0;
            for (var [ct, Ye] of Fe.texts(e))
              if (fe.compare(Ye, ee) === -1)
                $e = [ct, Ye];
              else {
                Me = [ct, Ye];
                break;
              }
            var Oe = !1;
            $e && Me && (fe.equals(Me[1], ee) ? Oe = !fe.hasPrevious(Me[1]) : Oe = fe.common($e[1], ee).length < fe.common(Me[1], ee).length), $e && !Oe ? (pe.path = $e[1], pe.offset = $e[0].text.length) : Me ? (pe.path = Me[1], pe.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: We,
        offset: At,
        text: xt
      } = n;
      if (xt.length === 0)
        break;
      var en = Fe.leaf(e, We), tn = en.text.slice(0, At), An = en.text.slice(At + xt.length);
      if (en.text = tn + An, t)
        for (var [En, Xn] of it.points(t))
          t[Xn] = It.transform(En, n);
      break;
    }
    case "set_node": {
      var {
        path: vn,
        properties: rr,
        newProperties: Tn
      } = n;
      if (vn.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Kn = Fe.get(e, vn);
      for (var ln in Tn) {
        if (ln === "children" || ln === "text")
          throw new Error('Cannot set the "'.concat(ln, '" property of nodes!'));
        var Mn = Tn[ln];
        Mn == null ? delete Kn[ln] : Kn[ln] = Mn;
      }
      for (var ar in rr)
        Tn.hasOwnProperty(ar) || delete Kn[ar];
      break;
    }
    case "set_selection": {
      var {
        newProperties: te
      } = n;
      if (te == null)
        t = te;
      else {
        if (t == null) {
          if (!it.isRange(te))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ir.stringify(te), " when there is no current selection."));
          t = cs({}, te);
        }
        for (var de in te) {
          var xe = te[de];
          if (xe == null) {
            if (de === "anchor" || de === "focus")
              throw new Error('Cannot remove the "'.concat(de, '" selection property'));
            delete t[de];
          } else
            t[de] = xe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ie,
        position: He,
        properties: Dt
      } = n;
      if (Ie.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ie, "] because the root node cannot be split."));
      var Mt = Fe.get(e, Ie), Yt = Fe.parent(e, Ie), In = Ie[Ie.length - 1], Ot;
      if ($t.isText(Mt)) {
        var rt = Mt.text.slice(0, He), Ft = Mt.text.slice(He);
        Mt.text = rt, Ot = cs(cs({}, Dt), {}, {
          text: Ft
        });
      } else {
        var Nt = Mt.children.slice(0, He), yn = Mt.children.slice(He);
        Mt.children = Nt, Ot = cs(cs({}, Dt), {}, {
          children: yn
        });
      }
      if (Yt.children.splice(In + 1, 0, Ot), t)
        for (var [ir, Zn] of it.points(t))
          t[Zn] = It.transform(ir, n);
      break;
    }
  }
  return t;
}, W4 = {
  transform(e, t) {
    e.children = w0(e.children);
    var n = e.selection && w0(e.selection);
    try {
      n = Y4(e, n, t);
    } finally {
      e.children = I0(e.children), n ? e.selection = Xa(n) ? I0(n) : n : e.selection = null;
    }
  }
}, q4 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, X4 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, t1 = (e, t) => {
  for (var n in e) {
    var r = e[n], a = t[n];
    if (fn(r) && fn(a)) {
      if (!t1(r, a))
        return !1;
    } else if (Array.isArray(r) && Array.isArray(a)) {
      if (r.length !== a.length)
        return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== a[i])
          return !1;
    } else if (r !== a)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function K4(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function qs(e, t) {
  if (e == null)
    return {};
  var n = K4(e, t), r, a;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (a = 0; a < i.length; a++)
      r = i[a], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Z4 = ["anchor", "focus"];
function N0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Q4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N0(Object(n), !0).forEach(function(r) {
      Yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var it = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: a
    } = e;
    return it.isBackward(e) === n ? [r, a] : [a, r];
  },
  end(e) {
    var [, t] = it.edges(e);
    return t;
  },
  equals(e, t) {
    return It.equals(e.anchor, t.anchor) && It.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (it.isRange(t)) {
      if (it.includes(e, t.anchor) || it.includes(e, t.focus))
        return !0;
      var [n, r] = it.edges(e), [a, i] = it.edges(t);
      return It.isBefore(n, a) && It.isAfter(r, i);
    }
    var [s, o] = it.edges(e), u = !1, V = !1;
    return It.isPoint(t) ? (u = It.compare(t, s) >= 0, V = It.compare(t, o) <= 0) : (u = fe.compare(t, s.path) >= 0, V = fe.compare(t, o.path) <= 0), u && V;
  },
  intersection(e, t) {
    var n = qs(e, Z4), [r, a] = it.edges(e), [i, s] = it.edges(t), o = It.isBefore(r, i) ? i : r, u = It.isBefore(a, s) ? a : s;
    return It.isBefore(u, o) ? null : Q4({
      anchor: o,
      focus: u
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return It.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return It.equals(t, n);
  },
  isExpanded(e) {
    return !it.isCollapsed(e);
  },
  isForward(e) {
    return !it.isBackward(e);
  },
  isRange(e) {
    return fn(e) && It.isPoint(e.anchor) && It.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = it.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Cf(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: a = "inward"
      } = n, i, s;
      if (a === "inward") {
        var o = it.isCollapsed(r);
        it.isForward(r) ? (i = "forward", s = o ? i : "backward") : (i = "backward", s = o ? i : "forward");
      } else
        a === "outward" ? it.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = a, s = a);
      var u = It.transform(r.anchor, t, {
        affinity: i
      }), V = It.transform(r.focus, t, {
        affinity: s
      });
      if (!u || !V)
        return null;
      r.anchor = u, r.focus = V;
    });
  }
}, k0 = (e) => fn(e) && Fe.isNodeList(e.children) && !Qn.isEditor(e), Yr = {
  isAncestor(e) {
    return fn(e) && Fe.isNodeList(e.children);
  },
  isElement: k0,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Yr.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return k0(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, J4 = ["children"], ek = ["text"], L0 = /* @__PURE__ */ new WeakMap(), Fe = {
  ancestor(e, t) {
    var n = Fe.get(e, t);
    if ($t.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ir.stringify(n)));
    return n;
  },
  *ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var r of fe.ancestors(t, n)) {
      var a = Fe.ancestor(e, r), i = [a, r];
      yield i;
    }
  },
  child(e, t) {
    if ($t.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ir.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ir.stringify(e)));
    return n;
  },
  *children(e, t) {
    for (var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      reverse: r = !1
    } = n, a = Fe.ancestor(e, t), {
      children: i
    } = a, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
      var o = Fe.child(a, s), u = t.concat(s);
      yield [o, u], s = r ? s - 1 : s + 1;
    }
  },
  common(e, t, n) {
    var r = fe.common(t, n), a = Fe.get(e, r);
    return [a, r];
  },
  descendant(e, t) {
    var n = Fe.get(e, t);
    if (Qn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ir.stringify(n)));
    return n;
  },
  *descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [n, r] of Fe.nodes(e, t))
      r.length !== 0 && (yield [n, r]);
  },
  *elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [n, r] of Fe.nodes(e, t))
      Yr.isElement(n) && (yield [n, r]);
  },
  extractProps(e) {
    if (Yr.isAncestor(e)) {
      var t = qs(e, J4);
      return t;
    } else {
      var t = qs(e, ek);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Fe.get(e, n); r && !($t.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if ($t.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ir.stringify(e)));
    var n = Cf({
      children: e.children
    }, (r) => {
      var [a, i] = it.edges(t), s = Fe.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, h] = p;
          return !it.includes(t, h);
        }
      });
      for (var [, o] of s) {
        if (!it.includes(t, o)) {
          var u = Fe.parent(r, o), V = o[o.length - 1];
          u.children.splice(V, 1);
        }
        if (fe.equals(o, i.path)) {
          var c = Fe.leaf(r, o);
          c.text = c.text.slice(0, i.offset);
        }
        if (fe.equals(o, a.path)) {
          var f = Fe.leaf(r, o);
          f.text = f.text.slice(a.offset);
        }
      }
      Qn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var a = t[r];
      if ($t.isText(n) || !n.children[a])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ir.stringify(e)));
      n = n.children[a];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var a = t[r];
      if ($t.isText(n) || !n.children[a])
        return !1;
      n = n.children[a];
    }
    return !0;
  },
  isNode(e) {
    return $t.isText(e) || Yr.isElement(e) || Qn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = L0.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Fe.isNode(r));
    return L0.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Fe.get(e, n); r && !($t.isText(r) || r.children.length === 0); ) {
      var a = r.children.length - 1;
      r = r.children[a], n.push(a);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Fe.get(e, t);
    if (!$t.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ir.stringify(n)));
    return n;
  },
  *levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var r of fe.levels(t, n)) {
      var a = Fe.get(e, r);
      yield [a, r];
    }
  },
  matches(e, t) {
    return Yr.isElement(e) && Yr.isElementProps(t) && Yr.matches(e, t) || $t.isText(e) && $t.isTextProps(t) && $t.matches(e, t);
  },
  *nodes(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      pass: n,
      reverse: r = !1
    } = t, {
      from: a = [],
      to: i
    } = t, s = /* @__PURE__ */ new Set(), o = [], u = e; !(i && (r ? fe.isBefore(o, i) : fe.isAfter(o, i))); ) {
      if (s.has(u) || (yield [u, o]), !s.has(u) && !$t.isText(u) && u.children.length !== 0 && (n == null || n([u, o]) === !1)) {
        s.add(u);
        var V = r ? u.children.length - 1 : 0;
        fe.isAncestor(o, a) && (V = a[o.length]), o = o.concat(V), u = Fe.get(e, o);
        continue;
      }
      if (o.length === 0)
        break;
      if (!r) {
        var c = fe.next(o);
        if (Fe.has(e, c)) {
          o = c, u = Fe.get(e, o);
          continue;
        }
      }
      if (r && o[o.length - 1] !== 0) {
        var f = fe.previous(o);
        o = f, u = Fe.get(e, o);
        continue;
      }
      o = fe.parent(o), u = Fe.get(e, o), s.add(u);
    }
  },
  parent(e, t) {
    var n = fe.parent(t), r = Fe.get(e, n);
    if ($t.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return $t.isText(e) ? e.text : e.children.map(Fe.string).join("");
  },
  *texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [n, r] of Fe.nodes(e, t))
      $t.isText(n) && (yield [n, r]);
  }
};
function P0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P0(Object(n), !0).forEach(function(r) {
      Yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ps = {
  isNodeOperation(e) {
    return ps.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!fn(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return fe.isPath(e.path) && Fe.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && fe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && fe.isPath(e.path) && fn(e.properties);
      case "move_node":
        return fe.isPath(e.path) && fe.isPath(e.newPath);
      case "remove_node":
        return fe.isPath(e.path) && Fe.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && fe.isPath(e.path);
      case "set_node":
        return fe.isPath(e.path) && fn(e.properties) && fn(e.newProperties);
      case "set_selection":
        return e.properties === null && it.isRange(e.newProperties) || e.newProperties === null && it.isRange(e.properties) || fn(e.properties) && fn(e.newProperties);
      case "split_node":
        return fe.isPath(e.path) && typeof e.position == "number" && fn(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ps.isOperation(t));
  },
  isSelectionOperation(e) {
    return ps.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ps.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Lt(Lt({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Lt(Lt({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Lt(Lt({}, e), {}, {
          type: "split_node",
          path: fe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (fe.equals(t, n))
          return e;
        if (fe.isSibling(n, t))
          return Lt(Lt({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = fe.transform(n, e), a = fe.transform(fe.next(n), e);
        return Lt(Lt({}, e), {}, {
          path: r,
          newPath: a
        });
      }
      case "remove_node":
        return Lt(Lt({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Lt(Lt({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Lt(Lt({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: o,
          newProperties: u
        } = e;
        return o == null ? Lt(Lt({}, e), {}, {
          properties: u,
          newProperties: null
        }) : u == null ? Lt(Lt({}, e), {}, {
          properties: null,
          newProperties: o
        }) : Lt(Lt({}, e), {}, {
          properties: u,
          newProperties: o
        });
      }
      case "split_node":
        return Lt(Lt({}, e), {}, {
          type: "merge_node",
          path: fe.next(e.path)
        });
    }
  }
}, D0 = /* @__PURE__ */ new WeakMap(), tk = (e) => {
  var t = D0.get(e);
  if (t !== void 0)
    return t;
  if (!fn(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || fn(e.marks)) && (e.selection === null || it.isRange(e.selection)) && Fe.isNodeList(e.children) && ps.isOperationList(e.operations);
  return D0.set(e, n), n;
}, Qn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return tk(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  }
};
function M0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function F0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? M0(Object(n), !0).forEach(function(r) {
      Yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : M0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var It = {
  compare(e, t) {
    var n = fe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return It.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return It.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && fe.equals(e.path, t.path);
  },
  isPoint(e) {
    return fn(e) && typeof e.offset == "number" && fe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Cf(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: a = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = fe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          fe.equals(t.path, i) && (t.offset < s || t.offset === s && a === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          fe.equals(t.path, i) && (r.offset += t.position), r.path = fe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          fe.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (fe.equals(t.path, i) || fe.isAncestor(t.path, i))
            return null;
          r.path = fe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (fe.equals(t.path, i)) {
            if (t.position === s && a == null)
              return null;
            (t.position < s || t.position === s && a === "forward") && (r.offset -= t.position, r.path = fe.transform(i, t, F0(F0({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = fe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, B0 = void 0, Ir = {
  setScrubber(e) {
    B0 = e;
  },
  stringify(e) {
    return JSON.stringify(e, B0);
  }
}, nk = ["text"], rk = ["anchor", "focus"];
function $0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $0(Object(n), !0).forEach(function(r) {
      Yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $t = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function a(i) {
      var s = qs(i, nk);
      return s;
    }
    return t1(r ? a(e) : e, r ? a(t) : t);
  },
  isText(e) {
    return fn(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => $t.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Gr({}, e)];
    for (var r of t) {
      var a = qs(r, rk), [i, s] = it.edges(r), o = [], u = 0, V = i.offset, c = s.offset;
      for (var f of n) {
        var {
          length: p
        } = f.text, h = u;
        if (u += p, V <= h && u <= c) {
          Object.assign(f, a), o.push(f);
          continue;
        }
        if (V !== c && (V === u || c === h) || V > u || c < h || c === h && h !== 0) {
          o.push(f);
          continue;
        }
        var g = f, b = void 0, v = void 0;
        if (c < u) {
          var x = c - h;
          v = Gr(Gr({}, g), {}, {
            text: g.text.slice(x)
          }), g = Gr(Gr({}, g), {}, {
            text: g.text.slice(0, x)
          });
        }
        if (V > h) {
          var E = V - h;
          b = Gr(Gr({}, g), {}, {
            text: g.text.slice(0, E)
          }), g = Gr(Gr({}, g), {}, {
            text: g.text.slice(E)
          });
        }
        Object.assign(g, a), b && o.push(b), o.push(g), v && o.push(v);
      }
      n = o;
    }
    return n;
  }
}, ak = (e) => e.selection ? e.selection : e.children.length > 0 ? Qn.end(e, []) : [0], wt;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(wt || (wt = {}));
wt.L, wt.L | wt.V | wt.LV | wt.LVT, wt.LV | wt.V, wt.V | wt.T, wt.LVT | wt.T, wt.T, wt.Any, wt.Extend | wt.ZWJ, wt.Any, wt.SpacingMark, wt.Prepend, wt.Any, wt.ZWJ, wt.ExtPict, wt.RI, wt.RI;
var ik = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Qn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: a = ak(e)
      } = n;
      if (fe.isPath(a) && (a = Qn.range(e, a)), it.isRange(a))
        if (it.isCollapsed(a))
          a = a.anchor;
        else {
          var i = it.end(a);
          if (!r && Qn.void(e, {
            at: i
          }))
            return;
          var s = it.start(a), o = Qn.pointRef(e, s), u = Qn.pointRef(e, i);
          H0.delete(e, {
            at: a,
            voids: r
          });
          var V = o.unref(), c = u.unref();
          a = V || c, H0.setSelection(e, {
            anchor: a,
            focus: a
          });
        }
      if (!(!r && Qn.void(e, {
        at: a
      }) || Qn.elementReadOnly(e, {
        at: a
      }))) {
        var {
          path: f,
          offset: p
        } = a;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: f,
          offset: p,
          text: t
        });
      }
    });
  }
};
function U0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ao(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U0(Object(n), !0).forEach(function(r) {
      Yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var H0 = Ao(Ao(Ao(Ao({}, W4), q4), X4), ik);
const n1 = (e) => e.type === qa.LINK, r1 = (e) => e.type === qa.VARIABLE, sk = (e, t) => Yr.isElement(e) ? n1(e) && t.markdownLinks ? `[${i1(e.children)}](${e.url})` : r1(e) && t.encodeVariables ? `{${e.name}}` : a1(e.children, t).join("") : Fe.string(e), a1 = (e, t) => e.map((n) => sk(n, t)), i1 = (e, { encodeVariables: t = !0, markdownLinks: n = !1 } = {}) => a1(e, { encodeVariables: t, markdownLinks: n }).join(`
`).trim(), j0 = (e) => {
  var t;
  return !!e.title || !!e.description || !!e.image || !!((t = e.actions) != null && t.filter(({ name: n }) => !!n).length);
}, ok = [
  w4(({ context: e }, t) => {
    if (!NC.safeParse(t).success)
      return e;
    const { slate: n, message: r, ai: a, delay: i, audio: s } = t.payload;
    return e.messages.push({
      type: cn.TEXT,
      text: (n == null ? void 0 : n.content) || r,
      delay: i,
      ...a ? { ai: a } : {},
      ...s ? { audio: s } : {}
    }), e;
  }),
  I4(({ context: e }, t) => (LC.safeParse(t).success && e.messages.push({ type: cn.IMAGE, url: t.payload.image }), e)),
  O4(({ context: e }, t) => {
    if (!wC.safeParse(t).success)
      return e;
    const {
      payload: { buttons: n }
    } = t;
    return e.actions = n.map(({ name: r, request: a }) => ({
      name: r,
      request: a
    })), e;
  }),
  x4(({ context: e }, t) => {
    if (!xC.safeParse(t).success)
      return e;
    const {
      payload: { title: n, imageUrl: r, description: a, buttons: i }
    } = t, s = {
      title: n,
      description: a.text,
      image: r,
      actions: i.map(({ name: o, request: u }) => ({ name: o, request: u }))
    };
    return j0(s) && e.messages.push({
      type: "card",
      ...s
    }), e;
  }),
  {
    canHandle: ({ type: e }) => e === Dn.CAROUSEL,
    handle: ({ context: e }, t) => {
      if (!OC.safeParse(t).success)
        return e;
      const n = t.payload.cards.map(({ title: r, description: a, imageUrl: i, buttons: s }) => ({
        title: r,
        description: a.text,
        image: i,
        actions: s.map(({ name: o, request: u }) => ({ name: o, request: u }))
      })).filter(j0);
      return n.length && e.messages.push({
        type: cn.CAROUSEL,
        cards: n
      }), e;
    }
  },
  {
    canHandle: ({ type: e }) => e === Dn.END,
    handle: ({ context: e }) => (e.messages.push({ type: cn.END }), e)
  }
];
var gs = /* @__PURE__ */ ((e) => (e.POSITIVE = "Thumbs up", e.NEGATIVE = "Thumbs down", e))(gs || {});
const s1 = () => ({
  messages: []
}), uk = ({
  url: e,
  user: t,
  userID: n,
  verify: r,
  versionID: a,
  traceHandlers: i = []
}) => {
  const s = Jr(
    () => new S4({
      verify: r,
      url: e,
      traces: [...ok, ...i]
    }),
    []
  );
  return { interact: async (c, f) => s.interact(s1(), {
    sessionID: n,
    action: c,
    config: f,
    ...a && { versionID: a }
  }), saveFeedback: async (c, f, p) => {
    const h = [];
    f.forEach((g) => {
      if (!g.ai || g.type !== cn.TEXT)
        return;
      const b = typeof g.text == "string" ? g.text : i1(g.text);
      h.push(b);
    }), await s.feedback({
      sessionID: n,
      name: c,
      text: h,
      lastUserTurn: p,
      ...a && { versionID: a }
    });
  }, saveTranscript: async () => {
    const {
      browser: { name: c },
      os: { name: f },
      platform: { type: p }
    } = Qc;
    await s.createTranscript(n, {
      ...f && { os: f },
      ...c && { browser: c },
      ...p && { device: p },
      ...t && { user: t }
    });
  } };
}, Vk = {
  turns: [],
  startTime: Date.now()
}, lk = ({ assistant: e, config: t, traceHandlers: n }) => {
  const [r] = Jt(() => new YN()), a = un([]), [i, s] = Jt(!1), [o, u, V] = JC(
    "audio-output",
    e.defaultAudioOutput ?? !1
  ), [c, f, p] = KC(() => ({
    ...Vk,
    status: t.autostart ? pr.IDLE : pr.ENDED,
    // retrieve stored session
    ...GN(e.persistence, t.verify.projectID, t.userID)
  })), [h, g] = Jt(!1), { clearNoReplyTimeout: b, setNoReplyTimeout: v } = k4(() => ({ interact: q, isStatus: $ })), x = uk({
    ...t,
    ...c,
    traceHandlers: [
      R4(v),
      ...e4(e.extensions),
      ...N4(e.extensions),
      ...n ?? []
    ]
  }), E = () => e.audioInterface && V.current, S = (D) => {
    f((J) => J.status === D ? J : { ...J, status: D });
  }, $ = (D) => p.current.status === D, U = (D) => {
    f((J) => ({ ...J, turns: D(J.turns) }));
  }, y = (D) => U((J) => [...J, D]), j = () => U(() => []), q = async (D, J) => {
    if (b(), p.current.status === pr.ENDED)
      return;
    p.current.turns.length === 1 && x.saveTranscript(), HN(D);
    const ee = J || (lg(D) ? D.payload : null);
    ee && y({
      id: Hs(),
      type: ja.USER,
      message: ee,
      timestamp: Date.now()
    });
    const C = XN(D, H());
    g(!0);
    const ge = await x.interact(C, { tts: E() }).catch((w) => (console.error(w), s1()));
    g(!1), y({
      id: Hs(),
      type: ja.SYSTEM,
      timestamp: Date.now(),
      ...ge
    });
    const pe = E() && a.current.length === 0;
    E() && ge.messages.forEach((w) => {
      var De;
      w.type === cn.TEXT && ((De = w.audio) != null && De.src) && a.current.push(w.audio.src);
    }), pe && (await new Promise((w) => setTimeout(w, js)), N()), wo({ type: As.INTERACT, payload: { session: p.current, action: C } }), b0(e.persistence, t.verify.projectID, p.current);
  }, Q = async () => {
    var D;
    a.current = [], GC() && E() && r.play(KN), p.current.turns.length && j(), S(pr.ACTIVE), await q(((D = t.launch) == null ? void 0 : D.event) ?? { type: Zr.LAUNCH });
  }, I = async (D) => {
    P(), q({ type: Zr.TEXT, payload: D });
  }, ie = async () => {
    wo({ type: As.OPEN }), s(!0), $(pr.IDLE) && await Q();
  }, z = () => {
    P(), wo({ type: As.CLOSE }), b0(e.persistence, t.verify.projectID, p.current), s(!1);
  }, H = () => p.current.turns, P = () => {
    a.current = [], r.stop();
  }, N = async () => {
    !E() || !a.current.length || (await r.play(a.current.shift()), N());
  }, K = () => {
    P(), u((D) => !D);
  };
  return Gn(() => {
    if (i)
      return () => {
        P();
      };
  }, [i]), {
    state: {
      session: c,
      isOpen: i,
      indicator: h,
      audioOutput: o
    },
    api: {
      launch: Q,
      reply: I,
      open: ie,
      interact: q,
      close: z,
      addTurn: y,
      feedback: x.saveFeedback,
      setStatus: S,
      setOpen: s,
      isStatus: $,
      reset: j,
      getTurns: H,
      setIndicator: g,
      setAudioOutput: u,
      toggleAudioOutput: K,
      // these are meant to be static, so bundling them with the API
      assistant: e,
      config: t
    }
  };
}, _r = Xc({}), Iu = Xc({}), yU = ({ children: e, extend: t, ...n }) => {
  const r = lk(n), a = Jr(() => (t == null ? void 0 : t(r.api)) ?? r.api, []);
  return /* @__PURE__ */ X.jsx(_r.Provider, { value: a, children: /* @__PURE__ */ X.jsx(Iu.Provider, { value: r.state, children: e }) });
}, o1 = 246, to = _t(vt.CARD), u1 = Te(to("section"), {
  display: "inline-flex",
  flexDirection: "column",
  width: o1,
  border: "1px solid #f1f1f1",
  borderRadius: "$2",
  boxSizing: "content-box",
  overflow: "hidden",
  backgroundColor: "$lightGrey",
  [`& ${tr.Container}`]: {
    width: "100%",
    color: "$primary",
    backgroundColor: "$white",
    boxShadow: "0 5px 8px -8px $shadow12, 0 2px 4px -3px $shadow12, 0 0 0 1px $shadow3, 0 1px 3px 1px $shadow1",
    marginBottom: "$2",
    trans: ["color", "box-shadow"],
    "&:hover": {
      color: "$darkPrimary",
      backgroundColor: "$white",
      boxShadow: "0 5px 8px -8px $shadow12, 0 2px 4px -3px $shadow12, 0 0 0 1px $shadow4, 0 1px 4px 1px $shadow4"
    },
    "&:first-of-type": {
      marginTop: "$3"
    },
    "&:last-of-type": {
      marginBottom: 0
    }
  }
}), ck = Te(to("main", "content"), {
  padding: "$3"
}), fk = Te(to("h3", "header"), {
  margin: "0 0 $1 0",
  typo: { weight: "$2" },
  color: "$black",
  wordBreak: "break-word",
  maxWidth: "100%",
  whiteSpace: "break-spaces"
}), dk = Te(to("p", "description"), {
  margin: 0,
  typo: { size: "$1" },
  color: "$darkGrey",
  whiteSpace: "normal",
  wordBreak: "break-word"
}), hk = Te(to("a", "link"), {
  margin: 0,
  typo: { size: "$1" },
  whiteSpace: "normal",
  overflow: "hidden",
  textOverflow: "ellipsis",
  color: "rgb(93, 157, 245)",
  textDecoration: "underline",
  pointerEvents: "all",
  wordBreak: "break-all"
}), mk = (e) => {
  let t;
  try {
    t = new URL(e);
  } catch {
    return !1;
  }
  return t.protocol === "http:" || t.protocol === "https:";
}, pk = ({ title: e, description: t, image: n, actions: r = [] }) => {
  const a = Yn(_r), i = mk(t), s = Jr(() => r.filter(({ name: o }) => !!o), [r]);
  return /* @__PURE__ */ X.jsxs(u1, { children: [
    !!n && /* @__PURE__ */ X.jsx(Qp, { image: n }),
    /* @__PURE__ */ X.jsxs(ck, { children: [
      !!e && /* @__PURE__ */ X.jsx(fk, { children: e }),
      !!t && (i ? /* @__PURE__ */ X.jsx(hk, { rel: "noopener noreferrer", href: t, target: "_blank", children: t }) : /* @__PURE__ */ X.jsx(dk, { children: t })),
      s.map(({ request: o, name: u }, V) => /* @__PURE__ */ X.jsx(tr, { onClick: () => a.interact(o, u), children: u }, V))
    ] })
  ] });
}, Sf = Object.assign(pk, {
  Container: u1
}), Eo = 42, Ru = 12, V1 = _t(vt.CAROUSEL), gk = Te(V1("span", "button"), {
  position: "absolute",
  zIndex: 1,
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "$round",
  trans: ["background-color", "box-shadow", "opacity"],
  height: Eo,
  width: Eo,
  cursor: "pointer",
  backgroundColor: "$white",
  color: "$black",
  boxShadow: "0 1px 3px 1px $shadow1, 0 0 0 1px $shadow3, 0 2px 4px -3px $shadow12, 0 5px 8px -8px $shadow12",
  border: "none",
  [`& ${zt.Frame}`]: {
    height: "$xxs",
    width: "$xxs",
    color: "rgba(0,0,0,0.6)",
    trans: ["color"]
  },
  "&:hover": {
    boxShadow: "0 1px 4px 1px $shadow4, 0 0 0 1px $shadow4, 0 2px 4px -3px $shadow12, 0 5px 8px -8px $shadow12"
  },
  "&:active": {
    boxShadow: "0 1px 4px 1px $shadow8, 0 0 0 1px $shadow4, 0 2px 4px -3px $shadow12, 0 5px 8px -8px $shadow12"
  },
  [`
      &:hover ${zt.Frame},
      &:active ${zt.Frame}
    `]: {
    color: "rgba(0,0,0,0.8)"
  },
  variants: {
    visible: {
      true: {
        opacity: 1,
        pointerEvents: "auto"
      },
      false: {
        opacity: 0,
        pointerEvents: "none"
      }
    },
    alignment: {
      left: {
        left: 48 - Eo / 2
      },
      right: {
        right: 70 - Eo / 2,
        [`& ${zt.Frame}`]: {
          transform: "scaleX(-1)"
        }
      }
    }
  }
}), l1 = Te(V1("div"), {
  display: "flex",
  whiteSpace: "nowrap",
  [`& ${Sf.Container}`]: {
    height: "fit-content",
    flexShrink: 0,
    marginLeft: Ru,
    "&:first-of-type": {
      marginLeft: 0
    }
  }
}), z0 = Wc(
  ({ onClick: e, alignment: t, visible: n, containerEl: r }, a) => /* @__PURE__ */ X.jsx(
    gk,
    {
      ref: a,
      alignment: t,
      visible: n,
      css: {
        transform: `translateY(calc(${r.clientHeight / 2}px - 50%))`
      },
      onClick: e,
      children: /* @__PURE__ */ X.jsx(zt, { svg: "largeArrowLeft" })
    }
  )
), xf = o1 + 2, c1 = xf / 3, bk = xf + Ru + c1, iu = xf + Ru, G0 = (e, t) => () => {
  const n = e == null ? void 0 : e.current;
  if (!n)
    return;
  const r = t(n);
  n.scrollTo({
    left: r && r * iu,
    behavior: "smooth"
  });
}, Ak = (e, t, n) => {
  const [r, a] = Jt(!1), [i, s] = Jt(!1), o = un(null), u = un(null), V = n.length > 1;
  return Gn(() => {
    !(t != null && t.current) || !V || s(!0);
  }, []), Gn(() => {
    const c = e == null ? void 0 : e.current;
    if (!c || !V)
      return;
    const f = iu * n.length - Ru, p = () => {
      const { scrollLeft: h } = c;
      a(h >= c1), s(h <= f - bk);
    };
    return c.addEventListener("scroll", p), () => {
      c.removeEventListener("scroll", p);
    };
  }, []), {
    previousButtonRef: o,
    nextButtonRef: u,
    showPreviousButton: r,
    showNextButton: i
  };
}, Ek = ({ cards: e, containerRef: t, controlsRef: n }) => {
  const { previousButtonRef: r, nextButtonRef: a, showPreviousButton: i, showNextButton: s } = Ak(
    t,
    n,
    e
  ), o = t == null ? void 0 : t.current, u = n == null ? void 0 : n.current, V = o && u, c = G0(t, (p) => Math.ceil(p.scrollLeft / iu) - 1), f = G0(t, (p) => Math.floor(p.scrollLeft / iu) + 1);
  return /* @__PURE__ */ X.jsxs(X.Fragment, { children: [
    /* @__PURE__ */ X.jsx(l1, { children: e.map((p, h) => /* @__PURE__ */ qc(Sf, { ...p, key: h })) }),
    V && jy(
      /* @__PURE__ */ X.jsxs(X.Fragment, { children: [
        /* @__PURE__ */ X.jsx(
          z0,
          {
            ref: r,
            alignment: "left",
            visible: i,
            containerEl: o,
            onClick: c
          }
        ),
        /* @__PURE__ */ X.jsx(
          z0,
          {
            ref: a,
            alignment: "right",
            visible: s,
            containerEl: o,
            onClick: f
          }
        )
      ] }),
      u
    )
  ] });
}, vk = Object.assign(Ek, {
  Container: l1
}), Of = (e, t) => ({ initialValue: n, ...r }) => {
  var u;
  const a = Jt(n ?? (t == null ? void 0 : t.defaultValue)), i = ((u = t == null ? void 0 : t.enrichProps) == null ? void 0 : u.call(t, r, a)) ?? r, [s, o] = a;
  return /* @__PURE__ */ X.jsx(e, { ...i, value: s, onValueChange: o });
}, wf = (...e) => (...t) => e.forEach((n) => n == null ? void 0 : n(...t)), _U = () => {
};
function xc() {
  return xc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, xc.apply(this, arguments);
}
function Tk(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var yk = Kc, _k = function(t) {
  var n = Se.useRef(t);
  return yk(function() {
    n.current = t;
  }), n;
}, Y0 = function(t, n) {
  if (typeof t == "function") {
    t(n);
    return;
  }
  t.current = n;
}, Ck = function(t, n) {
  var r = un();
  return qr(function(a) {
    t.current = a, r.current && Y0(r.current, null), r.current = n, n && Y0(n, a);
  }, [n]);
}, W0 = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0"
}, Sk = function(t) {
  Object.keys(W0).forEach(function(n) {
    t.style.setProperty(n, W0[n], "important");
  });
}, q0 = Sk, Cn = null, X0 = function(t, n) {
  var r = t.scrollHeight;
  return n.sizingStyle.boxSizing === "border-box" ? r + n.borderSize : r - n.paddingSize;
};
function xk(e, t, n, r) {
  n === void 0 && (n = 1), r === void 0 && (r = 1 / 0), Cn || (Cn = document.createElement("textarea"), Cn.setAttribute("tabindex", "-1"), Cn.setAttribute("aria-hidden", "true"), q0(Cn)), Cn.parentNode === null && document.body.appendChild(Cn);
  var a = e.paddingSize, i = e.borderSize, s = e.sizingStyle, o = s.boxSizing;
  Object.keys(s).forEach(function(p) {
    var h = p;
    Cn.style[h] = s[h];
  }), q0(Cn), Cn.value = t;
  var u = X0(Cn, e);
  Cn.value = t, u = X0(Cn, e), Cn.value = "x";
  var V = Cn.scrollHeight - a, c = V * n;
  o === "border-box" && (c = c + a + i), u = Math.max(c, u);
  var f = V * r;
  return o === "border-box" && (f = f + a + i), u = Math.min(f, u), [u, V];
}
var K0 = function() {
}, Ok = function(t, n) {
  return t.reduce(function(r, a) {
    return r[a] = n[a], r;
  }, {});
}, wk = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak"
], Ik = !!document.documentElement.currentStyle, Rk = function(t) {
  var n = window.getComputedStyle(t);
  if (n === null)
    return null;
  var r = Ok(wk, n), a = r.boxSizing;
  if (a === "")
    return null;
  Ik && a === "border-box" && (r.width = parseFloat(r.width) + parseFloat(r.borderRightWidth) + parseFloat(r.borderLeftWidth) + parseFloat(r.paddingRight) + parseFloat(r.paddingLeft) + "px");
  var i = parseFloat(r.paddingBottom) + parseFloat(r.paddingTop), s = parseFloat(r.borderBottomWidth) + parseFloat(r.borderTopWidth);
  return {
    sizingStyle: r,
    paddingSize: i,
    borderSize: s
  };
}, Nk = Rk;
function f1(e, t, n) {
  var r = _k(n);
  Se.useLayoutEffect(function() {
    var a = function(s) {
      return r.current(s);
    };
    if (e)
      return e.addEventListener(t, a), function() {
        return e.removeEventListener(t, a);
      };
  }, []);
}
var kk = function(t) {
  f1(window, "resize", t);
}, Lk = function(t) {
  f1(document.fonts, "loadingdone", t);
}, Pk = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], Dk = function(t, n) {
  var r = t.cacheMeasurements, a = t.maxRows, i = t.minRows, s = t.onChange, o = s === void 0 ? K0 : s, u = t.onHeightChange, V = u === void 0 ? K0 : u, c = Tk(t, Pk), f = c.value !== void 0, p = Se.useRef(null), h = Ck(p, n), g = Se.useRef(0), b = Se.useRef(), v = function() {
    var S = p.current, $ = r && b.current ? b.current : Nk(S);
    if ($) {
      b.current = $;
      var U = xk($, S.value || S.placeholder || "x", i, a), y = U[0], j = U[1];
      g.current !== y && (g.current = y, S.style.setProperty("height", y + "px", "important"), V(y, {
        rowHeight: j
      }));
    }
  }, x = function(S) {
    f || v(), o(S);
  };
  return Se.useLayoutEffect(v), kk(v), Lk(v), /* @__PURE__ */ Se.createElement("textarea", xc({}, c, {
    onChange: x,
    ref: h
  }));
}, Mk = /* @__PURE__ */ Se.forwardRef(Dk);
const Z0 = {
  width: "calc(100% - 42px)",
  borderRadius: "$1 0 0 $1",
  height: "42px",
  borderRightWidth: 0,
  fontFamily: "$default",
  fontSize: "$2"
}, If = {
  boxSizing: "border-box",
  border: "1px solid rgba(115,115,118,0.3)",
  backgroundColor: "$white",
  boxShadow: "0 1px 12px $shadow2",
  trans: ["border-color"],
  resize: "none"
}, Oc = {
  border: "1px solid rgba(115,115,118,0.5)"
}, d1 = Te(Mk, {
  ...If,
  ...Z0,
  // TODO use tokens
  padding: "11px $4 11px",
  color: "$black",
  "&:focus": {
    ...Oc,
    ...Z0,
    outline: "none"
  },
  "&::placeholder": {
    color: "$darkGrey"
  }
}), Q0 = Wc(({ onValueChange: e, onChange: t, ...n }, r) => {
  const a = wf(t, (i) => e(i.target.value));
  return /* @__PURE__ */ X.jsx(d1, { ref: r, ...n, onChange: a, minRows: 1, maxRows: 5, style: { height: 42 } });
}), Io = Object.assign(Q0, {
  Controlled: Of(Q0, { defaultValue: "" }),
  Container: d1
}), Rf = _t(vt.CHAT_INPUT), su = Te(Rf("label", "button"), {
  ...If,
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  paddingBottom: "8px",
  width: "$md",
  borderRadius: "$1",
  boxSizing: "border-box",
  cursor: "text",
  pointerEvents: "none",
  [`& ${rl.Container}`]: {
    transform: "scale(0)",
    marginTop: "auto",
    trans: ["background-color", "transform"]
  },
  variants: {
    ready: {
      true: {
        [`& ${rl.Container}`]: {
          transform: "scale(1)",
          cursor: "pointer",
          pointerEvents: "all"
        }
      }
    }
  }
}), h1 = Te(Rf("div"), {
  display: "flex",
  boxShadow: "0 1px 12px $shadow2",
  trans: ["border-color", "box-shadow"],
  position: "relative",
  [`& ${Io.Container}`]: {
    ...If,
    minHeight: "$md",
    margin: 0,
    borderRightWidth: 0,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 0,
    paddingRight: 7,
    boxShadow: "none"
  },
  [`& ${su}`]: {
    height: "inherit",
    borderLeftWidth: 0,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 0
  },
  [`& ${zt.Frame}`]: {
    color: "$white"
  },
  [`& ${Io.Container}:focus`]: {
    ...Oc,
    borderRightWidth: 0
  },
  [`& ${Io.Container}:focus + ${su}`]: {
    ...Oc,
    borderLeftWidth: 0
  }
}), Fk = Te(Rf("button"), {
  width: "$md",
  position: "absolute",
  right: 0,
  top: 0,
  bottom: 0,
  border: "none",
  background: "transparent",
  cursor: "pointer",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: 0,
  [`&& ${zt.Frame}`]: {
    color: "$darkGrey",
    opacity: 0.8,
    trans: ["opacity", "color"]
  },
  "&:hover": {
    [`&& ${zt.Frame}`]: {
      opacity: 1
    }
  },
  "&:active": {
    [`&& ${zt.Frame}`]: {
      color: "$black",
      opacity: 1
    }
  },
  variants: {
    listening: {
      true: {
        [`&& ${zt.Frame}`]: {
          color: "$warn"
        },
        "&:active": {
          [`&& ${zt.Frame}`]: {
            color: "$warn"
          }
        }
      }
    },
    disabled: {
      true: {
        cursor: "not-allowed",
        [`&& ${zt.Frame}`]: {
          opacity: 0.5
        }
      }
    }
  }
}), Bk = ({
  onStop: e,
  onStart: t,
  listening: n,
  processing: r,
  initializing: a
}) => /* @__PURE__ */ X.jsx(
  Fk,
  {
    onClick: n ? e : t,
    disabled: r || a,
    listening: n,
    children: /* @__PURE__ */ X.jsx(zt, { svg: n ? "stop" : "microphone" })
  }
);
var Nf = {}, m1 = {}, Pn = {};
Object.defineProperty(Pn, "__esModule", {
  value: !0
});
Pn.browserSupportsPolyfills = Pn.compareTwoStringsUsingDiceCoefficient = Pn.commandToRegExp = Pn.concatTranscripts = Pn.debounce = void 0;
var $k = function(t, n, r) {
  var a;
  return function() {
    var i = this, s = arguments, o = function() {
      a = null, r || t.apply(i, s);
    }, u = r && !a;
    clearTimeout(a), a = setTimeout(o, n), u && t.apply(i, s);
  };
};
Pn.debounce = $k;
var Uk = function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  return n.map(function(a) {
    return a.trim();
  }).join(" ").trim();
};
Pn.concatTranscripts = Uk;
var Hk = /\s*\((.*?)\)\s*/g, jk = /(\(\?:[^)]+\))\?/g, zk = /(\(\?)?:\w+/g, Gk = /\*/g, Yk = /[-{}[\]+?.,\\^$|#]/g, Wk = function(t) {
  return t instanceof RegExp ? new RegExp(t.source, "i") : (t = t.replace(Yk, "\\$&").replace(Hk, "(?:$1)?").replace(zk, function(n, r) {
    return r ? n : "([^\\s]+)";
  }).replace(Gk, "(.*?)").replace(jk, "\\s*$1?\\s*"), new RegExp("^" + t + "$", "i"));
};
Pn.commandToRegExp = Wk;
var qk = function(t, n) {
  if (t = t.replace(/\s+/g, "").toLowerCase(), n = n.replace(/\s+/g, "").toLowerCase(), !t.length && !n.length)
    return 1;
  if (!t.length || !n.length)
    return 0;
  if (t === n)
    return 1;
  if (t.length === 1 && n.length === 1 || t.length < 2 || n.length < 2)
    return 0;
  for (var r = /* @__PURE__ */ new Map(), a = 0; a < t.length - 1; a++) {
    var i = t.substring(a, a + 2), s = r.has(i) ? r.get(i) + 1 : 1;
    r.set(i, s);
  }
  for (var o = 0, u = 0; u < n.length - 1; u++) {
    var V = n.substring(u, u + 2), c = r.has(V) ? r.get(V) : 0;
    c > 0 && (r.set(V, c - 1), o++);
  }
  return 2 * o / (t.length + n.length - 2);
};
Pn.compareTwoStringsUsingDiceCoefficient = qk;
var Xk = function() {
  return typeof window < "u" && window.navigator !== void 0 && window.navigator.mediaDevices !== void 0 && window.navigator.mediaDevices.getUserMedia !== void 0 && (window.AudioContext !== void 0 || window.webkitAudioContext !== void 0);
};
Pn.browserSupportsPolyfills = Xk;
var Mi = {}, Za = {};
Object.defineProperty(Za, "__esModule", {
  value: !0
});
Za.APPEND_TRANSCRIPT = Za.CLEAR_TRANSCRIPT = void 0;
var Kk = "CLEAR_TRANSCRIPT";
Za.CLEAR_TRANSCRIPT = Kk;
var Zk = "APPEND_TRANSCRIPT";
Za.APPEND_TRANSCRIPT = Zk;
Object.defineProperty(Mi, "__esModule", {
  value: !0
});
Mi.appendTranscript = Mi.clearTranscript = void 0;
var p1 = Za, Qk = function() {
  return {
    type: p1.CLEAR_TRANSCRIPT
  };
};
Mi.clearTranscript = Qk;
var Jk = function(t, n) {
  return {
    type: p1.APPEND_TRANSCRIPT,
    payload: {
      interimTranscript: t,
      finalTranscript: n
    }
  };
};
Mi.appendTranscript = Jk;
var Nu = {};
Object.defineProperty(Nu, "__esModule", {
  value: !0
});
Nu.transcriptReducer = void 0;
var J0 = Za, e5 = Pn, t5 = function(t, n) {
  switch (n.type) {
    case J0.CLEAR_TRANSCRIPT:
      return {
        interimTranscript: "",
        finalTranscript: ""
      };
    case J0.APPEND_TRANSCRIPT:
      return {
        interimTranscript: n.payload.interimTranscript,
        finalTranscript: (0, e5.concatTranscripts)(t.finalTranscript, n.payload.finalTranscript)
      };
    default:
      throw new Error();
  }
};
Nu.transcriptReducer = t5;
var g1 = {}, kf = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = void 0;
  var t = function() {
    return /(android)/i.test(typeof navigator < "u" ? navigator.userAgent : "");
  };
  e.default = t;
})(kf);
var Lf = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = e.isNative = void 0;
  var t = typeof window < "u" && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition), n = function(i) {
    return i === t;
  };
  e.isNative = n;
  var r = t;
  e.default = r;
})(Lf);
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = void 0;
  var t = a(kf), n = Pn, r = Lf;
  function a(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function i(f, p, h, g, b, v, x) {
    try {
      var E = f[v](x), S = E.value;
    } catch ($) {
      h($);
      return;
    }
    E.done ? p(S) : Promise.resolve(S).then(g, b);
  }
  function s(f) {
    return function() {
      var p = this, h = arguments;
      return new Promise(function(g, b) {
        var v = f.apply(p, h);
        function x(S) {
          i(v, g, b, x, E, "next", S);
        }
        function E(S) {
          i(v, g, b, x, E, "throw", S);
        }
        x(void 0);
      });
    };
  }
  function o(f, p) {
    if (!(f instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function u(f, p) {
    for (var h = 0; h < p.length; h++) {
      var g = p[h];
      g.enumerable = g.enumerable || !1, g.configurable = !0, "value" in g && (g.writable = !0), Object.defineProperty(f, g.key, g);
    }
  }
  function V(f, p, h) {
    return p && u(f.prototype, p), h && u(f, h), f;
  }
  var c = /* @__PURE__ */ function() {
    function f(p) {
      o(this, f), this.recognition = null, this.pauseAfterDisconnect = !1, this.interimTranscript = "", this.finalTranscript = "", this.listening = !1, this.isMicrophoneAvailable = !0, this.subscribers = {}, this.onStopListening = function() {
      }, this.previousResultWasFinalOnly = !1, this.resetTranscript = this.resetTranscript.bind(this), this.startListening = this.startListening.bind(this), this.stopListening = this.stopListening.bind(this), this.abortListening = this.abortListening.bind(this), this.setSpeechRecognition = this.setSpeechRecognition.bind(this), this.disableRecognition = this.disableRecognition.bind(this), this.setSpeechRecognition(p), (0, t.default)() && (this.updateFinalTranscript = (0, n.debounce)(this.updateFinalTranscript, 250, !0));
    }
    return V(f, [{
      key: "setSpeechRecognition",
      value: function(h) {
        var g = !!h && ((0, r.isNative)(h) || (0, n.browserSupportsPolyfills)());
        g && (this.disableRecognition(), this.recognition = new h(), this.recognition.continuous = !1, this.recognition.interimResults = !0, this.recognition.onresult = this.updateTranscript.bind(this), this.recognition.onend = this.onRecognitionDisconnect.bind(this), this.recognition.onerror = this.onError.bind(this)), this.emitBrowserSupportsSpeechRecognitionChange(g);
      }
    }, {
      key: "subscribe",
      value: function(h, g) {
        this.subscribers[h] = g;
      }
    }, {
      key: "unsubscribe",
      value: function(h) {
        delete this.subscribers[h];
      }
    }, {
      key: "emitListeningChange",
      value: function(h) {
        var g = this;
        this.listening = h, Object.keys(this.subscribers).forEach(function(b) {
          var v = g.subscribers[b].onListeningChange;
          v(h);
        });
      }
    }, {
      key: "emitMicrophoneAvailabilityChange",
      value: function(h) {
        var g = this;
        this.isMicrophoneAvailable = h, Object.keys(this.subscribers).forEach(function(b) {
          var v = g.subscribers[b].onMicrophoneAvailabilityChange;
          v(h);
        });
      }
    }, {
      key: "emitTranscriptChange",
      value: function(h, g) {
        var b = this;
        Object.keys(this.subscribers).forEach(function(v) {
          var x = b.subscribers[v].onTranscriptChange;
          x(h, g);
        });
      }
    }, {
      key: "emitClearTranscript",
      value: function() {
        var h = this;
        Object.keys(this.subscribers).forEach(function(g) {
          var b = h.subscribers[g].onClearTranscript;
          b();
        });
      }
    }, {
      key: "emitBrowserSupportsSpeechRecognitionChange",
      value: function(h) {
        var g = this;
        Object.keys(this.subscribers).forEach(function(b) {
          var v = g.subscribers[b], x = v.onBrowserSupportsSpeechRecognitionChange, E = v.onBrowserSupportsContinuousListeningChange;
          x(h), E(h);
        });
      }
    }, {
      key: "disconnect",
      value: function(h) {
        if (this.recognition && this.listening)
          switch (h) {
            case "ABORT":
              this.pauseAfterDisconnect = !0, this.abort();
              break;
            case "RESET":
              this.pauseAfterDisconnect = !1, this.abort();
              break;
            case "STOP":
            default:
              this.pauseAfterDisconnect = !0, this.stop();
          }
      }
    }, {
      key: "disableRecognition",
      value: function() {
        this.recognition && (this.recognition.onresult = function() {
        }, this.recognition.onend = function() {
        }, this.recognition.onerror = function() {
        }, this.listening && this.stopListening());
      }
    }, {
      key: "onError",
      value: function(h) {
        h && h.error && h.error === "not-allowed" && (this.emitMicrophoneAvailabilityChange(!1), this.disableRecognition());
      }
    }, {
      key: "onRecognitionDisconnect",
      value: function() {
        this.onStopListening(), this.listening = !1, this.pauseAfterDisconnect ? this.emitListeningChange(!1) : this.recognition && (this.recognition.continuous ? this.startListening({
          continuous: this.recognition.continuous
        }) : this.emitListeningChange(!1)), this.pauseAfterDisconnect = !1;
      }
    }, {
      key: "updateTranscript",
      value: function(h) {
        var g = h.results, b = h.resultIndex, v = b === void 0 ? g.length - 1 : b;
        this.interimTranscript = "", this.finalTranscript = "";
        for (var x = v; x < g.length; ++x)
          g[x].isFinal && (!(0, t.default)() || g[x][0].confidence > 0) ? this.updateFinalTranscript(g[x][0].transcript) : this.interimTranscript = (0, n.concatTranscripts)(this.interimTranscript, g[x][0].transcript);
        var E = !1;
        this.interimTranscript === "" && this.finalTranscript !== "" ? (this.previousResultWasFinalOnly && (E = !0), this.previousResultWasFinalOnly = !0) : this.previousResultWasFinalOnly = !1, E || this.emitTranscriptChange(this.interimTranscript, this.finalTranscript);
      }
    }, {
      key: "updateFinalTranscript",
      value: function(h) {
        this.finalTranscript = (0, n.concatTranscripts)(this.finalTranscript, h);
      }
    }, {
      key: "resetTranscript",
      value: function() {
        this.disconnect("RESET");
      }
    }, {
      key: "startListening",
      value: function() {
        var p = s(/* @__PURE__ */ regeneratorRuntime.mark(function g() {
          var b, v, x, E, S, $, U = arguments;
          return regeneratorRuntime.wrap(function(j) {
            for (; ; )
              switch (j.prev = j.next) {
                case 0:
                  if (b = U.length > 0 && U[0] !== void 0 ? U[0] : {}, v = b.continuous, x = v === void 0 ? !1 : v, E = b.language, this.recognition) {
                    j.next = 3;
                    break;
                  }
                  return j.abrupt("return");
                case 3:
                  if (S = x !== this.recognition.continuous, $ = E && E !== this.recognition.lang, !(S || $)) {
                    j.next = 11;
                    break;
                  }
                  if (!this.listening) {
                    j.next = 9;
                    break;
                  }
                  return j.next = 9, this.stopListening();
                case 9:
                  this.recognition.continuous = S ? x : this.recognition.continuous, this.recognition.lang = $ ? E : this.recognition.lang;
                case 11:
                  if (this.listening) {
                    j.next = 22;
                    break;
                  }
                  return this.recognition.continuous || (this.resetTranscript(), this.emitClearTranscript()), j.prev = 13, j.next = 16, this.start();
                case 16:
                  this.emitListeningChange(!0), j.next = 22;
                  break;
                case 19:
                  j.prev = 19, j.t0 = j.catch(13), j.t0 instanceof DOMException || this.emitMicrophoneAvailabilityChange(!1);
                case 22:
                case "end":
                  return j.stop();
              }
          }, g, this, [[13, 19]]);
        }));
        function h() {
          return p.apply(this, arguments);
        }
        return h;
      }()
    }, {
      key: "abortListening",
      value: function() {
        var p = s(/* @__PURE__ */ regeneratorRuntime.mark(function g() {
          var b = this;
          return regeneratorRuntime.wrap(function(x) {
            for (; ; )
              switch (x.prev = x.next) {
                case 0:
                  return this.disconnect("ABORT"), this.emitListeningChange(!1), x.next = 4, new Promise(function(E) {
                    b.onStopListening = E;
                  });
                case 4:
                case "end":
                  return x.stop();
              }
          }, g, this);
        }));
        function h() {
          return p.apply(this, arguments);
        }
        return h;
      }()
    }, {
      key: "stopListening",
      value: function() {
        var p = s(/* @__PURE__ */ regeneratorRuntime.mark(function g() {
          var b = this;
          return regeneratorRuntime.wrap(function(x) {
            for (; ; )
              switch (x.prev = x.next) {
                case 0:
                  return this.disconnect("STOP"), this.emitListeningChange(!1), x.next = 4, new Promise(function(E) {
                    b.onStopListening = E;
                  });
                case 4:
                case "end":
                  return x.stop();
              }
          }, g, this);
        }));
        function h() {
          return p.apply(this, arguments);
        }
        return h;
      }()
    }, {
      key: "getRecognition",
      value: function() {
        return this.recognition;
      }
    }, {
      key: "start",
      value: function() {
        var p = s(/* @__PURE__ */ regeneratorRuntime.mark(function g() {
          return regeneratorRuntime.wrap(function(v) {
            for (; ; )
              switch (v.prev = v.next) {
                case 0:
                  if (!(this.recognition && !this.listening)) {
                    v.next = 4;
                    break;
                  }
                  return v.next = 3, this.recognition.start();
                case 3:
                  this.listening = !0;
                case 4:
                case "end":
                  return v.stop();
              }
          }, g, this);
        }));
        function h() {
          return p.apply(this, arguments);
        }
        return h;
      }()
    }, {
      key: "stop",
      value: function() {
        this.recognition && this.listening && (this.recognition.stop(), this.listening = !1);
      }
    }, {
      key: "abort",
      value: function() {
        this.recognition && this.listening && (this.recognition.abort(), this.listening = !1);
      }
    }]), f;
  }();
  e.default = c;
})(g1);
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = e.useSpeechRecognition = void 0;
  var t = dn, n = Pn, r = Mi, a = Nu, i = u(g1), s = u(kf), o = u(Lf);
  function u(z) {
    return z && z.__esModule ? z : { default: z };
  }
  function V(z, H, P, N, K, D, J) {
    try {
      var ee = z[D](J), C = ee.value;
    } catch (ge) {
      P(ge);
      return;
    }
    ee.done ? H(C) : Promise.resolve(C).then(N, K);
  }
  function c(z) {
    return function() {
      var H = this, P = arguments;
      return new Promise(function(N, K) {
        var D = z.apply(H, P);
        function J(C) {
          V(D, N, K, J, ee, "next", C);
        }
        function ee(C) {
          V(D, N, K, J, ee, "throw", C);
        }
        J(void 0);
      });
    };
  }
  function f(z) {
    return g(z) || h(z) || E(z) || p();
  }
  function p() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function h(z) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(z))
      return Array.from(z);
  }
  function g(z) {
    if (Array.isArray(z))
      return S(z);
  }
  function b(z) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? b = function(P) {
      return typeof P;
    } : b = function(P) {
      return P && typeof Symbol == "function" && P.constructor === Symbol && P !== Symbol.prototype ? "symbol" : typeof P;
    }, b(z);
  }
  function v(z, H) {
    return U(z) || $(z, H) || E(z, H) || x();
  }
  function x() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function E(z, H) {
    if (z) {
      if (typeof z == "string")
        return S(z, H);
      var P = Object.prototype.toString.call(z).slice(8, -1);
      if (P === "Object" && z.constructor && (P = z.constructor.name), P === "Map" || P === "Set")
        return Array.from(z);
      if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
        return S(z, H);
    }
  }
  function S(z, H) {
    (H == null || H > z.length) && (H = z.length);
    for (var P = 0, N = new Array(H); P < H; P++)
      N[P] = z[P];
    return N;
  }
  function $(z, H) {
    if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(z)))) {
      var P = [], N = !0, K = !1, D = void 0;
      try {
        for (var J = z[Symbol.iterator](), ee; !(N = (ee = J.next()).done) && (P.push(ee.value), !(H && P.length === H)); N = !0)
          ;
      } catch (C) {
        K = !0, D = C;
      } finally {
        try {
          !N && J.return != null && J.return();
        } finally {
          if (K)
            throw D;
        }
      }
      return P;
    }
  }
  function U(z) {
    if (Array.isArray(z))
      return z;
  }
  var y = !!o.default, j = y && !(0, s.default)(), q, Q = function() {
    var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, P = H.transcribing, N = P === void 0 ? !0 : P, K = H.clearTranscriptOnListen, D = K === void 0 ? !0 : K, J = H.commands, ee = J === void 0 ? [] : J, C = (0, t.useState)(I.getRecognitionManager()), ge = v(C, 1), pe = ge[0], w = (0, t.useState)(y), De = v(w, 2), $e = De[0], Me = De[1], ct = (0, t.useState)(j), Ye = v(ct, 2), Oe = Ye[0], We = Ye[1], At = (0, t.useReducer)(a.transcriptReducer, {
      interimTranscript: pe.interimTranscript,
      finalTranscript: ""
    }), xt = v(At, 2), en = xt[0], tn = en.interimTranscript, An = en.finalTranscript, En = xt[1], Xn = (0, t.useState)(pe.listening), vn = v(Xn, 2), rr = vn[0], Tn = vn[1], Kn = (0, t.useState)(pe.isMicrophoneAvailable), ln = v(Kn, 2), Mn = ln[0], ar = ln[1], te = (0, t.useRef)(ee);
    te.current = ee;
    var de = function() {
      En((0, r.clearTranscript)());
    }, xe = (0, t.useCallback)(function() {
      pe.resetTranscript(), de();
    }, [pe]), Ie = function(rt, Ft, Nt) {
      var yn = b(rt) === "object" ? rt.toString() : rt, ir = yn.replace(/[&/\\#,+()!$~%.'":*?<>{}]/g, "").replace(/  +/g, " ").trim(), Zn = (0, n.compareTwoStringsUsingDiceCoefficient)(ir, Ft);
      return Zn >= Nt ? {
        command: rt,
        commandWithoutSpecials: ir,
        howSimilar: Zn,
        isFuzzyMatch: !0
      } : null;
    }, He = function(rt, Ft) {
      var Nt = (0, n.commandToRegExp)(rt), yn = Nt.exec(Ft);
      return yn ? {
        command: rt,
        parameters: yn.slice(1)
      } : null;
    }, Dt = (0, t.useCallback)(function(Ot, rt) {
      te.current.forEach(function(Ft) {
        var Nt = Ft.command, yn = Ft.callback, ir = Ft.matchInterim, Zn = ir === void 0 ? !1 : ir, _a = Ft.isFuzzyMatch, sr = _a === void 0 ? !1 : _a, na = Ft.fuzzyMatchingThreshold, Ca = na === void 0 ? 0.8 : na, Sa = Ft.bestMatchOnly, Ji = Sa === void 0 ? !1 : Sa, Fr = !rt && Zn ? Ot.trim() : rt.trim(), es = Array.isArray(Nt) ? Nt : [Nt], Br = es.map(function(nn) {
          return sr ? Ie(nn, Fr, Ca) : He(nn, Fr);
        }).filter(function(nn) {
          return nn;
        });
        if (sr && Ji && Br.length >= 2) {
          Br.sort(function(nn, Oa) {
            return Oa.howSimilar - nn.howSimilar;
          });
          var ra = Br[0], ts = ra.command, ui = ra.commandWithoutSpecials, xa = ra.howSimilar;
          yn(ui, Fr, xa, {
            command: ts,
            resetTranscript: xe
          });
        } else
          Br.forEach(function(nn) {
            if (nn.isFuzzyMatch) {
              var Oa = nn.command, ns = nn.commandWithoutSpecials, aa = nn.howSimilar;
              yn(ns, Fr, aa, {
                command: Oa,
                resetTranscript: xe
              });
            } else {
              var L = nn.command, oe = nn.parameters;
              yn.apply(void 0, f(oe).concat([{
                command: L,
                resetTranscript: xe
              }]));
            }
          });
      });
    }, [xe]), Mt = (0, t.useCallback)(function(Ot, rt) {
      N && En((0, r.appendTranscript)(Ot, rt)), Dt(Ot, rt);
    }, [Dt, N]), Yt = (0, t.useCallback)(function() {
      D && de();
    }, [D]);
    (0, t.useEffect)(function() {
      var Ot = I.counter;
      I.counter += 1;
      var rt = {
        onListeningChange: Tn,
        onMicrophoneAvailabilityChange: ar,
        onTranscriptChange: Mt,
        onClearTranscript: Yt,
        onBrowserSupportsSpeechRecognitionChange: Me,
        onBrowserSupportsContinuousListeningChange: We
      };
      return pe.subscribe(Ot, rt), function() {
        pe.unsubscribe(Ot);
      };
    }, [N, D, pe, Mt, Yt]);
    var In = (0, n.concatTranscripts)(An, tn);
    return {
      transcript: In,
      interimTranscript: tn,
      finalTranscript: An,
      listening: rr,
      isMicrophoneAvailable: Mn,
      resetTranscript: xe,
      browserSupportsSpeechRecognition: $e,
      browserSupportsContinuousListening: Oe
    };
  };
  e.useSpeechRecognition = Q;
  var I = {
    counter: 0,
    applyPolyfill: function(H) {
      q ? q.setSpeechRecognition(H) : q = new i.default(H);
      var P = !!H && (0, n.browserSupportsPolyfills)();
      y = P, j = P;
    },
    removePolyfill: function() {
      q ? q.setSpeechRecognition(o.default) : q = new i.default(o.default), y = !!o.default, j = y && !(0, s.default)();
    },
    getRecognitionManager: function() {
      return q || (q = new i.default(o.default)), q;
    },
    getRecognition: function() {
      var H = I.getRecognitionManager();
      return H.getRecognition();
    },
    startListening: function() {
      var z = c(/* @__PURE__ */ regeneratorRuntime.mark(function P() {
        var N, K, D, J, ee = arguments;
        return regeneratorRuntime.wrap(function(ge) {
          for (; ; )
            switch (ge.prev = ge.next) {
              case 0:
                return N = ee.length > 0 && ee[0] !== void 0 ? ee[0] : {}, K = N.continuous, D = N.language, J = I.getRecognitionManager(), ge.next = 4, J.startListening({
                  continuous: K,
                  language: D
                });
              case 4:
              case "end":
                return ge.stop();
            }
        }, P);
      }));
      function H() {
        return z.apply(this, arguments);
      }
      return H;
    }(),
    stopListening: function() {
      var z = c(/* @__PURE__ */ regeneratorRuntime.mark(function P() {
        var N;
        return regeneratorRuntime.wrap(function(D) {
          for (; ; )
            switch (D.prev = D.next) {
              case 0:
                return N = I.getRecognitionManager(), D.next = 3, N.stopListening();
              case 3:
              case "end":
                return D.stop();
            }
        }, P);
      }));
      function H() {
        return z.apply(this, arguments);
      }
      return H;
    }(),
    abortListening: function() {
      var z = c(/* @__PURE__ */ regeneratorRuntime.mark(function P() {
        var N;
        return regeneratorRuntime.wrap(function(D) {
          for (; ; )
            switch (D.prev = D.next) {
              case 0:
                return N = I.getRecognitionManager(), D.next = 3, N.abortListening();
              case 3:
              case "end":
                return D.stop();
            }
        }, P);
      }));
      function H() {
        return z.apply(this, arguments);
      }
      return H;
    }(),
    browserSupportsSpeechRecognition: function() {
      return y;
    },
    browserSupportsContinuousListening: function() {
      return j;
    }
  }, ie = I;
  e.default = ie;
})(m1);
(function(e) {
  function t(s) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? t = function(u) {
      return typeof u;
    } : t = function(u) {
      return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
    }, t(s);
  }
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), Object.defineProperty(e, "useSpeechRecognition", {
    enumerable: !0,
    get: function() {
      return n.useSpeechRecognition;
    }
  }), e.default = void 0;
  var n = a(m1);
  function r() {
    if (typeof WeakMap != "function")
      return null;
    var s = /* @__PURE__ */ new WeakMap();
    return r = function() {
      return s;
    }, s;
  }
  function a(s) {
    if (s && s.__esModule)
      return s;
    if (s === null || t(s) !== "object" && typeof s != "function")
      return { default: s };
    var o = r();
    if (o && o.has(s))
      return o.get(s);
    var u = {}, V = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var c in s)
      if (Object.prototype.hasOwnProperty.call(s, c)) {
        var f = V ? Object.getOwnPropertyDescriptor(s, c) : null;
        f && (f.get || f.set) ? Object.defineProperty(u, c, f) : u[c] = s[c];
      }
    return u.default = s, o && o.set(s, u), u;
  }
  var i = n.default;
  e.default = i;
})(Nf);
const em = /* @__PURE__ */ pn(Nf), n5 = ({
  onSend: e,
  onValueChange: t,
  customSpeechRecognition: n
}) => {
  const r = un(null), a = Nf.useSpeechRecognition({ clearTranscriptOnListen: !0 }), i = a.browserSupportsSpeechRecognition && qC(), s = !!n && (n.overrideNative || !i), o = un(
    s ? n.initialState.listening : a.listening
  ), u = un(
    s ? n.initialState.processing : !1
  ), V = un(e);
  V.current = e;
  const [c, f] = Jt(
    s ? n.initialState : {
      listening: a.listening,
      transcript: a.transcript,
      processing: !1,
      initializing: !1,
      microphoneAvailable: a.isMicrophoneAvailable
    }
  ), p = () => {
    s ? (n.resetTranscript(), n.startListening()) : (a.resetTranscript(), em.startListening({ continuous: !0 }));
  }, h = () => {
    s ? n.stopListening() : em.stopListening();
  };
  return Kc(() => {
    s || !a.listening || t(a.transcript);
  }, [s, a.transcript]), Gn(() => {
    var g, b, v, x;
    s ? (u.current && !c.processing && ((g = V.current) == null || g.call(V), n.resetTranscript(), (b = r.current) == null || b.focus()), u.current = c.processing) : (o.current && !a.listening && ((v = V.current) == null || v.call(V), a.resetTranscript(), (x = r.current) == null || x.focus()), o.current = a.listening);
  }, [s, a.listening, c.processing]), Gn(() => {
    if (s)
      return n.onStateChange((g) => {
        t(g.transcript), f(g);
      });
  }, [s]), {
    available: s || i,
    listening: s ? c.listening : a.listening,
    processing: s ? c.processing : !1,
    textareaRef: r,
    initializing: s ? c.initializing : !1,
    stopListening: h,
    startListening: p,
    microphoneAvailable: s ? c.microphoneAvailable : a.isMicrophoneAvailable
  };
}, tm = ({
  id: e,
  onSend: t,
  placeholder: n,
  disableSend: r,
  onValueChange: a,
  audioInterface: i,
  speechRecognition: s,
  ...o
}) => {
  const u = Jr(() => `vf-chat-input--${Hs()}`, []) ?? e, V = n5({ onSend: t, onValueChange: a, customSpeechRecognition: s }), c = (g) => {
    g.stopPropagation();
    const { shiftKey: b } = g;
    g.key === "Enter" && g.key === "Enter" && !b && (g.preventDefault(), t == null || t());
  }, f = !!o.value && !r && !V.listening, p = V.available && V.microphoneAvailable && i && !f, h = () => V.initializing ? "Initializing..." : V.listening ? "Listening..." : V.processing ? "Processing..." : n;
  return /* @__PURE__ */ X.jsxs(h1, { children: [
    /* @__PURE__ */ X.jsx(
      Io,
      {
        id: u,
        ref: V.textareaRef,
        readOnly: V.initializing || V.processing || V.listening,
        onKeyDown: c,
        placeholder: h(),
        onValueChange: a,
        ...o
      }
    ),
    /* @__PURE__ */ X.jsx(su, { htmlFor: u, ready: f, children: /* @__PURE__ */ X.jsx(rl, { size: "small", svg: "smallArrowUp", onClick: t }) }),
    p && /* @__PURE__ */ X.jsx(
      Bk,
      {
        onStop: V.stopListening,
        onStart: V.startListening,
        listening: V.listening,
        processing: V.processing,
        initializing: V.initializing
      }
    )
  ] });
}, r5 = Object.assign(tm, {
  Controlled: Of(tm, {
    defaultValue: "",
    enrichProps: (e, [, t]) => ({
      ...e,
      onSend: () => {
        var n;
        t(""), (n = e.onSend) == null || n.call(e);
      }
    })
  }),
  Container: h1,
  ButtonContainer: su
}), a5 = _t(vt.INPUT), i5 = {
  height: "$md",
  boxSizing: "border-box",
  border: "1px solid rgba(115,115,118,0.3)",
  borderRadius: "$1",
  backgroundColor: "$white",
  boxShadow: "0 1px 12px $shadow2",
  trans: ["border-color"]
}, s5 = {
  border: "1px solid rgba(115,115,118,0.5)"
}, b1 = Te(a5("input"), {
  ...i5,
  padding: "0 $4",
  typo: {},
  color: "$black",
  "&:focus": {
    ...s5,
    outline: 0
  },
  "&::placeholder": {
    color: "$darkGrey"
  }
}), nm = ({ onValueChange: e, onChange: t, ...n }) => {
  const r = wf(t, (a) => e(a.target.value));
  return /* @__PURE__ */ X.jsx(b1, { ...n, onChange: r });
}, o5 = Object.assign(nm, {
  Controlled: Of(nm, { defaultValue: "" }),
  Container: b1
}), A1 = _t(vt.FOOTER), E1 = Te(A1("footer"), {
  padding: "$3 $4 $4 $4",
  borderRadius: "$1",
  [`& ${o5.Container}`]: {
    flex: 1
  },
  [`& ${tr.Container}`]: {
    width: "100%"
  },
  variants: {
    withShadow: {
      true: {
        boxShadow: "0 12px 48px $shadow16"
      }
    },
    withWatermark: {
      true: {
        paddingBottom: "0"
      }
    }
  }
}), v1 = Te(A1("aside", "watermark"), {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  padding: "10px 0 $3 0",
  typo: { size: 12, height: "17px" },
  color: "$darkGrey",
  "& a": {
    marginLeft: "0.5ch",
    textDecoration: "none",
    color: "$blue",
    "&:focus": {
      outline: 0
    }
  }
}), u5 = ({
  withWatermark: e,
  hasEnded: t,
  disableSend: n,
  onStart: r,
  onSend: a,
  audioInterface: i,
  speechRecognition: s
}) => {
  const [o, u] = Jt(""), V = async () => {
    !o || n || (u(""), await (a == null ? void 0 : a(o)));
  };
  return /* @__PURE__ */ X.jsxs(E1, { withShadow: !!t, withWatermark: e, children: [
    t ? /* @__PURE__ */ X.jsx(tr, { onClick: r, children: "Start New Chat" }) : /* @__PURE__ */ X.jsx(
      r5,
      {
        value: o,
        placeholder: "Message",
        autoFocus: !0,
        onValueChange: u,
        onSend: V,
        disableSend: n,
        audioInterface: i,
        speechRecognition: s
      }
    ),
    e && /* @__PURE__ */ X.jsxs(v1, { children: [
      "Assistant  by",
      /* @__PURE__ */ X.jsx("a", { target: "_blank", href: "https://aiautomatisering.net/", rel: "noreferrer", children: "AI Automatisering" })
    ] })
  ] });
}, T1 = Object.assign(u5, {
  Container: E1,
  Watermark: v1
}), Pf = _t(vt.HEADER), Df = Te(Pf("h1", "title"), {
  ...Bp,
  typo: { size: 17, weight: "$2", height: "$2" },
  color: "rgba(255,255,255,0.95)"
}), y1 = Te(Pf(tr.Reset, "button"), {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  height: 32,
  width: 32,
  marginLeft: 8,
  borderRadius: 6,
  background: "none",
  trans: ["background-color"],
  "&:hover": {
    backgroundColor: "rgba(255,255,255,0.16)",
    [`& ${zt.Frame}`]: {
      color: "$white"
    }
  },
  [`& ${zt.Frame}`]: {
    height: "$xxs",
    width: "$xxs",
    color: "rgba(255,255,255,0.8)",
    trans: ["color"]
  }
}), _1 = Te(Pf("header"), {
  display: "flex",
  flexShrink: 0,
  alignItems: "center",
  height: "$lg",
  padding: "0 $4 0 $5",
  backgroundColor: "$primary",
  boxShadow: "0 1px 2px $shadow16",
  [`& ${ba.Container}`]: {
    height: 32,
    width: 32
  },
  [`& ${Df}`]: {
    flex: 1,
    margin: "0 0 0 14px"
  }
}), V5 = ({ title: e, image: t, actions: n = [] }) => /* @__PURE__ */ X.jsxs(_1, { children: [
  /* @__PURE__ */ X.jsx(ba, { avatar: t }),
  /* @__PURE__ */ X.jsx(Df, { children: e }),
  n.map(({ svg: r, onClick: a }, i) => /* @__PURE__ */ X.jsx(y1, { onClick: a, children: /* @__PURE__ */ X.jsx(zt, { svg: r }) }, i))
] }), C1 = Object.assign(V5, {
  Container: _1,
  Title: Df,
  Button: y1
}), rm = 32, l5 = 1e3, c5 = _t(vt.LOADER), S1 = Te(c5("div"), {
  height: rm,
  width: rm,
  borderWidth: "2px",
  borderStyle: "solid",
  borderRadius: "$round",
  borderColor: "#f0f0f0",
  borderTopColor: "#000",
  animation: `${z2} ${l5}ms linear`,
  animationIterationCount: "infinite"
}), f5 = _t(vt.PROMPT), x1 = Te(f5("div"), {
  padding: "$4 $4 $3 $4",
  borderRadius: "$1",
  backgroundColor: "$white",
  boxShadow: "0 12px 48px 4px $shadow12",
  [`& ${tr.Container}`]: {
    width: "100%",
    marginTop: "$1",
    "&:first-of-type": {
      marginTop: 0
    }
  }
}), d5 = ({ accept: e, cancel: t }) => /* @__PURE__ */ X.jsxs(x1, { children: [
  /* @__PURE__ */ X.jsx(tr.Primary, { tabIndex: -1, ...e, children: e.label }),
  /* @__PURE__ */ X.jsx(tr, { type: "subtle", tabIndex: -1, ...t, children: t.label })
] }), Ro = Object.assign(d5, {
  Container: x1
}), h5 = "voiceflow-chat-frame";
var ku = /* @__PURE__ */ ((e) => (e.EMBEDDED = "embedded", e.OVERLAY = "overlay", e))(ku || {});
const m5 = F.object({
  mode: F.nativeEnum(ku).default(
    "overlay"
    /* OVERLAY */
  ),
  target: F.instanceof(HTMLElement).optional().transform((e) => e ?? document.getElementById(h5) ?? void 0)
}).optional().transform((e) => {
  if (e != null && e.target && e.mode !== "embedded" && console.warn(`render.target has no effect in ${e.mode} mode.`), (e == null ? void 0 : e.mode) === "embedded") {
    if (e.target)
      return {
        mode: "embedded",
        target: e.target
      };
    console.error("No valid target found for embedded mode. Defaulting to overlay mode.");
  }
  return {
    mode: "overlay"
    /* OVERLAY */
  };
});
var O1 = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    var n = 1e3, r = 6e4, a = 36e5, i = "millisecond", s = "second", o = "minute", u = "hour", V = "day", c = "week", f = "month", p = "quarter", h = "year", g = "date", b = "Invalid Date", v = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, x = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, E = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, S = function(H, P, N) {
      var K = String(H);
      return !K || K.length >= P ? H : "" + Array(P + 1 - K.length).join(N) + H;
    }, $ = { s: S, z: function(H) {
      var P = -H.utcOffset(), N = Math.abs(P), K = Math.floor(N / 60), D = N % 60;
      return (P <= 0 ? "+" : "-") + S(K, 2, "0") + ":" + S(D, 2, "0");
    }, m: function H(P, N) {
      if (P.date() < N.date())
        return -H(N, P);
      var K = 12 * (N.year() - P.year()) + (N.month() - P.month()), D = P.clone().add(K, f), J = N - D < 0, ee = P.clone().add(K + (J ? -1 : 1), f);
      return +(-(K + (N - D) / (J ? D - ee : ee - D)) || 0);
    }, a: function(H) {
      return H < 0 ? Math.ceil(H) || 0 : Math.floor(H);
    }, p: function(H) {
      return { M: f, y: h, w: c, d: V, D: g, h: u, m: o, s, ms: i, Q: p }[H] || String(H || "").toLowerCase().replace(/s$/, "");
    }, u: function(H) {
      return H === void 0;
    } }, U = "en", y = {};
    y[U] = E;
    var j = function(H) {
      return H instanceof ie;
    }, q = function H(P, N, K) {
      var D;
      if (!P)
        return U;
      if (typeof P == "string") {
        var J = P.toLowerCase();
        y[J] && (D = J), N && (y[J] = N, D = J);
        var ee = P.split("-");
        if (!D && ee.length > 1)
          return H(ee[0]);
      } else {
        var C = P.name;
        y[C] = P, D = C;
      }
      return !K && D && (U = D), D || !K && U;
    }, Q = function(H, P) {
      if (j(H))
        return H.clone();
      var N = typeof P == "object" ? P : {};
      return N.date = H, N.args = arguments, new ie(N);
    }, I = $;
    I.l = q, I.i = j, I.w = function(H, P) {
      return Q(H, { locale: P.$L, utc: P.$u, x: P.$x, $offset: P.$offset });
    };
    var ie = function() {
      function H(N) {
        this.$L = q(N.locale, null, !0), this.parse(N);
      }
      var P = H.prototype;
      return P.parse = function(N) {
        this.$d = function(K) {
          var D = K.date, J = K.utc;
          if (D === null)
            return /* @__PURE__ */ new Date(NaN);
          if (I.u(D))
            return /* @__PURE__ */ new Date();
          if (D instanceof Date)
            return new Date(D);
          if (typeof D == "string" && !/Z$/i.test(D)) {
            var ee = D.match(v);
            if (ee) {
              var C = ee[2] - 1 || 0, ge = (ee[7] || "0").substring(0, 3);
              return J ? new Date(Date.UTC(ee[1], C, ee[3] || 1, ee[4] || 0, ee[5] || 0, ee[6] || 0, ge)) : new Date(ee[1], C, ee[3] || 1, ee[4] || 0, ee[5] || 0, ee[6] || 0, ge);
            }
          }
          return new Date(D);
        }(N), this.$x = N.x || {}, this.init();
      }, P.init = function() {
        var N = this.$d;
        this.$y = N.getFullYear(), this.$M = N.getMonth(), this.$D = N.getDate(), this.$W = N.getDay(), this.$H = N.getHours(), this.$m = N.getMinutes(), this.$s = N.getSeconds(), this.$ms = N.getMilliseconds();
      }, P.$utils = function() {
        return I;
      }, P.isValid = function() {
        return this.$d.toString() !== b;
      }, P.isSame = function(N, K) {
        var D = Q(N);
        return this.startOf(K) <= D && D <= this.endOf(K);
      }, P.isAfter = function(N, K) {
        return Q(N) < this.startOf(K);
      }, P.isBefore = function(N, K) {
        return this.endOf(K) < Q(N);
      }, P.$g = function(N, K, D) {
        return I.u(N) ? this[K] : this.set(D, N);
      }, P.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, P.valueOf = function() {
        return this.$d.getTime();
      }, P.startOf = function(N, K) {
        var D = this, J = !!I.u(K) || K, ee = I.p(N), C = function(Ye, Oe) {
          var We = I.w(D.$u ? Date.UTC(D.$y, Oe, Ye) : new Date(D.$y, Oe, Ye), D);
          return J ? We : We.endOf(V);
        }, ge = function(Ye, Oe) {
          return I.w(D.toDate()[Ye].apply(D.toDate("s"), (J ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Oe)), D);
        }, pe = this.$W, w = this.$M, De = this.$D, $e = "set" + (this.$u ? "UTC" : "");
        switch (ee) {
          case h:
            return J ? C(1, 0) : C(31, 11);
          case f:
            return J ? C(1, w) : C(0, w + 1);
          case c:
            var Me = this.$locale().weekStart || 0, ct = (pe < Me ? pe + 7 : pe) - Me;
            return C(J ? De - ct : De + (6 - ct), w);
          case V:
          case g:
            return ge($e + "Hours", 0);
          case u:
            return ge($e + "Minutes", 1);
          case o:
            return ge($e + "Seconds", 2);
          case s:
            return ge($e + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, P.endOf = function(N) {
        return this.startOf(N, !1);
      }, P.$set = function(N, K) {
        var D, J = I.p(N), ee = "set" + (this.$u ? "UTC" : ""), C = (D = {}, D[V] = ee + "Date", D[g] = ee + "Date", D[f] = ee + "Month", D[h] = ee + "FullYear", D[u] = ee + "Hours", D[o] = ee + "Minutes", D[s] = ee + "Seconds", D[i] = ee + "Milliseconds", D)[J], ge = J === V ? this.$D + (K - this.$W) : K;
        if (J === f || J === h) {
          var pe = this.clone().set(g, 1);
          pe.$d[C](ge), pe.init(), this.$d = pe.set(g, Math.min(this.$D, pe.daysInMonth())).$d;
        } else
          C && this.$d[C](ge);
        return this.init(), this;
      }, P.set = function(N, K) {
        return this.clone().$set(N, K);
      }, P.get = function(N) {
        return this[I.p(N)]();
      }, P.add = function(N, K) {
        var D, J = this;
        N = Number(N);
        var ee = I.p(K), C = function(w) {
          var De = Q(J);
          return I.w(De.date(De.date() + Math.round(w * N)), J);
        };
        if (ee === f)
          return this.set(f, this.$M + N);
        if (ee === h)
          return this.set(h, this.$y + N);
        if (ee === V)
          return C(1);
        if (ee === c)
          return C(7);
        var ge = (D = {}, D[o] = r, D[u] = a, D[s] = n, D)[ee] || 1, pe = this.$d.getTime() + N * ge;
        return I.w(pe, this);
      }, P.subtract = function(N, K) {
        return this.add(-1 * N, K);
      }, P.format = function(N) {
        var K = this, D = this.$locale();
        if (!this.isValid())
          return D.invalidDate || b;
        var J = N || "YYYY-MM-DDTHH:mm:ssZ", ee = I.z(this), C = this.$H, ge = this.$m, pe = this.$M, w = D.weekdays, De = D.months, $e = function(Oe, We, At, xt) {
          return Oe && (Oe[We] || Oe(K, J)) || At[We].slice(0, xt);
        }, Me = function(Oe) {
          return I.s(C % 12 || 12, Oe, "0");
        }, ct = D.meridiem || function(Oe, We, At) {
          var xt = Oe < 12 ? "AM" : "PM";
          return At ? xt.toLowerCase() : xt;
        }, Ye = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: pe + 1, MM: I.s(pe + 1, 2, "0"), MMM: $e(D.monthsShort, pe, De, 3), MMMM: $e(De, pe), D: this.$D, DD: I.s(this.$D, 2, "0"), d: String(this.$W), dd: $e(D.weekdaysMin, this.$W, w, 2), ddd: $e(D.weekdaysShort, this.$W, w, 3), dddd: w[this.$W], H: String(C), HH: I.s(C, 2, "0"), h: Me(1), hh: Me(2), a: ct(C, ge, !0), A: ct(C, ge, !1), m: String(ge), mm: I.s(ge, 2, "0"), s: String(this.$s), ss: I.s(this.$s, 2, "0"), SSS: I.s(this.$ms, 3, "0"), Z: ee };
        return J.replace(x, function(Oe, We) {
          return We || Ye[Oe] || ee.replace(":", "");
        });
      }, P.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, P.diff = function(N, K, D) {
        var J, ee = I.p(K), C = Q(N), ge = (C.utcOffset() - this.utcOffset()) * r, pe = this - C, w = I.m(this, C);
        return w = (J = {}, J[h] = w / 12, J[f] = w, J[p] = w / 3, J[c] = (pe - ge) / 6048e5, J[V] = (pe - ge) / 864e5, J[u] = pe / a, J[o] = pe / r, J[s] = pe / n, J)[ee] || pe, D ? w : I.a(w);
      }, P.daysInMonth = function() {
        return this.endOf(f).$D;
      }, P.$locale = function() {
        return y[this.$L];
      }, P.locale = function(N, K) {
        if (!N)
          return this.$L;
        var D = this.clone(), J = q(N, K, !0);
        return J && (D.$L = J), D;
      }, P.clone = function() {
        return I.w(this.$d, this);
      }, P.toDate = function() {
        return new Date(this.valueOf());
      }, P.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, P.toISOString = function() {
        return this.$d.toISOString();
      }, P.toString = function() {
        return this.$d.toUTCString();
      }, H;
    }(), z = ie.prototype;
    return Q.prototype = z, [["$ms", i], ["$s", s], ["$m", o], ["$H", u], ["$W", V], ["$M", f], ["$y", h], ["$D", g]].forEach(function(H) {
      z[H[1]] = function(P) {
        return this.$g(P, H[0], H[1]);
      };
    }), Q.extend = function(H, P) {
      return H.$i || (H(P, ie, Q), H.$i = !0), Q;
    }, Q.locale = q, Q.isDayjs = j, Q.unix = function(H) {
      return Q(1e3 * H);
    }, Q.en = y[U], Q.Ls = y, Q.p = {}, Q;
  });
})(O1);
var p5 = O1.exports;
const wc = /* @__PURE__ */ pn(p5);
var w1 = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(bt, function() {
    return function(n, r, a) {
      n = n || {};
      var i = r.prototype, s = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function o(V, c, f, p) {
        return i.fromToBase(V, c, f, p);
      }
      a.en.relativeTime = s, i.fromToBase = function(V, c, f, p, h) {
        for (var g, b, v, x = f.$locale().relativeTime || s, E = n.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], S = E.length, $ = 0; $ < S; $ += 1) {
          var U = E[$];
          U.d && (g = p ? a(V).diff(f, U.d, !0) : f.diff(V, U.d, !0));
          var y = (n.rounding || Math.round)(Math.abs(g));
          if (v = g > 0, y <= U.r || !U.r) {
            y <= 1 && $ > 0 && (U = E[$ - 1]);
            var j = x[U.l];
            h && (y = h("" + y)), b = typeof j == "string" ? j.replace("%d", y) : j(y, c, U.l, v);
            break;
          }
        }
        if (c)
          return b;
        var q = v ? x.future : x.past;
        return typeof q == "function" ? q(b) : q.replace("%s", b);
      }, i.to = function(V, c) {
        return o(V, c, this, !0);
      }, i.from = function(V, c) {
        return o(V, c, this);
      };
      var u = function(V) {
        return V.$u ? a.utc() : a();
      };
      i.toNow = function(V) {
        return this.to(u(this), V);
      }, i.fromNow = function(V) {
        return this.from(u(this), V);
      };
    };
  });
})(w1);
var g5 = w1.exports;
const b5 = /* @__PURE__ */ pn(g5);
wc.extend(b5);
const A5 = (e) => Jr(() => {
  if (!e)
    return null;
  const t = wc(e), n = wc();
  switch (!0) {
    case n.isSame(t, "day"):
      return "Today";
    case n.subtract(1, "day").isSame(t, "day"):
      return "Yesterday";
    default:
      return t.fromNow();
  }
}, [e]), I1 = (e = []) => {
  const { scrollToBottom: t } = Yn(of);
  Kc(() => {
    t();
  }, e);
}, am = (e) => {
  const t = (n) => () => console.warn(e(n));
  return {
    open: t("open"),
    hide: t("hide"),
    show: t("show"),
    close: t("close"),
    interact: t("interact"),
    proactive: {
      clear: t("proactive.clear"),
      push: t("proactive.push")
    }
  };
}, R1 = (e, t, n) => Gn(() => {
  if (!Yy(e))
    return;
  const r = am((i) => `Method '${i}' has no effect in this mode.`), a = t();
  return Object.assign(e, {
    ...r,
    ...a,
    proactive: {
      ...r.proactive,
      ...a.proactive
    }
  }), n == null || n(), () => {
    const i = am(
      (s) => `Method '${s}' has no effect after 'destroy' has been called. Call 'load' to render the chat and restore this method.`
    );
    Object.assign(e, i);
  };
}, []), E5 = (e, t = []) => {
  const n = un(!1);
  Gn(() => {
    if (n.current)
      return e();
    n.current = !0;
  }, t);
}, N1 = (e) => {
  const [t, n] = Jt("");
  return Gn(() => {
    e != null && e.color && n(H2({ color: e.color }));
  }, [e == null ? void 0 : e.color]), t;
};
var ou = Symbol("@ts-pattern/matcher"), im = "@ts-pattern/anonymous-select-key", sm = function(e) {
  return !!(e && typeof e == "object");
}, RV = function(e) {
  return e && !!e[ou];
}, v5 = function e(t, n, r) {
  if (sm(t)) {
    if (RV(t)) {
      var a = t[ou]().match(n), i = a.matched, s = a.selections;
      return i && s && Object.keys(s).forEach(function(u) {
        return r(u, s[u]);
      }), i;
    }
    if (!sm(n))
      return !1;
    if (Array.isArray(t))
      return !!Array.isArray(n) && t.length === n.length && t.every(function(u, V) {
        return e(u, n[V], r);
      });
    if (t instanceof Map)
      return n instanceof Map && Array.from(t.keys()).every(function(u) {
        return e(t.get(u), n.get(u), r);
      });
    if (t instanceof Set) {
      if (!(n instanceof Set))
        return !1;
      if (t.size === 0)
        return n.size === 0;
      if (t.size === 1) {
        var o = Array.from(t.values())[0];
        return RV(o) ? Array.from(n.values()).every(function(u) {
          return e(o, u, r);
        }) : n.has(o);
      }
      return Array.from(t.values()).every(function(u) {
        return n.has(u);
      });
    }
    return Object.keys(t).every(function(u) {
      var V, c = t[u];
      return (u in n || RV(V = c) && V[ou]().matcherType === "optional") && e(c, n[u], r);
    });
  }
  return Object.is(n, t);
};
function ni(e) {
  var t;
  return (t = {})[ou] = function() {
    return { match: function(n) {
      return { matched: !!e(n) };
    } };
  }, t;
}
ni(function(e) {
  return !0;
});
ni(function(e) {
  return typeof e == "string";
});
ni(function(e) {
  return typeof e == "number";
});
ni(function(e) {
  return typeof e == "boolean";
});
ni(function(e) {
  return typeof e == "bigint";
});
ni(function(e) {
  return typeof e == "symbol";
});
ni(function(e) {
  return e == null;
});
function Lu(e) {
  return new T5(e, []);
}
var T5 = /* @__PURE__ */ function() {
  function e(n, r) {
    this.value = void 0, this.cases = void 0, this.value = n, this.cases = r;
  }
  var t = e.prototype;
  return t.with = function() {
    var n = [].slice.call(arguments), r = n[n.length - 1], a = [n[0]], i = [];
    return n.length === 3 && typeof n[1] == "function" ? (a.push(n[0]), i.push(n[1])) : n.length > 2 && a.push.apply(a, n.slice(1, n.length - 1)), new e(this.value, this.cases.concat([{ match: function(s) {
      var o = {}, u = !!(a.some(function(V) {
        return v5(V, s, function(c, f) {
          o[c] = f;
        });
      }) && i.every(function(V) {
        return V(s);
      }));
      return { matched: u, value: u && Object.keys(o).length ? im in o ? o[im] : o : s };
    }, handler: r }]));
  }, t.when = function(n, r) {
    return new e(this.value, this.cases.concat([{ match: function(a) {
      return { matched: !!n(a), value: a };
    }, handler: r }]));
  }, t.otherwise = function(n) {
    return new e(this.value, this.cases.concat([{ match: function(r) {
      return { matched: !0, value: r };
    }, handler: n }])).run();
  }, t.exhaustive = function() {
    return this.run();
  }, t.run = function() {
    for (var n = this.value, r = void 0, a = 0; a < this.cases.length; a++) {
      var i = this.cases[a], s = i.match(this.value);
      if (s.matched) {
        n = s.value, r = i.handler;
        break;
      }
    }
    if (!r) {
      var o;
      try {
        o = JSON.stringify(this.value);
      } catch {
        o = this.value;
      }
      throw new Error("Pattern matching error: no pattern matches value " + o);
    }
    return r(n, this.value);
  }, e;
}();
const y5 = (e = js) => ({
  type: "indicator",
  messageDelay: e
}), _5 = ({
  messages: e,
  isLast: t
}) => {
  const n = un(t && !!e.length), [r, a] = Jt(!n.current), [i, s] = Jt(n.current), [o, u] = Jt(n.current ? [] : e), V = qr(() => {
    a(!0), s(!1);
  }, []);
  return Gn(() => {
    if (!n)
      return;
    const c = e.flatMap((g) => [
      y5(g.delay),
      { type: "message", message: g }
    ]);
    let f;
    const p = (g, b) => {
      if (b === 0) {
        g();
        return;
      }
      f = setTimeout(() => {
        g();
      }, b);
    }, h = () => {
      if (!n.current)
        return;
      const g = c.shift();
      if (!g) {
        V();
        return;
      }
      Lu(g).with({
        type: "message"
        /* MESSAGE */
      }, ({ message: b }) => {
        s(!1), u((v) => [...v, b]), p(h, js);
      }).with({
        type: "indicator"
        /* INDICATOR */
      }, ({ messageDelay: b = js }) => {
        s(!0), p(h, b);
      }).exhaustive();
    };
    return h(), () => {
      clearTimeout(f);
    };
  }, []), E5(() => {
    t || (n.current = !1, V(), u(e));
  }, [t]), {
    complete: r,
    showIndicator: i,
    visibleMessages: o
  };
}, k1 = 1e3, L1 = _t(vt.TYPING_INDICATOR), P1 = Te(L1("span"), {
  display: "inline-flex"
}), D1 = Te(L1("span", "dot"), {
  height: 8,
  width: 8,
  margin: "0 2px",
  borderRadius: "$round",
  backgroundColor: "#adadb3",
  opacity: 0.2,
  animation: `${j2} ${k1}ms`,
  animationIterationCount: "infinite"
}), C5 = Math.floor(k1 / 3), S5 = () => /* @__PURE__ */ X.jsx(P1, { children: Array.from({ length: 3 }).map((e, t) => /* @__PURE__ */ X.jsx(D1, { css: { animationDelay: `${C5 * (t + 1)}ms` } }, t)) }), x5 = Object.assign(S5, {
  Container: P1,
  Dot: D1
}), Mf = _t(vt.MESSAGE), Ff = Te(Mf("div"), {
  display: "inline-block",
  boxSizing: "border-box",
  padding: "10px 14px",
  borderRadius: "$1",
  typo: {},
  overflowWrap: "anywhere"
}), M1 = Te(Mf(Ff, "chat"), {
  variants: {
    from: {
      system: {
        color: "$black",
        backgroundColor: "$lightGrey"
      },
      user: {
        color: "$white",
        backgroundColor: "$primary",
        whiteSpace: "break-spaces"
      }
    }
  }
});
var Xs = /* @__PURE__ */ ((e) => (e.CHAT = "chat", e.DEBUG = "debug", e))(Xs || {});
const om = 6, um = 32, F1 = Te(Mf(Ff, "debug"), {
  position: "relative",
  marginTop: om,
  border: "1px solid $medGrey",
  padding: "10px 14px",
  backgroundColor: "$white",
  boxShadow: "0 1px 2px $shadow2",
  svg: {
    position: "absolute",
    top: -om
  },
  variants: {
    orientation: {
      left: {
        svg: {
          left: um
        }
      },
      right: {
        svg: {
          right: um
        }
      }
    }
  },
  defaultVariants: {
    orientation: "left"
  }
}), O5 = ({ children: e, ...t }) => /* @__PURE__ */ X.jsxs(F1, { ...t, children: [
  /* @__PURE__ */ X.jsx(zp, {}),
  e
] }), B1 = Object.assign(O5, {
  Container: F1
}), w5 = {
  [Xs.CHAT]: M1,
  [Xs.DEBUG]: B1
}, I5 = Yp(w5, Xs.CHAT), Qr = Object.assign(I5, {
  Variant: Xs,
  Container: Ff,
  Chat: M1,
  Debug: B1
}), R5 = (e) => {
  const t = new Date(e), n = t.getHours(), r = t.getMinutes();
  return `${n % 12 || 12}:${r >= 10 ? "" : "0"}${r} ${n >= 12 ? "pm" : "am"}`;
}, N5 = _t(vt.TIMESTAMP), $1 = Te(N5("div"), {
  typo: { size: 12, height: "17px" },
  color: "$darkGrey",
  whiteSpace: "nowrap",
  flexShrink: 0
}), k5 = ({ value: e }) => /* @__PURE__ */ X.jsx($1, { children: R5(e) }), Qa = Object.assign(k5, {
  Container: $1
}), Wi = _t(vt.SYSTEM_RESPONSE), U1 = Te(Wi("div", "actions"), {
  display: "flex",
  flexWrap: "wrap",
  marginBottom: 8,
  padding: "0 $5 0 54px",
  [`& ${tr.Container}`]: {
    height: "unset",
    paddingTop: 7,
    paddingBottom: 7,
    marginTop: 8,
    marginRight: 8,
    whiteSpace: "normal",
    textAlign: "start"
  }
}), H1 = Te(Wi("span", "controls"), {
  position: "relative"
}), Bf = Te(Wi("div"), {
  display: "flex",
  [`& ${ba.Container}`]: {
    visibility: "hidden",
    alignSelf: "flex-end",
    margin: "0 8px 4px 0"
  },
  [`& ${Qa.Container}`]: {
    alignSelf: "center",
    whiteSpace: "nowrap",
    marginLeft: 8,
    opacity: "0%",
    trans: ["opacity"]
  },
  [`&:hover ${Qa.Container}`]: {
    opacity: "100%"
  },
  variants: {
    withImage: {
      true: {
        [`& ${ba.Container}`]: {
          visibility: "visible"
        }
      }
    },
    scrollable: {
      true: {
        overflowX: "scroll",
        flexShrink: 0,
        scrollbarWidth: "none",
        "-ms-overflow-style": "none",
        "&::-webkit-scrollbar": {
          display: "none"
        }
      }
    },
    center: {
      true: {
        alignItems: "center"
      }
    }
  }
}), L5 = Te(Wi(Bf, "message")), P5 = Te(Wi(Bf, "indicator")), j1 = Te(Wi("div", "list"), {
  display: "flex",
  flexDirection: "column",
  flexShrink: 0,
  flex: "inherit",
  [`& ${Qr.Container}`]: {
    marginBottom: "$1",
    "&:last-of-type": {
      marginBottom: 0
    }
  }
}), z1 = ({ avatar: e }) => /* @__PURE__ */ X.jsxs(P5, { withImage: !0, center: !0, children: [
  /* @__PURE__ */ X.jsx(ba, { avatar: e }),
  /* @__PURE__ */ X.jsx(x5, {})
] }), D5 = (e) => {
  const t = e[Fa.ITALIC], n = e[Fa.UNDERLINE], r = e[Fa.STRIKE_THROUGH], a = e[Fa.FONT_WEIGHT];
  let { text: i } = e;
  if (!i.trim())
    return i;
  const s = i.match(/^\s+/) || "", o = i.match(/\s+$/) || "";
  return i = i.trim(), t && (i = `*${i}*`), n && (i = `<u>${i}</u>`), r && (i = `~~${i}~~`), a && (i = `**${i}**`), `${s}${i}${o}`;
}, M5 = (e) => {
  var t;
  return `[${e.children.map($f())}](${(t = e.url) === null || t === void 0 ? void 0 : t.replace(/\s+/g, "")})`;
}, F5 = (e) => `{${e.name}}`, B5 = (e) => n1(e) ? M5(e) : r1(e) ? F5(e) : e.children.map($f()).join(""), $f = () => (e) => (
  // eslint-disable-next-line no-nested-ternary
  $t.isText(e) ? D5(e) : Yr.isElement(e) ? B5(e) : ""
), $5 = (e) => e.map($f()).join(`
`).replace(/\n{3,}/g, (t) => `
${"<br/>".repeat(t.length - 2)}

`), G1 = -1, Pu = 0, uu = 1, Vu = 2, Uf = 3, Hf = 4, jf = 5, zf = 6, Y1 = 7, W1 = 8, Vm = typeof self == "object" ? self : globalThis, U5 = (e, t) => {
  const n = (a, i) => (e.set(i, a), a), r = (a) => {
    if (e.has(a))
      return e.get(a);
    const [i, s] = t[a];
    switch (i) {
      case Pu:
      case G1:
        return n(s, a);
      case uu: {
        const o = n([], a);
        for (const u of s)
          o.push(r(u));
        return o;
      }
      case Vu: {
        const o = n({}, a);
        for (const [u, V] of s)
          o[r(u)] = r(V);
        return o;
      }
      case Uf:
        return n(new Date(s), a);
      case Hf: {
        const { source: o, flags: u } = s;
        return n(new RegExp(o, u), a);
      }
      case jf: {
        const o = n(/* @__PURE__ */ new Map(), a);
        for (const [u, V] of s)
          o.set(r(u), r(V));
        return o;
      }
      case zf: {
        const o = n(/* @__PURE__ */ new Set(), a);
        for (const u of s)
          o.add(r(u));
        return o;
      }
      case Y1: {
        const { name: o, message: u } = s;
        return n(new Vm[o](u), a);
      }
      case W1:
        return n(BigInt(s), a);
      case "BigInt":
        return n(Object(BigInt(s)), a);
    }
    return n(new Vm[i](s), a);
  };
  return r;
}, lm = (e) => U5(/* @__PURE__ */ new Map(), e)(0), vi = "", { toString: H5 } = {}, { keys: j5 } = Object, fs = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Pu, t];
  const n = H5.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [uu, vi];
    case "Object":
      return [Vu, vi];
    case "Date":
      return [Uf, vi];
    case "RegExp":
      return [Hf, vi];
    case "Map":
      return [jf, vi];
    case "Set":
      return [zf, vi];
  }
  return n.includes("Array") ? [uu, n] : n.includes("Error") ? [Y1, n] : [Vu, n];
}, vo = ([e, t]) => e === Pu && (t === "function" || t === "symbol"), z5 = (e, t, n, r) => {
  const a = (s, o) => {
    const u = r.push(s) - 1;
    return n.set(o, u), u;
  }, i = (s) => {
    if (n.has(s))
      return n.get(s);
    let [o, u] = fs(s);
    switch (o) {
      case Pu: {
        let c = s;
        switch (u) {
          case "bigint":
            o = W1, c = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + u);
            c = null;
            break;
          case "undefined":
            return a([G1], s);
        }
        return a([o, c], s);
      }
      case uu: {
        if (u)
          return a([u, [...s]], s);
        const c = [], f = a([o, c], s);
        for (const p of s)
          c.push(i(p));
        return f;
      }
      case Vu: {
        if (u)
          switch (u) {
            case "BigInt":
              return a([u, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return a([u, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return i(s.toJSON());
        const c = [], f = a([o, c], s);
        for (const p of j5(s))
          (e || !vo(fs(s[p]))) && c.push([i(p), i(s[p])]);
        return f;
      }
      case Uf:
        return a([o, s.toISOString()], s);
      case Hf: {
        const { source: c, flags: f } = s;
        return a([o, { source: c, flags: f }], s);
      }
      case jf: {
        const c = [], f = a([o, c], s);
        for (const [p, h] of s)
          (e || !(vo(fs(p)) || vo(fs(h)))) && c.push([i(p), i(h)]);
        return f;
      }
      case zf: {
        const c = [], f = a([o, c], s);
        for (const p of s)
          (e || !vo(fs(p))) && c.push(i(p));
        return f;
      }
    }
    const { message: V } = s;
    return a([o, { name: u, message: V }], s);
  };
  return i;
}, cm = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return z5(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Ja = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? lm(cm(e, t)) : structuredClone(e)
) : (e, t) => lm(cm(e, t));
class no {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
no.prototype.property = {};
no.prototype.normal = {};
no.prototype.space = null;
function q1(e, t) {
  const n = {}, r = {};
  let a = -1;
  for (; ++a < e.length; )
    Object.assign(n, e[a].property), Object.assign(r, e[a].normal);
  return new no(n, r, t);
}
function Ks(e) {
  return e.toLowerCase();
}
class nr {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
nr.prototype.space = null;
nr.prototype.boolean = !1;
nr.prototype.booleanish = !1;
nr.prototype.overloadedBoolean = !1;
nr.prototype.number = !1;
nr.prototype.commaSeparated = !1;
nr.prototype.spaceSeparated = !1;
nr.prototype.commaOrSpaceSeparated = !1;
nr.prototype.mustUseProperty = !1;
nr.prototype.defined = !1;
let G5 = 0;
const je = ri(), qt = ri(), X1 = ri(), he = ri(), Rt = ri(), Ii = ri(), $n = ri();
function ri() {
  return 2 ** ++G5;
}
const Ic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: je,
  booleanish: qt,
  commaOrSpaceSeparated: $n,
  commaSeparated: Ii,
  number: he,
  overloadedBoolean: X1,
  spaceSeparated: Rt
}, Symbol.toStringTag, { value: "Module" })), NV = Object.keys(Ic);
class Gf extends nr {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, a) {
    let i = -1;
    if (super(t, n), fm(this, "space", a), typeof r == "number")
      for (; ++i < NV.length; ) {
        const s = NV[i];
        fm(this, NV[i], (r & Ic[s]) === Ic[s]);
      }
  }
}
Gf.prototype.defined = !0;
function fm(e, t, n) {
  n && (e[t] = n);
}
const Y5 = {}.hasOwnProperty;
function qi(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (Y5.call(e.properties, r)) {
      const a = e.properties[r], i = new Gf(
        r,
        e.transform(e.attributes || {}, r),
        a,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (i.mustUseProperty = !0), t[r] = i, n[Ks(r)] = r, n[Ks(i.attribute)] = r;
    }
  return new no(t, n, e.space);
}
const K1 = qi({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Z1 = qi({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Q1(e, t) {
  return t in e ? e[t] : t;
}
function J1(e, t) {
  return Q1(e, t.toLowerCase());
}
const eb = qi({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: J1,
  properties: { xmlns: null, xmlnsXLink: null }
}), tb = qi({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: qt,
    ariaAutoComplete: null,
    ariaBusy: qt,
    ariaChecked: qt,
    ariaColCount: he,
    ariaColIndex: he,
    ariaColSpan: he,
    ariaControls: Rt,
    ariaCurrent: null,
    ariaDescribedBy: Rt,
    ariaDetails: null,
    ariaDisabled: qt,
    ariaDropEffect: Rt,
    ariaErrorMessage: null,
    ariaExpanded: qt,
    ariaFlowTo: Rt,
    ariaGrabbed: qt,
    ariaHasPopup: null,
    ariaHidden: qt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Rt,
    ariaLevel: he,
    ariaLive: null,
    ariaModal: qt,
    ariaMultiLine: qt,
    ariaMultiSelectable: qt,
    ariaOrientation: null,
    ariaOwns: Rt,
    ariaPlaceholder: null,
    ariaPosInSet: he,
    ariaPressed: qt,
    ariaReadOnly: qt,
    ariaRelevant: null,
    ariaRequired: qt,
    ariaRoleDescription: Rt,
    ariaRowCount: he,
    ariaRowIndex: he,
    ariaRowSpan: he,
    ariaSelected: qt,
    ariaSetSize: he,
    ariaSort: null,
    ariaValueMax: he,
    ariaValueMin: he,
    ariaValueNow: he,
    ariaValueText: null,
    role: null
  }
}), W5 = qi({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: J1,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Ii,
    acceptCharset: Rt,
    accessKey: Rt,
    action: null,
    allow: null,
    allowFullScreen: je,
    allowPaymentRequest: je,
    allowUserMedia: je,
    alt: null,
    as: null,
    async: je,
    autoCapitalize: null,
    autoComplete: Rt,
    autoFocus: je,
    autoPlay: je,
    capture: je,
    charSet: null,
    checked: je,
    cite: null,
    className: Rt,
    cols: he,
    colSpan: null,
    content: null,
    contentEditable: qt,
    controls: je,
    controlsList: Rt,
    coords: he | Ii,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: je,
    defer: je,
    dir: null,
    dirName: null,
    disabled: je,
    download: X1,
    draggable: qt,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: je,
    formTarget: null,
    headers: Rt,
    height: he,
    hidden: je,
    high: he,
    href: null,
    hrefLang: null,
    htmlFor: Rt,
    httpEquiv: Rt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: je,
    itemId: null,
    itemProp: Rt,
    itemRef: Rt,
    itemScope: je,
    itemType: Rt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: je,
    low: he,
    manifest: null,
    max: null,
    maxLength: he,
    media: null,
    method: null,
    min: null,
    minLength: he,
    multiple: je,
    muted: je,
    name: null,
    nonce: null,
    noModule: je,
    noValidate: je,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: je,
    optimum: he,
    pattern: null,
    ping: Rt,
    placeholder: null,
    playsInline: je,
    poster: null,
    preload: null,
    readOnly: je,
    referrerPolicy: null,
    rel: Rt,
    required: je,
    reversed: je,
    rows: he,
    rowSpan: he,
    sandbox: Rt,
    scope: null,
    scoped: je,
    seamless: je,
    selected: je,
    shape: null,
    size: he,
    sizes: null,
    slot: null,
    span: he,
    spellCheck: qt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: he,
    step: null,
    style: null,
    tabIndex: he,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: je,
    useMap: null,
    value: qt,
    width: he,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Rt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: he,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: he,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: je,
    // Lists. Use CSS to reduce space between items instead
    declare: je,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: he,
    // `<img>` and `<object>`
    leftMargin: he,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: he,
    // `<body>`
    marginWidth: he,
    // `<body>`
    noResize: je,
    // `<frame>`
    noHref: je,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: je,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: je,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: he,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: qt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: he,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: he,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: je,
    disableRemotePlayback: je,
    prefix: null,
    property: null,
    results: he,
    security: null,
    unselectable: null
  }
}), q5 = qi({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Q1,
  properties: {
    about: $n,
    accentHeight: he,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: he,
    amplitude: he,
    arabicForm: null,
    ascent: he,
    attributeName: null,
    attributeType: null,
    azimuth: he,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: he,
    by: null,
    calcMode: null,
    capHeight: he,
    className: Rt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: he,
    diffuseConstant: he,
    direction: null,
    display: null,
    dur: null,
    divisor: he,
    dominantBaseline: null,
    download: je,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: he,
    enableBackground: null,
    end: null,
    event: null,
    exponent: he,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: he,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Ii,
    g2: Ii,
    glyphName: Ii,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: he,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: he,
    horizOriginX: he,
    horizOriginY: he,
    id: null,
    ideographic: he,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: he,
    k: he,
    k1: he,
    k2: he,
    k3: he,
    k4: he,
    kernelMatrix: $n,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: he,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: he,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: he,
    overlineThickness: he,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: he,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Rt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: he,
    pointsAtY: he,
    pointsAtZ: he,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: $n,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: $n,
    rev: $n,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: $n,
    requiredFeatures: $n,
    requiredFonts: $n,
    requiredFormats: $n,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: he,
    specularExponent: he,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: he,
    strikethroughThickness: he,
    string: null,
    stroke: null,
    strokeDashArray: $n,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: he,
    strokeOpacity: he,
    strokeWidth: null,
    style: null,
    surfaceScale: he,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: $n,
    tabIndex: he,
    tableValues: null,
    target: null,
    targetX: he,
    targetY: he,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: $n,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: he,
    underlineThickness: he,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: he,
    values: null,
    vAlphabetic: he,
    vMathematical: he,
    vectorEffect: null,
    vHanging: he,
    vIdeographic: he,
    version: null,
    vertAdvY: he,
    vertOriginX: he,
    vertOriginY: he,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: he,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), X5 = /^data[-\w.:]+$/i, dm = /-[a-z]/g, K5 = /[A-Z]/g;
function Du(e, t) {
  const n = Ks(t);
  let r = t, a = nr;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && X5.test(t)) {
    if (t.charAt(4) === "-") {
      const i = t.slice(5).replace(dm, Q5);
      r = "data" + i.charAt(0).toUpperCase() + i.slice(1);
    } else {
      const i = t.slice(4);
      if (!dm.test(i)) {
        let s = i.replace(K5, Z5);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    a = Gf;
  }
  return new a(r, t);
}
function Z5(e) {
  return "-" + e.toLowerCase();
}
function Q5(e) {
  return e.charAt(1).toUpperCase();
}
const J5 = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, ro = q1([Z1, K1, eb, tb, W5], "html"), ai = q1([Z1, K1, eb, tb, q5], "svg");
function hm(e) {
  const t = [], n = String(e || "");
  let r = n.indexOf(","), a = 0, i = !1;
  for (; !i; ) {
    r === -1 && (r = n.length, i = !0);
    const s = n.slice(a, r).trim();
    (s || !i) && t.push(s), a = r + 1, r = n.indexOf(",", a);
  }
  return t;
}
function nb(e, t) {
  const n = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const mm = /[#.]/g;
function e8(e, t) {
  const n = e || "", r = {};
  let a = 0, i, s;
  for (; a < n.length; ) {
    mm.lastIndex = a;
    const o = mm.exec(n), u = n.slice(a, o ? o.index : n.length);
    u && (i ? i === "#" ? r.id = u : Array.isArray(r.className) ? r.className.push(u) : r.className = [u] : s = u, a += u.length), o && (i = o[0], a++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: s || t || "div",
    properties: r,
    children: []
  };
}
function pm(e) {
  const t = String(e || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function rb(e) {
  return e.join(" ").trim();
}
const t8 = /* @__PURE__ */ new Set(["button", "menu", "reset", "submit"]), Rc = {}.hasOwnProperty;
function ab(e, t, n) {
  const r = n && i8(n);
  function a(i, s, ...o) {
    let u = -1, V;
    if (i == null) {
      V = { type: "root", children: [] };
      const c = (
        /** @type {Child} */
        s
      );
      o.unshift(c);
    } else if (V = e8(i, t), V.tagName = V.tagName.toLowerCase(), r && Rc.call(r, V.tagName) && (V.tagName = r[V.tagName]), n8(s, V.tagName)) {
      let c;
      for (c in s)
        Rc.call(s, c) && r8(e, V.properties, c, s[c]);
    } else
      o.unshift(s);
    for (; ++u < o.length; )
      Nc(V.children, o[u]);
    return V.type === "element" && V.tagName === "template" && (V.content = { type: "root", children: V.children }, V.children = []), V;
  }
  return a;
}
function n8(e, t) {
  return e == null || typeof e != "object" || Array.isArray(e) ? !1 : t === "input" || !e.type || typeof e.type != "string" ? !0 : "children" in e && Array.isArray(e.children) ? !1 : t === "button" ? t8.has(e.type.toLowerCase()) : !("value" in e);
}
function r8(e, t, n, r) {
  const a = Du(e, n);
  let i = -1, s;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r))
        return;
      s = r;
    } else
      typeof r == "boolean" ? s = r : typeof r == "string" ? a.spaceSeparated ? s = pm(r) : a.commaSeparated ? s = hm(r) : a.commaOrSpaceSeparated ? s = pm(hm(r).join(" ")) : s = gm(a, a.property, r) : Array.isArray(r) ? s = r.concat() : s = a.property === "style" ? a8(r) : String(r);
    if (Array.isArray(s)) {
      const o = [];
      for (; ++i < s.length; ) {
        const u = (
          /** @type {number | string} */
          gm(a, a.property, s[i])
        );
        o[i] = u;
      }
      s = o;
    }
    if (a.property === "className" && Array.isArray(t.className)) {
      const o = (
        /** @type {number | string} */
        s
      );
      s = t.className.concat(o);
    }
    t[a.property] = s;
  }
}
function Nc(e, t) {
  let n = -1;
  if (t != null)
    if (typeof t == "string" || typeof t == "number")
      e.push({ type: "text", value: String(t) });
    else if (Array.isArray(t))
      for (; ++n < t.length; )
        Nc(e, t[n]);
    else if (typeof t == "object" && "type" in t)
      t.type === "root" ? Nc(e, t.children) : e.push(t);
    else
      throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function gm(e, t, n) {
  if (typeof n == "string") {
    if (e.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((e.boolean || e.overloadedBoolean) && (n === "" || Ks(n) === Ks(t)))
      return !0;
  }
  return n;
}
function a8(e) {
  const t = [];
  let n;
  for (n in e)
    Rc.call(e, n) && t.push([n, e[n]].join(": "));
  return t.join("; ");
}
function i8(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    t[e[n].toLowerCase()] = e[n];
  return t;
}
const s8 = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], o8 = ab(ro, "div"), u8 = ab(ai, "g", s8), kV = /\r?\n|\r/g;
function V8(e) {
  const t = String(e), n = [];
  for (kV.lastIndex = 0; kV.test(t); )
    n.push(kV.lastIndex);
  return n.push(t.length + 1), { toPoint: r, toOffset: a };
  function r(i) {
    let s = -1;
    if (typeof i == "number" && i > -1 && i < n[n.length - 1]) {
      for (; ++s < n.length; )
        if (n[s] > i)
          return {
            line: s + 1,
            column: i - (s > 0 ? n[s - 1] : 0) + 1,
            offset: i
          };
    }
  }
  function a(i) {
    const s = i && i.line, o = i && i.column;
    if (typeof s == "number" && typeof o == "number" && !Number.isNaN(s) && !Number.isNaN(o) && s - 1 in n) {
      const u = (n[s - 2] || 0) + o - 1 || 0;
      if (u > -1 && u < n[n.length - 1])
        return u;
    }
  }
}
const Ba = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, ib = {}.hasOwnProperty, l8 = Object.prototype;
function c8(e, t) {
  const n = t || {};
  return Yf(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? ai : ro,
      verbose: n.verbose || !1
    },
    e
  );
}
function Yf(e, t) {
  let n;
  switch (t.nodeName) {
    case "#comment": {
      const r = (
        /** @type {P5Comment} */
        t
      );
      return n = { type: "comment", value: r.data }, No(e, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {P5Document | P5DocumentFragment} */
        t
      ), a = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: sb(e, t.childNodes),
        data: { quirksMode: a }
      }, e.file && e.location) {
        const i = String(e.file), s = V8(i), o = s.toPoint(0), u = s.toPoint(i.length);
        n.position = { start: o, end: u };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {P5DocumentType} */
        t
      );
      return n = { type: "doctype" }, No(e, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {P5Text} */
        t
      );
      return n = { type: "text", value: r.value }, No(e, r, n), n;
    }
    default:
      return n = f8(
        e,
        /** @type {P5Element} */
        t
      ), n;
  }
}
function sb(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; ) {
    const a = (
      /** @type {RootContent} */
      Yf(e, t[n])
    );
    r.push(a);
  }
  return r;
}
function f8(e, t) {
  const n = e.schema;
  e.schema = t.namespaceURI === Ba.svg ? ai : ro;
  let r = -1;
  const a = {};
  for (; ++r < t.attrs.length; ) {
    const o = t.attrs[r], u = (o.prefix ? o.prefix + ":" : "") + o.name;
    ib.call(l8, u) || (a[u] = o.value);
  }
  const s = (e.schema.space === "svg" ? u8 : o8)(t.tagName, a, sb(e, t.childNodes));
  if (No(e, t, s), s.tagName === "template") {
    const o = (
      /** @type {P5Template} */
      t
    ), u = o.sourceCodeLocation, V = u && u.startTag && xi(u.startTag), c = u && u.endTag && xi(u.endTag), f = (
      /** @type {Root} */
      Yf(e, o.content)
    );
    V && c && e.file && (f.position = { start: V.end, end: c.start }), s.content = f;
  }
  return e.schema = n, s;
}
function No(e, t, n) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const r = d8(e, n, t.sourceCodeLocation);
    r && (e.location = !0, n.position = r);
  }
}
function d8(e, t, n) {
  const r = xi(n);
  if (t.type === "element") {
    const a = t.children[t.children.length - 1];
    if (r && !n.endTag && a && a.position && a.position.end && (r.end = Object.assign({}, a.position.end)), e.verbose) {
      const i = {};
      let s;
      if (n.attrs)
        for (s in n.attrs)
          ib.call(n.attrs, s) && (i[Du(e.schema, s).property] = xi(
            n.attrs[s]
          ));
      n.startTag;
      const o = xi(n.startTag), u = n.endTag ? xi(n.endTag) : void 0, V = { opening: o };
      u && (V.closing = u), V.properties = i, t.data = { position: V };
    }
  }
  return r;
}
function xi(e) {
  const t = bm({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), n = bm({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || n ? { start: t, end: n } : void 0;
}
function bm(e) {
  return e.line && e.column ? e : void 0;
}
var Am = {}.hasOwnProperty;
function ob(e, t) {
  var n = t || {};
  function r(a) {
    var i = r.invalid, s = r.handlers;
    if (a && Am.call(a, e) && (i = Am.call(s, a[e]) ? s[a[e]] : r.unknown), i)
      return i.apply(this, arguments);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const h8 = {}, m8 = {}.hasOwnProperty, ub = ob("type", { handlers: { root: g8, element: T8, text: E8, comment: v8, doctype: A8 } });
function p8(e, t) {
  const r = (t || h8).space;
  return ub(e, r === "svg" ? ai : ro);
}
function g8(e, t) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = Wf(e.children, n, t), Xi(e, n), n;
}
function b8(e, t) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = Wf(e.children, n, t), Xi(e, n), n;
}
function A8(e) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return Xi(e, t), t;
}
function E8(e) {
  const t = {
    nodeName: "#text",
    value: e.value,
    parentNode: null
  };
  return Xi(e, t), t;
}
function v8(e) {
  const t = {
    nodeName: "#comment",
    data: e.value,
    parentNode: null
  };
  return Xi(e, t), t;
}
function T8(e, t) {
  const n = t;
  let r = n;
  e.type === "element" && e.tagName.toLowerCase() === "svg" && n.space === "html" && (r = ai);
  const a = [];
  let i;
  if (e.properties) {
    for (i in e.properties)
      if (i !== "children" && m8.call(e.properties, i)) {
        const u = y8(
          r,
          i,
          e.properties[i]
        );
        u && a.push(u);
      }
  }
  const s = r.space, o = {
    nodeName: e.tagName,
    tagName: e.tagName,
    attrs: a,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: Ba[s],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = Wf(e.children, o, r), Xi(e, o), e.tagName === "template" && e.content && (o.content = b8(e.content, r)), o;
}
function y8(e, t, n) {
  const r = Du(e, t);
  if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? nb(n) : rb(n));
  const a = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const i = a.name.indexOf(":");
    i < 0 ? a.prefix = "" : (a.name = a.name.slice(i + 1), a.prefix = r.attribute.slice(0, i)), a.namespace = Ba[r.space];
  }
  return a;
}
function Wf(e, t, n) {
  let r = -1;
  const a = [];
  if (e)
    for (; ++r < e.length; ) {
      const i = ub(e[r], n);
      i.parentNode = t, a.push(i);
    }
  return a;
}
function Xi(e, t) {
  const n = e.position;
  n && n.start && n.end && (n.start.offset, n.end.offset, t.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
const _8 = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], C8 = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), Pt = "";
var T;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.NUMBER_SIGN = 35] = "NUMBER_SIGN", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_F = 70] = "LATIN_CAPITAL_F", e[e.LATIN_CAPITAL_X = 88] = "LATIN_CAPITAL_X", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_F = 102] = "LATIN_SMALL_F", e[e.LATIN_SMALL_X = 120] = "LATIN_SMALL_X", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z", e[e.REPLACEMENT_CHARACTER = 65533] = "REPLACEMENT_CHARACTER";
})(T = T || (T = {}));
const kn = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function Vb(e) {
  return e >= 55296 && e <= 57343;
}
function S8(e) {
  return e >= 56320 && e <= 57343;
}
function x8(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function lb(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function cb(e) {
  return e >= 64976 && e <= 65007 || C8.has(e);
}
var Z;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(Z = Z || (Z = {}));
const O8 = 65536;
class w8 {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = O8, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t) {
    const { line: n, col: r, offset: a } = this;
    return {
      code: t,
      startLine: n,
      endLine: n,
      startCol: r,
      endCol: r,
      startOffset: a,
      endOffset: a
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (S8(n))
        return this.pos++, this._addGap(), x8(t, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, T.EOF;
    return this._err(Z.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, n) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, n) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(t, this.pos);
    for (let r = 0; r < t.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(t) {
    const n = this.pos + t;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, T.EOF;
    const r = this.html.charCodeAt(n);
    return r === T.CARRIAGE_RETURN ? T.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, T.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === T.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, T.LINE_FEED) : t === T.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, Vb(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === T.LINE_FEED || t === T.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    lb(t) ? this._err(Z.controlCharacterInInputStream) : cb(t) && this._err(Z.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var Ze;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(Ze = Ze || (Ze = {}));
function fb(e, t) {
  for (let n = e.attrs.length - 1; n >= 0; n--)
    if (e.attrs[n].name === t)
      return e.attrs[n].value;
  return null;
}
const ca = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((e) => e.charCodeAt(0))
), I8 = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((e) => e.charCodeAt(0))
);
var LV;
const R8 = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), N8 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (LV = String.fromCodePoint) !== null && LV !== void 0 ? LV : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function k8(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = R8.get(e)) !== null && t !== void 0 ? t : e;
}
var Qt;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(Qt || (Qt = {}));
const L8 = 32;
var Nr;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Nr || (Nr = {}));
function kc(e) {
  return e >= Qt.ZERO && e <= Qt.NINE;
}
function P8(e) {
  return e >= Qt.UPPER_A && e <= Qt.UPPER_F || e >= Qt.LOWER_A && e <= Qt.LOWER_F;
}
function D8(e) {
  return e >= Qt.UPPER_A && e <= Qt.UPPER_Z || e >= Qt.LOWER_A && e <= Qt.LOWER_Z || kc(e);
}
function M8(e) {
  return e === Qt.EQUALS || D8(e);
}
var Zt;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(Zt || (Zt = {}));
var Pa;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(Pa || (Pa = {}));
class F8 {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = Zt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Pa.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = Zt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case Zt.EntityStart:
        return t.charCodeAt(n) === Qt.NUM ? (this.state = Zt.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = Zt.NamedEntity, this.stateNamedEntity(t, n));
      case Zt.NumericStart:
        return this.stateNumericStart(t, n);
      case Zt.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case Zt.NumericHex:
        return this.stateNumericHex(t, n);
      case Zt.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | L8) === Qt.LOWER_X ? (this.state = Zt.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = Zt.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, a) {
    if (n !== r) {
      const i = r - n;
      this.result = this.result * Math.pow(a, i) + parseInt(t.substr(n, i), a), this.consumed += i;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const a = t.charCodeAt(n);
      if (kc(a) || P8(a))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(a, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const a = t.charCodeAt(n);
      if (kc(a))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(a, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === Qt.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Pa.Strict)
      return 0;
    return this.emitCodePoint(k8(this.result), this.consumed), this.errors && (t !== Qt.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let a = r[this.treeIndex], i = (a & Nr.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const s = t.charCodeAt(n);
      if (this.treeIndex = hb(r, a, this.treeIndex + Math.max(1, i), s), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Pa.Attribute && // We shouldn't have consumed any characters after the entity,
        (i === 0 || // And there should be no invalid characters.
        M8(s)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (a = r[this.treeIndex], i = (a & Nr.VALUE_LENGTH) >> 14, i !== 0) {
        if (s === Qt.SEMI)
          return this.emitNamedEntityData(this.treeIndex, i, this.consumed + this.excess);
        this.decodeMode !== Pa.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, a = (r[n] & Nr.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, a, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: a } = this;
    return this.emitCodePoint(n === 1 ? a[t] & ~Nr.VALUE_LENGTH : a[t + 1], r), n === 3 && this.emitCodePoint(a[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case Zt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Pa.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case Zt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Zt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Zt.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Zt.EntityStart:
        return 0;
    }
  }
}
function db(e) {
  let t = "";
  const n = new F8(e, (r) => t += N8(r));
  return function(a, i) {
    let s = 0, o = 0;
    for (; (o = a.indexOf("&", o)) >= 0; ) {
      t += a.slice(s, o), n.startEntity(i);
      const V = n.write(
        a,
        // Skip the "&"
        o + 1
      );
      if (V < 0) {
        s = o + n.end();
        break;
      }
      s = o + V, o = V === 0 ? s + 1 : s;
    }
    const u = t + a.slice(s);
    return t = "", u;
  };
}
function hb(e, t, n, r) {
  const a = (t & Nr.BRANCH_LENGTH) >> 7, i = t & Nr.JUMP_TABLE;
  if (a === 0)
    return i !== 0 && r === i ? n : -1;
  if (i) {
    const u = r - i;
    return u < 0 || u >= a ? -1 : e[n + u] - 1;
  }
  let s = n, o = s + a - 1;
  for (; s <= o; ) {
    const u = s + o >>> 1, V = e[u];
    if (V < r)
      s = u + 1;
    else if (V > r)
      o = u - 1;
    else
      return e[u + a];
  }
  return -1;
}
db(ca);
db(I8);
var re;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(re = re || (re = {}));
var ga;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(ga = ga || (ga = {}));
var Un;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(Un = Un || (Un = {}));
var Y;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(Y = Y || (Y = {}));
var l;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SECTION = 94] = "SECTION", e[e.SELECT = 95] = "SELECT", e[e.SOURCE = 96] = "SOURCE", e[e.SMALL = 97] = "SMALL", e[e.SPAN = 98] = "SPAN", e[e.STRIKE = 99] = "STRIKE", e[e.STRONG = 100] = "STRONG", e[e.STYLE = 101] = "STYLE", e[e.SUB = 102] = "SUB", e[e.SUMMARY = 103] = "SUMMARY", e[e.SUP = 104] = "SUP", e[e.TABLE = 105] = "TABLE", e[e.TBODY = 106] = "TBODY", e[e.TEMPLATE = 107] = "TEMPLATE", e[e.TEXTAREA = 108] = "TEXTAREA", e[e.TFOOT = 109] = "TFOOT", e[e.TD = 110] = "TD", e[e.TH = 111] = "TH", e[e.THEAD = 112] = "THEAD", e[e.TITLE = 113] = "TITLE", e[e.TR = 114] = "TR", e[e.TRACK = 115] = "TRACK", e[e.TT = 116] = "TT", e[e.U = 117] = "U", e[e.UL = 118] = "UL", e[e.SVG = 119] = "SVG", e[e.VAR = 120] = "VAR", e[e.WBR = 121] = "WBR", e[e.XMP = 122] = "XMP";
})(l = l || (l = {}));
const B8 = /* @__PURE__ */ new Map([
  [Y.A, l.A],
  [Y.ADDRESS, l.ADDRESS],
  [Y.ANNOTATION_XML, l.ANNOTATION_XML],
  [Y.APPLET, l.APPLET],
  [Y.AREA, l.AREA],
  [Y.ARTICLE, l.ARTICLE],
  [Y.ASIDE, l.ASIDE],
  [Y.B, l.B],
  [Y.BASE, l.BASE],
  [Y.BASEFONT, l.BASEFONT],
  [Y.BGSOUND, l.BGSOUND],
  [Y.BIG, l.BIG],
  [Y.BLOCKQUOTE, l.BLOCKQUOTE],
  [Y.BODY, l.BODY],
  [Y.BR, l.BR],
  [Y.BUTTON, l.BUTTON],
  [Y.CAPTION, l.CAPTION],
  [Y.CENTER, l.CENTER],
  [Y.CODE, l.CODE],
  [Y.COL, l.COL],
  [Y.COLGROUP, l.COLGROUP],
  [Y.DD, l.DD],
  [Y.DESC, l.DESC],
  [Y.DETAILS, l.DETAILS],
  [Y.DIALOG, l.DIALOG],
  [Y.DIR, l.DIR],
  [Y.DIV, l.DIV],
  [Y.DL, l.DL],
  [Y.DT, l.DT],
  [Y.EM, l.EM],
  [Y.EMBED, l.EMBED],
  [Y.FIELDSET, l.FIELDSET],
  [Y.FIGCAPTION, l.FIGCAPTION],
  [Y.FIGURE, l.FIGURE],
  [Y.FONT, l.FONT],
  [Y.FOOTER, l.FOOTER],
  [Y.FOREIGN_OBJECT, l.FOREIGN_OBJECT],
  [Y.FORM, l.FORM],
  [Y.FRAME, l.FRAME],
  [Y.FRAMESET, l.FRAMESET],
  [Y.H1, l.H1],
  [Y.H2, l.H2],
  [Y.H3, l.H3],
  [Y.H4, l.H4],
  [Y.H5, l.H5],
  [Y.H6, l.H6],
  [Y.HEAD, l.HEAD],
  [Y.HEADER, l.HEADER],
  [Y.HGROUP, l.HGROUP],
  [Y.HR, l.HR],
  [Y.HTML, l.HTML],
  [Y.I, l.I],
  [Y.IMG, l.IMG],
  [Y.IMAGE, l.IMAGE],
  [Y.INPUT, l.INPUT],
  [Y.IFRAME, l.IFRAME],
  [Y.KEYGEN, l.KEYGEN],
  [Y.LABEL, l.LABEL],
  [Y.LI, l.LI],
  [Y.LINK, l.LINK],
  [Y.LISTING, l.LISTING],
  [Y.MAIN, l.MAIN],
  [Y.MALIGNMARK, l.MALIGNMARK],
  [Y.MARQUEE, l.MARQUEE],
  [Y.MATH, l.MATH],
  [Y.MENU, l.MENU],
  [Y.META, l.META],
  [Y.MGLYPH, l.MGLYPH],
  [Y.MI, l.MI],
  [Y.MO, l.MO],
  [Y.MN, l.MN],
  [Y.MS, l.MS],
  [Y.MTEXT, l.MTEXT],
  [Y.NAV, l.NAV],
  [Y.NOBR, l.NOBR],
  [Y.NOFRAMES, l.NOFRAMES],
  [Y.NOEMBED, l.NOEMBED],
  [Y.NOSCRIPT, l.NOSCRIPT],
  [Y.OBJECT, l.OBJECT],
  [Y.OL, l.OL],
  [Y.OPTGROUP, l.OPTGROUP],
  [Y.OPTION, l.OPTION],
  [Y.P, l.P],
  [Y.PARAM, l.PARAM],
  [Y.PLAINTEXT, l.PLAINTEXT],
  [Y.PRE, l.PRE],
  [Y.RB, l.RB],
  [Y.RP, l.RP],
  [Y.RT, l.RT],
  [Y.RTC, l.RTC],
  [Y.RUBY, l.RUBY],
  [Y.S, l.S],
  [Y.SCRIPT, l.SCRIPT],
  [Y.SECTION, l.SECTION],
  [Y.SELECT, l.SELECT],
  [Y.SOURCE, l.SOURCE],
  [Y.SMALL, l.SMALL],
  [Y.SPAN, l.SPAN],
  [Y.STRIKE, l.STRIKE],
  [Y.STRONG, l.STRONG],
  [Y.STYLE, l.STYLE],
  [Y.SUB, l.SUB],
  [Y.SUMMARY, l.SUMMARY],
  [Y.SUP, l.SUP],
  [Y.TABLE, l.TABLE],
  [Y.TBODY, l.TBODY],
  [Y.TEMPLATE, l.TEMPLATE],
  [Y.TEXTAREA, l.TEXTAREA],
  [Y.TFOOT, l.TFOOT],
  [Y.TD, l.TD],
  [Y.TH, l.TH],
  [Y.THEAD, l.THEAD],
  [Y.TITLE, l.TITLE],
  [Y.TR, l.TR],
  [Y.TRACK, l.TRACK],
  [Y.TT, l.TT],
  [Y.U, l.U],
  [Y.UL, l.UL],
  [Y.SVG, l.SVG],
  [Y.VAR, l.VAR],
  [Y.WBR, l.WBR],
  [Y.XMP, l.XMP]
]);
function Ki(e) {
  var t;
  return (t = B8.get(e)) !== null && t !== void 0 ? t : l.UNKNOWN;
}
const Ve = l, $8 = {
  [re.HTML]: /* @__PURE__ */ new Set([
    Ve.ADDRESS,
    Ve.APPLET,
    Ve.AREA,
    Ve.ARTICLE,
    Ve.ASIDE,
    Ve.BASE,
    Ve.BASEFONT,
    Ve.BGSOUND,
    Ve.BLOCKQUOTE,
    Ve.BODY,
    Ve.BR,
    Ve.BUTTON,
    Ve.CAPTION,
    Ve.CENTER,
    Ve.COL,
    Ve.COLGROUP,
    Ve.DD,
    Ve.DETAILS,
    Ve.DIR,
    Ve.DIV,
    Ve.DL,
    Ve.DT,
    Ve.EMBED,
    Ve.FIELDSET,
    Ve.FIGCAPTION,
    Ve.FIGURE,
    Ve.FOOTER,
    Ve.FORM,
    Ve.FRAME,
    Ve.FRAMESET,
    Ve.H1,
    Ve.H2,
    Ve.H3,
    Ve.H4,
    Ve.H5,
    Ve.H6,
    Ve.HEAD,
    Ve.HEADER,
    Ve.HGROUP,
    Ve.HR,
    Ve.HTML,
    Ve.IFRAME,
    Ve.IMG,
    Ve.INPUT,
    Ve.LI,
    Ve.LINK,
    Ve.LISTING,
    Ve.MAIN,
    Ve.MARQUEE,
    Ve.MENU,
    Ve.META,
    Ve.NAV,
    Ve.NOEMBED,
    Ve.NOFRAMES,
    Ve.NOSCRIPT,
    Ve.OBJECT,
    Ve.OL,
    Ve.P,
    Ve.PARAM,
    Ve.PLAINTEXT,
    Ve.PRE,
    Ve.SCRIPT,
    Ve.SECTION,
    Ve.SELECT,
    Ve.SOURCE,
    Ve.STYLE,
    Ve.SUMMARY,
    Ve.TABLE,
    Ve.TBODY,
    Ve.TD,
    Ve.TEMPLATE,
    Ve.TEXTAREA,
    Ve.TFOOT,
    Ve.TH,
    Ve.THEAD,
    Ve.TITLE,
    Ve.TR,
    Ve.TRACK,
    Ve.UL,
    Ve.WBR,
    Ve.XMP
  ]),
  [re.MATHML]: /* @__PURE__ */ new Set([Ve.MI, Ve.MO, Ve.MN, Ve.MS, Ve.MTEXT, Ve.ANNOTATION_XML]),
  [re.SVG]: /* @__PURE__ */ new Set([Ve.TITLE, Ve.FOREIGN_OBJECT, Ve.DESC]),
  [re.XLINK]: /* @__PURE__ */ new Set(),
  [re.XML]: /* @__PURE__ */ new Set(),
  [re.XMLNS]: /* @__PURE__ */ new Set()
};
function mb(e) {
  return e === Ve.H1 || e === Ve.H2 || e === Ve.H3 || e === Ve.H4 || e === Ve.H5 || e === Ve.H6;
}
Y.STYLE, Y.SCRIPT, Y.XMP, Y.IFRAME, Y.NOEMBED, Y.NOFRAMES, Y.PLAINTEXT;
const U8 = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var _;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.NAMED_CHARACTER_REFERENCE = 72] = "NAMED_CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 73] = "AMBIGUOUS_AMPERSAND", e[e.NUMERIC_CHARACTER_REFERENCE = 74] = "NUMERIC_CHARACTER_REFERENCE", e[e.HEXADEMICAL_CHARACTER_REFERENCE_START = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START", e[e.HEXADEMICAL_CHARACTER_REFERENCE = 76] = "HEXADEMICAL_CHARACTER_REFERENCE", e[e.DECIMAL_CHARACTER_REFERENCE = 77] = "DECIMAL_CHARACTER_REFERENCE", e[e.NUMERIC_CHARACTER_REFERENCE_END = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(_ || (_ = {}));
const Gt = {
  DATA: _.DATA,
  RCDATA: _.RCDATA,
  RAWTEXT: _.RAWTEXT,
  SCRIPT_DATA: _.SCRIPT_DATA,
  PLAINTEXT: _.PLAINTEXT,
  CDATA_SECTION: _.CDATA_SECTION
};
function Es(e) {
  return e >= T.DIGIT_0 && e <= T.DIGIT_9;
}
function bs(e) {
  return e >= T.LATIN_CAPITAL_A && e <= T.LATIN_CAPITAL_Z;
}
function H8(e) {
  return e >= T.LATIN_SMALL_A && e <= T.LATIN_SMALL_Z;
}
function fa(e) {
  return H8(e) || bs(e);
}
function Lc(e) {
  return fa(e) || Es(e);
}
function pb(e) {
  return e >= T.LATIN_CAPITAL_A && e <= T.LATIN_CAPITAL_F;
}
function gb(e) {
  return e >= T.LATIN_SMALL_A && e <= T.LATIN_SMALL_F;
}
function j8(e) {
  return Es(e) || pb(e) || gb(e);
}
function To(e) {
  return e + 32;
}
function bb(e) {
  return e === T.SPACE || e === T.LINE_FEED || e === T.TABULATION || e === T.FORM_FEED;
}
function z8(e) {
  return e === T.EQUALS_SIGN || Lc(e);
}
function Em(e) {
  return bb(e) || e === T.SOLIDUS || e === T.GREATER_THAN_SIGN;
}
class G8 {
  constructor(t, n) {
    this.options = t, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = _.DATA, this.returnState = _.DATA, this.charRefCode = -1, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new w8(n), this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(t) {
    var n, r;
    (r = (n = this.handler).onParseError) === null || r === void 0 || r.call(n, this.preprocessor.getError(t));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t());
  }
  write(t, n, r) {
    this.active = !0, this.preprocessor.write(t, n), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this._unconsume(this.consumedAfterSnapshot), this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _unconsume(t) {
    this.consumedAfterSnapshot -= t, this.preprocessor.retreat(t);
  }
  _reconsumeInState(t, n) {
    this.state = t, this._callState(n);
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let n = 0; n < t; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, n) {
    return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: Ze.START_TAG,
      tagName: "",
      tagID: l.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: Ze.END_TAG,
      tagName: "",
      tagID: l.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: Ze.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: Ze.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, n) {
    this.currentCharacterToken = {
      type: t,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, n;
    const r = this.currentToken;
    if (fb(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const a = (t = (n = r.location).attrs) !== null && t !== void 0 ? t : n.attrs = /* @__PURE__ */ Object.create(null);
        a[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(Z.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = Ki(t.tagName), t.type === Ze.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(Z.endTagWithAttributes), t.selfClosing && this._err(Z.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case Ze.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case Ze.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case Ze.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: Ze.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type !== t)
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
      else {
        this.currentCharacterToken.chars += n;
        return;
      }
    this._createCharacterToken(t, n);
  }
  _emitCodePoint(t) {
    const n = bb(t) ? Ze.WHITESPACE_CHARACTER : t === T.NULL ? Ze.NULL_CHARACTER : Ze.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(Ze.CHARACTER, t);
  }
  // Character reference helpers
  _matchNamedCharacterReference(t) {
    let n = null, r = 0, a = !1;
    for (let i = 0, s = ca[0]; i >= 0 && (i = hb(ca, s, i + 1, t), !(i < 0)); t = this._consume()) {
      r += 1, s = ca[i];
      const o = s & Nr.VALUE_LENGTH;
      if (o) {
        const u = (o >> 14) - 1;
        if (t !== T.SEMICOLON && this._isCharacterReferenceInAttribute() && z8(this.preprocessor.peek(1)) ? (n = [T.AMPERSAND], i += u) : (n = u === 0 ? [ca[i] & ~Nr.VALUE_LENGTH] : u === 1 ? [ca[++i]] : [ca[++i], ca[++i]], r = 0, a = t !== T.SEMICOLON), u === 0) {
          this._consume();
          break;
        }
      }
    }
    return this._unconsume(r), a && !this.preprocessor.endOfChunkHit && this._err(Z.missingSemicolonAfterCharacterReference), this._unconsume(1), n;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === _.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === _.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === _.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case _.DATA: {
        this._stateData(t);
        break;
      }
      case _.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case _.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case _.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case _.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case _.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case _.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case _.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case _.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case _.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case _.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case _.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case _.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case _.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case _.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case _.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case _.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case _.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case _.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case _.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case _.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case _.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case _.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case _.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case _.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case _.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case _.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case _.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case _.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case _.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case _.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case _.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case _.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case _.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case _.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case _.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case _.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case _.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case _.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case _.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case _.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case _.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case _.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case _.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case _.COMMENT: {
        this._stateComment(t);
        break;
      }
      case _.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case _.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case _.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case _.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case _.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case _.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case _.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case _.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case _.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case _.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case _.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case _.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case _.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case _.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case _.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case _.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case _.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case _.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case _.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case _.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case _.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case _.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case _.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case _.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case _.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case _.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case _.CHARACTER_REFERENCE: {
        this._stateCharacterReference(t);
        break;
      }
      case _.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(t);
        break;
      }
      case _.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      case _.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(t);
        break;
      }
      case _.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(t);
        break;
      }
      case _.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(t);
        break;
      }
      case _.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(t);
        break;
      }
      case _.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case T.LESS_THAN_SIGN: {
        this.state = _.TAG_OPEN;
        break;
      }
      case T.AMPERSAND: {
        this.returnState = _.DATA, this.state = _.CHARACTER_REFERENCE;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case T.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case T.AMPERSAND: {
        this.returnState = _.RCDATA, this.state = _.CHARACTER_REFERENCE;
        break;
      }
      case T.LESS_THAN_SIGN: {
        this.state = _.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this._emitChars(Pt);
        break;
      }
      case T.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case T.LESS_THAN_SIGN: {
        this.state = _.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this._emitChars(Pt);
        break;
      }
      case T.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case T.LESS_THAN_SIGN: {
        this.state = _.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this._emitChars(Pt);
        break;
      }
      case T.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this._emitChars(Pt);
        break;
      }
      case T.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (fa(t))
      this._createStartTagToken(), this.state = _.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case T.EXCLAMATION_MARK: {
          this.state = _.MARKUP_DECLARATION_OPEN;
          break;
        }
        case T.SOLIDUS: {
          this.state = _.END_TAG_OPEN;
          break;
        }
        case T.QUESTION_MARK: {
          this._err(Z.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = _.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case T.EOF: {
          this._err(Z.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(Z.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = _.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (fa(t))
      this._createEndTagToken(), this.state = _.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case T.GREATER_THAN_SIGN: {
          this._err(Z.missingEndTagName), this.state = _.DATA;
          break;
        }
        case T.EOF: {
          this._err(Z.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(Z.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = _.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const n = this.currentToken;
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED: {
        this.state = _.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case T.SOLIDUS: {
        this.state = _.SELF_CLOSING_START_TAG;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this.state = _.DATA, this.emitCurrentTagToken();
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), n.tagName += Pt;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(bs(t) ? To(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === T.SOLIDUS ? this.state = _.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = _.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    fa(t) ? (this.state = _.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = _.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = _.BEFORE_ATTRIBUTE_NAME, !1;
      case T.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = _.SELF_CLOSING_START_TAG, !1;
      case T.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = _.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = _.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === T.SOLIDUS ? this.state = _.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = _.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    fa(t) ? (this.state = _.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = _.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = _.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case T.SOLIDUS: {
        this.state = _.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case T.EXCLAMATION_MARK: {
        this.state = _.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = _.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    fa(t) ? (this.state = _.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = _.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = _.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === T.HYPHEN_MINUS ? (this.state = _.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = _.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === T.HYPHEN_MINUS ? (this.state = _.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = _.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case T.HYPHEN_MINUS: {
        this.state = _.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case T.LESS_THAN_SIGN: {
        this.state = _.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this._emitChars(Pt);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case T.HYPHEN_MINUS: {
        this.state = _.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case T.LESS_THAN_SIGN: {
        this.state = _.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this.state = _.SCRIPT_DATA_ESCAPED, this._emitChars(Pt);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = _.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case T.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case T.LESS_THAN_SIGN: {
        this.state = _.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this.state = _.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this.state = _.SCRIPT_DATA_ESCAPED, this._emitChars(Pt);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = _.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === T.SOLIDUS ? this.state = _.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : fa(t) ? (this._emitChars("<"), this.state = _.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = _.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    fa(t) ? (this.state = _.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = _.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = _.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(kn.SCRIPT, !1) && Em(this.preprocessor.peek(kn.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < kn.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else
      this._ensureHibernation() || (this.state = _.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case T.HYPHEN_MINUS: {
        this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case T.LESS_THAN_SIGN: {
        this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this._emitChars(Pt);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case T.HYPHEN_MINUS: {
        this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case T.LESS_THAN_SIGN: {
        this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Pt);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case T.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case T.LESS_THAN_SIGN: {
        this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this.state = _.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Pt);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === T.SOLIDUS ? (this.state = _.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(kn.SCRIPT, !1) && Em(this.preprocessor.peek(kn.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < kn.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = _.SCRIPT_DATA_ESCAPED;
    } else
      this._ensureHibernation() || (this.state = _.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED:
        break;
      case T.SOLIDUS:
      case T.GREATER_THAN_SIGN:
      case T.EOF: {
        this.state = _.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case T.EQUALS_SIGN: {
        this._err(Z.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = _.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = _.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED:
      case T.SOLIDUS:
      case T.GREATER_THAN_SIGN:
      case T.EOF: {
        this._leaveAttrName(), this.state = _.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case T.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = _.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case T.QUOTATION_MARK:
      case T.APOSTROPHE:
      case T.LESS_THAN_SIGN: {
        this._err(Z.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this.currentAttr.name += Pt;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(bs(t) ? To(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED:
        break;
      case T.SOLIDUS: {
        this.state = _.SELF_CLOSING_START_TAG;
        break;
      }
      case T.EQUALS_SIGN: {
        this.state = _.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this.state = _.DATA, this.emitCurrentTagToken();
        break;
      }
      case T.EOF: {
        this._err(Z.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = _.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED:
        break;
      case T.QUOTATION_MARK: {
        this.state = _.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case T.APOSTROPHE: {
        this.state = _.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.missingAttributeValue), this.state = _.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = _.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case T.QUOTATION_MARK: {
        this.state = _.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case T.AMPERSAND: {
        this.returnState = _.ATTRIBUTE_VALUE_DOUBLE_QUOTED, this.state = _.CHARACTER_REFERENCE;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this.currentAttr.value += Pt;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case T.APOSTROPHE: {
        this.state = _.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case T.AMPERSAND: {
        this.returnState = _.ATTRIBUTE_VALUE_SINGLE_QUOTED, this.state = _.CHARACTER_REFERENCE;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this.currentAttr.value += Pt;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED: {
        this._leaveAttrValue(), this.state = _.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case T.AMPERSAND: {
        this.returnState = _.ATTRIBUTE_VALUE_UNQUOTED, this.state = _.CHARACTER_REFERENCE;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = _.DATA, this.emitCurrentTagToken();
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), this.currentAttr.value += Pt;
        break;
      }
      case T.QUOTATION_MARK:
      case T.APOSTROPHE:
      case T.LESS_THAN_SIGN:
      case T.EQUALS_SIGN:
      case T.GRAVE_ACCENT: {
        this._err(Z.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED: {
        this._leaveAttrValue(), this.state = _.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case T.SOLIDUS: {
        this._leaveAttrValue(), this.state = _.SELF_CLOSING_START_TAG;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = _.DATA, this.emitCurrentTagToken();
        break;
      }
      case T.EOF: {
        this._err(Z.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(Z.missingWhitespaceBetweenAttributes), this.state = _.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case T.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = _.DATA, this.emitCurrentTagToken();
        break;
      }
      case T.EOF: {
        this._err(Z.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(Z.unexpectedSolidusInTag), this.state = _.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const n = this.currentToken;
    switch (t) {
      case T.GREATER_THAN_SIGN: {
        this.state = _.DATA, this.emitCurrentComment(n);
        break;
      }
      case T.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), n.data += Pt;
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(kn.DASH_DASH, !0) ? (this._createCommentToken(kn.DASH_DASH.length + 1), this.state = _.COMMENT_START) : this._consumeSequenceIfMatch(kn.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(kn.DOCTYPE.length + 1), this.state = _.DOCTYPE) : this._consumeSequenceIfMatch(kn.CDATA_START, !0) ? this.inForeignNode ? this.state = _.CDATA_SECTION : (this._err(Z.cdataInHtmlContent), this._createCommentToken(kn.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = _.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(Z.incorrectlyOpenedComment), this._createCommentToken(2), this.state = _.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case T.HYPHEN_MINUS: {
        this.state = _.COMMENT_START_DASH;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.abruptClosingOfEmptyComment), this.state = _.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = _.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const n = this.currentToken;
    switch (t) {
      case T.HYPHEN_MINUS: {
        this.state = _.COMMENT_END;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.abruptClosingOfEmptyComment), this.state = _.DATA, this.emitCurrentComment(n);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = _.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const n = this.currentToken;
    switch (t) {
      case T.HYPHEN_MINUS: {
        this.state = _.COMMENT_END_DASH;
        break;
      }
      case T.LESS_THAN_SIGN: {
        n.data += "<", this.state = _.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), n.data += Pt;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const n = this.currentToken;
    switch (t) {
      case T.EXCLAMATION_MARK: {
        n.data += "!", this.state = _.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case T.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = _.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === T.HYPHEN_MINUS ? this.state = _.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = _.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === T.HYPHEN_MINUS ? this.state = _.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = _.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== T.GREATER_THAN_SIGN && t !== T.EOF && this._err(Z.nestedComment), this.state = _.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const n = this.currentToken;
    switch (t) {
      case T.HYPHEN_MINUS: {
        this.state = _.COMMENT_END;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = _.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const n = this.currentToken;
    switch (t) {
      case T.GREATER_THAN_SIGN: {
        this.state = _.DATA, this.emitCurrentComment(n);
        break;
      }
      case T.EXCLAMATION_MARK: {
        this.state = _.COMMENT_END_BANG;
        break;
      }
      case T.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case T.EOF: {
        this._err(Z.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = _.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const n = this.currentToken;
    switch (t) {
      case T.HYPHEN_MINUS: {
        n.data += "--!", this.state = _.COMMENT_END_DASH;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.incorrectlyClosedComment), this.state = _.DATA, this.emitCurrentComment(n);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = _.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED: {
        this.state = _.BEFORE_DOCTYPE_NAME;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this.state = _.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Z.missingWhitespaceBeforeDoctypeName), this.state = _.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (bs(t))
      this._createDoctypeToken(String.fromCharCode(To(t))), this.state = _.DOCTYPE_NAME;
    else
      switch (t) {
        case T.SPACE:
        case T.LINE_FEED:
        case T.TABULATION:
        case T.FORM_FEED:
          break;
        case T.NULL: {
          this._err(Z.unexpectedNullCharacter), this._createDoctypeToken(Pt), this.state = _.DOCTYPE_NAME;
          break;
        }
        case T.GREATER_THAN_SIGN: {
          this._err(Z.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = _.DATA;
          break;
        }
        case T.EOF: {
          this._err(Z.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = _.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED: {
        this.state = _.AFTER_DOCTYPE_NAME;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this.state = _.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), n.name += Pt;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(bs(t) ? To(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED:
        break;
      case T.GREATER_THAN_SIGN: {
        this.state = _.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(kn.PUBLIC, !1) ? this.state = _.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(kn.SYSTEM, !1) ? this.state = _.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(Z.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = _.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED: {
        this.state = _.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case T.QUOTATION_MARK: {
        this._err(Z.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = _.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case T.APOSTROPHE: {
        this._err(Z.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = _.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = _.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Z.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = _.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED:
        break;
      case T.QUOTATION_MARK: {
        n.publicId = "", this.state = _.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case T.APOSTROPHE: {
        n.publicId = "", this.state = _.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = _.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Z.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = _.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case T.QUOTATION_MARK: {
        this.state = _.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), n.publicId += Pt;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = _.DATA;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case T.APOSTROPHE: {
        this.state = _.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), n.publicId += Pt;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = _.DATA;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED: {
        this.state = _.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this.state = _.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case T.QUOTATION_MARK: {
        this._err(Z.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = _.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case T.APOSTROPHE: {
        this._err(Z.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = _.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Z.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = _.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const n = this.currentToken;
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED:
        break;
      case T.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = _.DATA;
        break;
      }
      case T.QUOTATION_MARK: {
        n.systemId = "", this.state = _.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case T.APOSTROPHE: {
        n.systemId = "", this.state = _.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Z.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = _.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED: {
        this.state = _.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case T.QUOTATION_MARK: {
        this._err(Z.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = _.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case T.APOSTROPHE: {
        this._err(Z.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = _.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = _.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Z.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = _.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED:
        break;
      case T.QUOTATION_MARK: {
        n.systemId = "", this.state = _.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case T.APOSTROPHE: {
        n.systemId = "", this.state = _.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = _.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Z.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = _.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case T.QUOTATION_MARK: {
        this.state = _.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), n.systemId += Pt;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = _.DATA;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case T.APOSTROPHE: {
        this.state = _.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter), n.systemId += Pt;
        break;
      }
      case T.GREATER_THAN_SIGN: {
        this._err(Z.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = _.DATA;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case T.SPACE:
      case T.LINE_FEED:
      case T.TABULATION:
      case T.FORM_FEED:
        break;
      case T.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = _.DATA;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Z.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = _.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const n = this.currentToken;
    switch (t) {
      case T.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = _.DATA;
        break;
      }
      case T.NULL: {
        this._err(Z.unexpectedNullCharacter);
        break;
      }
      case T.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case T.RIGHT_SQUARE_BRACKET: {
        this.state = _.CDATA_SECTION_BRACKET;
        break;
      }
      case T.EOF: {
        this._err(Z.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === T.RIGHT_SQUARE_BRACKET ? this.state = _.CDATA_SECTION_END : (this._emitChars("]"), this.state = _.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case T.GREATER_THAN_SIGN: {
        this.state = _.DATA;
        break;
      }
      case T.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = _.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(t) {
    t === T.NUMBER_SIGN ? this.state = _.NUMERIC_CHARACTER_REFERENCE : Lc(t) ? (this.state = _.NAMED_CHARACTER_REFERENCE, this._stateNamedCharacterReference(t)) : (this._flushCodePointConsumedAsCharacterReference(T.AMPERSAND), this._reconsumeInState(this.returnState, t));
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(t) {
    const n = this._matchNamedCharacterReference(t);
    if (!this._ensureHibernation())
      if (n) {
        for (let r = 0; r < n.length; r++)
          this._flushCodePointConsumedAsCharacterReference(n[r]);
        this.state = this.returnState;
      } else
        this._flushCodePointConsumedAsCharacterReference(T.AMPERSAND), this.state = _.AMBIGUOUS_AMPERSAND;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    Lc(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === T.SEMICOLON && this._err(Z.unknownNamedCharacterReference), this._reconsumeInState(this.returnState, t));
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(t) {
    this.charRefCode = 0, t === T.LATIN_SMALL_X || t === T.LATIN_CAPITAL_X ? this.state = _.HEXADEMICAL_CHARACTER_REFERENCE_START : Es(t) ? (this.state = _.DECIMAL_CHARACTER_REFERENCE, this._stateDecimalCharacterReference(t)) : (this._err(Z.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(T.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(T.NUMBER_SIGN), this._reconsumeInState(this.returnState, t));
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(t) {
    j8(t) ? (this.state = _.HEXADEMICAL_CHARACTER_REFERENCE, this._stateHexademicalCharacterReference(t)) : (this._err(Z.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(T.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(T.NUMBER_SIGN), this._unconsume(2), this.state = this.returnState);
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(t) {
    pb(t) ? this.charRefCode = this.charRefCode * 16 + t - 55 : gb(t) ? this.charRefCode = this.charRefCode * 16 + t - 87 : Es(t) ? this.charRefCode = this.charRefCode * 16 + t - 48 : t === T.SEMICOLON ? this.state = _.NUMERIC_CHARACTER_REFERENCE_END : (this._err(Z.missingSemicolonAfterCharacterReference), this.state = _.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(t) {
    Es(t) ? this.charRefCode = this.charRefCode * 10 + t - 48 : t === T.SEMICOLON ? this.state = _.NUMERIC_CHARACTER_REFERENCE_END : (this._err(Z.missingSemicolonAfterCharacterReference), this.state = _.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(t) {
    if (this.charRefCode === T.NULL)
      this._err(Z.nullCharacterReference), this.charRefCode = T.REPLACEMENT_CHARACTER;
    else if (this.charRefCode > 1114111)
      this._err(Z.characterReferenceOutsideUnicodeRange), this.charRefCode = T.REPLACEMENT_CHARACTER;
    else if (Vb(this.charRefCode))
      this._err(Z.surrogateCharacterReference), this.charRefCode = T.REPLACEMENT_CHARACTER;
    else if (cb(this.charRefCode))
      this._err(Z.noncharacterCharacterReference);
    else if (lb(this.charRefCode) || this.charRefCode === T.CARRIAGE_RETURN) {
      this._err(Z.controlCharacterReference);
      const n = U8.get(this.charRefCode);
      n !== void 0 && (this.charRefCode = n);
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode), this._reconsumeInState(this.returnState, t);
  }
}
const Ab = /* @__PURE__ */ new Set([l.DD, l.DT, l.LI, l.OPTGROUP, l.OPTION, l.P, l.RB, l.RP, l.RT, l.RTC]), vm = /* @__PURE__ */ new Set([
  ...Ab,
  l.CAPTION,
  l.COLGROUP,
  l.TBODY,
  l.TD,
  l.TFOOT,
  l.TH,
  l.THEAD,
  l.TR
]), yo = /* @__PURE__ */ new Map([
  [l.APPLET, re.HTML],
  [l.CAPTION, re.HTML],
  [l.HTML, re.HTML],
  [l.MARQUEE, re.HTML],
  [l.OBJECT, re.HTML],
  [l.TABLE, re.HTML],
  [l.TD, re.HTML],
  [l.TEMPLATE, re.HTML],
  [l.TH, re.HTML],
  [l.ANNOTATION_XML, re.MATHML],
  [l.MI, re.MATHML],
  [l.MN, re.MATHML],
  [l.MO, re.MATHML],
  [l.MS, re.MATHML],
  [l.MTEXT, re.MATHML],
  [l.DESC, re.SVG],
  [l.FOREIGN_OBJECT, re.SVG],
  [l.TITLE, re.SVG]
]), Y8 = [l.H1, l.H2, l.H3, l.H4, l.H5, l.H6], W8 = [l.TR, l.TEMPLATE, l.HTML], q8 = [l.TBODY, l.TFOOT, l.THEAD, l.TEMPLATE, l.HTML], X8 = [l.TABLE, l.TEMPLATE, l.HTML], K8 = [l.TD, l.TH];
class Z8 {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = l.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === l.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === re.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, n) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, n) {
    const r = this._indexOf(t);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(t, n, r) {
    const a = this._indexOf(t) + 1;
    this.items.splice(a, 0, n), this.tagIDs.splice(a, 0, r), this.stackTop++, a === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, a === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(t, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== re.HTML);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const n = this._indexOf(t);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  popUntilPopped(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(Y8, re.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(K8, re.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (t.includes(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(X8, re.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(q8, re.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(W8, re.HTML);
  }
  remove(t) {
    const n = this._indexOf(t);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === l.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const n = this._indexOf(t) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === l.HTML;
  }
  //Element in scope
  hasInScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n], a = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === t && a === re.HTML)
        return !0;
      if (yo.get(r) === a)
        return !1;
    }
    return !0;
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t], r = this.treeAdapter.getNamespaceURI(this.items[t]);
      if (mb(n) && r === re.HTML)
        return !0;
      if (yo.get(n) === r)
        return !1;
    }
    return !0;
  }
  hasInListItemScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n], a = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === t && a === re.HTML)
        return !0;
      if ((r === l.UL || r === l.OL) && a === re.HTML || yo.get(r) === a)
        return !1;
    }
    return !0;
  }
  hasInButtonScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n], a = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === t && a === re.HTML)
        return !0;
      if (r === l.BUTTON && a === re.HTML || yo.get(r) === a)
        return !1;
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n];
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === re.HTML) {
        if (r === t)
          return !0;
        if (r === l.TABLE || r === l.TEMPLATE || r === l.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t];
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === re.HTML) {
        if (n === l.TBODY || n === l.THEAD || n === l.TFOOT)
          return !0;
        if (n === l.TABLE || n === l.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasInSelectScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n];
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === re.HTML) {
        if (r === t)
          return !0;
        if (r !== l.OPTION && r !== l.OPTGROUP)
          return !1;
      }
    }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; Ab.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; vm.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== t && vm.has(this.currentTagId); )
      this.pop();
  }
}
const PV = 3;
var mr;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(mr = mr || (mr = {}));
const Tm = { type: mr.Marker };
class Q8 {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, n) {
    const r = [], a = n.length, i = this.treeAdapter.getTagName(t), s = this.treeAdapter.getNamespaceURI(t);
    for (let o = 0; o < this.entries.length; o++) {
      const u = this.entries[o];
      if (u.type === mr.Marker)
        break;
      const { element: V } = u;
      if (this.treeAdapter.getTagName(V) === i && this.treeAdapter.getNamespaceURI(V) === s) {
        const c = this.treeAdapter.getAttrList(V);
        c.length === a && r.push({ idx: o, attrs: c });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < PV)
      return;
    const n = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n);
    if (r.length < PV)
      return;
    const a = new Map(n.map((s) => [s.name, s.value]));
    let i = 0;
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      o.attrs.every((u) => a.get(u.name) === u.value) && (i += 1, i >= PV && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(Tm);
  }
  pushElement(t, n) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: mr.Element,
      element: t,
      token: n
    });
  }
  insertElementAfterBookmark(t, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: mr.Element,
      element: t,
      token: n
    });
  }
  removeEntry(t) {
    const n = this.entries.indexOf(t);
    n >= 0 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(Tm);
    t >= 0 ? this.entries.splice(0, t + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const n = this.entries.find((r) => r.type === mr.Marker || this.treeAdapter.getTagName(r.element) === t);
    return n && n.type === mr.Element ? n : null;
  }
  getElementEntry(t) {
    return this.entries.find((n) => n.type === mr.Element && n.element === t);
  }
}
function ym(e) {
  return {
    nodeName: "#text",
    value: e,
    parentNode: null
  };
}
const yi = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: Un.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, n) {
    return {
      nodeName: e,
      tagName: e,
      attrs: n,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, n) {
    const r = e.childNodes.indexOf(n);
    e.childNodes.splice(r, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, n, r) {
    const a = e.childNodes.find((i) => i.nodeName === "#documentType");
    if (a)
      a.name = t, a.publicId = n, a.systemId = r;
    else {
      const i = {
        nodeName: "#documentType",
        name: t,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      yi.appendChild(e, i);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const n = e.childNodes[e.childNodes.length - 1];
      if (yi.isTextNode(n)) {
        n.value += t;
        return;
      }
    }
    yi.appendChild(e, ym(t));
  },
  insertTextBefore(e, t, n) {
    const r = e.childNodes[e.childNodes.indexOf(n) - 1];
    r && yi.isTextNode(r) ? r.value += t : yi.insertBefore(e, ym(t), n);
  },
  adoptAttributes(e, t) {
    const n = new Set(e.attrs.map((r) => r.name));
    for (let r = 0; r < t.length; r++)
      n.has(t[r].name) || e.attrs.push(t[r]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, Eb = "html", J8 = "about:legacy-compat", eL = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", vb = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], tL = [
  ...vb,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], nL = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), Tb = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], rL = [
  ...Tb,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function _m(e, t) {
  return t.some((n) => e.startsWith(n));
}
function aL(e) {
  return e.name === Eb && e.publicId === null && (e.systemId === null || e.systemId === J8);
}
function iL(e) {
  if (e.name !== Eb)
    return Un.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === eL)
    return Un.QUIRKS;
  let { publicId: n } = e;
  if (n !== null) {
    if (n = n.toLowerCase(), nL.has(n))
      return Un.QUIRKS;
    let r = t === null ? tL : vb;
    if (_m(n, r))
      return Un.QUIRKS;
    if (r = t === null ? Tb : rL, _m(n, r))
      return Un.LIMITED_QUIRKS;
  }
  return Un.NO_QUIRKS;
}
const Cm = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, sL = "definitionurl", oL = "definitionURL", uL = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), VL = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: re.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: re.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: re.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: re.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: re.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: re.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: re.XLINK }],
  ["xml:base", { prefix: "xml", name: "base", namespace: re.XML }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: re.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: re.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: re.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: re.XMLNS }]
]), lL = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), cL = /* @__PURE__ */ new Set([
  l.B,
  l.BIG,
  l.BLOCKQUOTE,
  l.BODY,
  l.BR,
  l.CENTER,
  l.CODE,
  l.DD,
  l.DIV,
  l.DL,
  l.DT,
  l.EM,
  l.EMBED,
  l.H1,
  l.H2,
  l.H3,
  l.H4,
  l.H5,
  l.H6,
  l.HEAD,
  l.HR,
  l.I,
  l.IMG,
  l.LI,
  l.LISTING,
  l.MENU,
  l.META,
  l.NOBR,
  l.OL,
  l.P,
  l.PRE,
  l.RUBY,
  l.S,
  l.SMALL,
  l.SPAN,
  l.STRONG,
  l.STRIKE,
  l.SUB,
  l.SUP,
  l.TABLE,
  l.TT,
  l.U,
  l.UL,
  l.VAR
]);
function fL(e) {
  const t = e.tagID;
  return t === l.FONT && e.attrs.some(({ name: r }) => r === ga.COLOR || r === ga.SIZE || r === ga.FACE) || cL.has(t);
}
function yb(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === sL) {
      e.attrs[t].name = oL;
      break;
    }
}
function _b(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = uL.get(e.attrs[t].name);
    n != null && (e.attrs[t].name = n);
  }
}
function qf(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = VL.get(e.attrs[t].name);
    n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace);
  }
}
function dL(e) {
  const t = lL.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = Ki(e.tagName));
}
function hL(e, t) {
  return t === re.MATHML && (e === l.MI || e === l.MO || e === l.MN || e === l.MS || e === l.MTEXT);
}
function mL(e, t, n) {
  if (t === re.MATHML && e === l.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === ga.ENCODING) {
        const a = n[r].value.toLowerCase();
        return a === Cm.TEXT_HTML || a === Cm.APPLICATION_XML;
      }
  }
  return t === re.SVG && (e === l.FOREIGN_OBJECT || e === l.DESC || e === l.TITLE);
}
function pL(e, t, n, r) {
  return (!r || r === re.HTML) && mL(e, t, n) || (!r || r === re.MATHML) && hL(e, t);
}
const gL = "hidden", bL = 8, AL = 3;
var R;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(R || (R = {}));
const EL = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, Cb = /* @__PURE__ */ new Set([l.TABLE, l.TBODY, l.TFOOT, l.THEAD, l.TR]), Sm = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: yi,
  onParseError: null
};
class xm {
  constructor(t, n, r = null, a = null) {
    this.fragmentContext = r, this.scriptHandler = a, this.currentToken = null, this.stopped = !1, this.insertionMode = R.INITIAL, this.originalInsertionMode = R.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...Sm,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new G8(this.options, this), this.activeFormattingElements = new Q8(this.treeAdapter), this.fragmentContextID = r ? Ki(this.treeAdapter.getTagName(r)) : l.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new Z8(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, n) {
    const r = new this(n);
    return r.tokenizer.write(t, !0), r.document;
  }
  static getFragmentParser(t, n) {
    const r = {
      ...Sm,
      ...n
    };
    t ?? (t = r.treeAdapter.createElement(Y.TEMPLATE, re.HTML, []));
    const a = r.treeAdapter.createElement("documentmock", re.HTML, []), i = new this(r, a, t);
    return i.fragmentContextID === l.TEMPLATE && i.tmplInsertionModeStack.unshift(R.IN_TEMPLATE), i._initTokenizerForFragmentParsing(), i._insertFakeRootElement(), i._resetInsertionMode(), i._findFormInFragmentContext(), i;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, n), n;
  }
  //Errors
  _err(t, n, r) {
    var a;
    if (!this.onParseError)
      return;
    const i = (a = t.location) !== null && a !== void 0 ? a : EL, s = {
      code: n,
      startLine: i.startLine,
      startCol: i.startCol,
      startOffset: i.startOffset,
      endLine: r ? i.startLine : i.endLine,
      endCol: r ? i.startCol : i.endCol,
      endOffset: r ? i.startOffset : i.endOffset
    };
    this.onParseError(s);
  }
  //Stack events
  onItemPush(t, n, r) {
    var a, i;
    (i = (a = this.treeAdapter).onItemPush) === null || i === void 0 || i.call(a, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n);
  }
  onItemPop(t, n) {
    var r, a;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (a = (r = this.treeAdapter).onItemPop) === null || a === void 0 || a.call(r, t, this.openElements.current), n) {
      let i, s;
      this.openElements.stackTop === 0 && this.fragmentContext ? (i = this.fragmentContext, s = this.fragmentContextID) : { current: i, currentTagId: s } = this.openElements, this._setContextModes(i, s);
    }
  }
  _setContextModes(t, n) {
    const r = t === this.document || this.treeAdapter.getNamespaceURI(t) === re.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(n, t);
  }
  _switchToTextParsing(t, n) {
    this._insertElement(t, re.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = R.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = R.TEXT, this.originalInsertionMode = R.IN_BODY, this.tokenizer.state = Gt.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === Y.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== re.HTML))
      switch (this.fragmentContextID) {
        case l.TITLE:
        case l.TEXTAREA: {
          this.tokenizer.state = Gt.RCDATA;
          break;
        }
        case l.STYLE:
        case l.XMP:
        case l.IFRAME:
        case l.NOEMBED:
        case l.NOFRAMES:
        case l.NOSCRIPT: {
          this.tokenizer.state = Gt.RAWTEXT;
          break;
        }
        case l.SCRIPT: {
          this.tokenizer.state = Gt.SCRIPT_DATA;
          break;
        }
        case l.PLAINTEXT: {
          this.tokenizer.state = Gt.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  _setDocumentType(t) {
    const n = t.name || "", r = t.publicId || "", a = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, a), t.location) {
      const s = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      s && this.treeAdapter.setNodeSourceCodeLocation(s, t.location);
    }
  }
  _attachElementToTree(t, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r, t);
    }
  }
  _appendElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location);
  }
  _insertElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID);
  }
  _insertFakeElement(t, n) {
    const r = this.treeAdapter.createElement(t, re.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  _insertTemplate(t) {
    const n = this.treeAdapter.createElement(t.tagName, re.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, t.location), this.openElements.push(n, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(Y.HTML, re.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, l.HTML);
  }
  _appendCommentNode(t, n) {
    const r = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location);
  }
  _insertCharacters(t) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, t.chars, r) : this.treeAdapter.insertText(n, t.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t.chars)), !t.location)
      return;
    const a = this.treeAdapter.getChildNodes(n), i = r ? a.lastIndexOf(r) : a.length, s = a[i - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(s)) {
      const { endLine: u, endCol: V, endOffset: c } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(s, { endLine: u, endCol: V, endOffset: c });
    } else
      this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(s, t.location);
  }
  _adoptNodes(t, n) {
    for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  _setEndLocation(t, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) {
      const r = n.location, a = this.treeAdapter.getTagName(t), i = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === Ze.END_TAG && a === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, i);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, t.tagID === l.SVG && this.treeAdapter.getTagName(n) === Y.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === re.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === l.MGLYPH || t.tagID === l.MALIGNMARK) && !this._isIntegrationPoint(r, n, re.HTML)
    );
  }
  _processToken(t) {
    switch (t.type) {
      case Ze.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case Ze.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case Ze.COMMENT: {
        this.onComment(t);
        break;
      }
      case Ze.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case Ze.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case Ze.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case Ze.EOF: {
        this.onEof(t);
        break;
      }
      case Ze.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(t, n, r) {
    const a = this.treeAdapter.getNamespaceURI(n), i = this.treeAdapter.getAttrList(n);
    return pL(t, a, i, r);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const n = this.activeFormattingElements.entries.findIndex((a) => a.type === mr.Marker || this.openElements.contains(a.element)), r = n < 0 ? t - 1 : n - 1;
      for (let a = r; a >= 0; a--) {
        const i = this.activeFormattingElements.entries[a];
        this._insertElement(i.token, this.treeAdapter.getNamespaceURI(i.element)), i.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = R.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(l.P), this.openElements.popUntilTagNamePopped(l.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case l.TR: {
          this.insertionMode = R.IN_ROW;
          return;
        }
        case l.TBODY:
        case l.THEAD:
        case l.TFOOT: {
          this.insertionMode = R.IN_TABLE_BODY;
          return;
        }
        case l.CAPTION: {
          this.insertionMode = R.IN_CAPTION;
          return;
        }
        case l.COLGROUP: {
          this.insertionMode = R.IN_COLUMN_GROUP;
          return;
        }
        case l.TABLE: {
          this.insertionMode = R.IN_TABLE;
          return;
        }
        case l.BODY: {
          this.insertionMode = R.IN_BODY;
          return;
        }
        case l.FRAMESET: {
          this.insertionMode = R.IN_FRAMESET;
          return;
        }
        case l.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case l.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case l.HTML: {
          this.insertionMode = this.headElement ? R.AFTER_HEAD : R.BEFORE_HEAD;
          return;
        }
        case l.TD:
        case l.TH: {
          if (t > 0) {
            this.insertionMode = R.IN_CELL;
            return;
          }
          break;
        }
        case l.HEAD: {
          if (t > 0) {
            this.insertionMode = R.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = R.IN_BODY;
  }
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let n = t - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === l.TEMPLATE)
          break;
        if (r === l.TABLE) {
          this.insertionMode = R.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = R.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(t) {
    return Cb.has(t);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const n = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case l.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === re.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case l.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(t) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t);
  }
  //Special elements
  _isSpecialElement(t, n) {
    const r = this.treeAdapter.getNamespaceURI(t);
    return $8[r].has(n);
  }
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      KP(this, t);
      return;
    }
    switch (this.insertionMode) {
      case R.INITIAL: {
        ds(this, t);
        break;
      }
      case R.BEFORE_HTML: {
        vs(this, t);
        break;
      }
      case R.BEFORE_HEAD: {
        Ts(this, t);
        break;
      }
      case R.IN_HEAD: {
        ys(this, t);
        break;
      }
      case R.IN_HEAD_NO_SCRIPT: {
        _s(this, t);
        break;
      }
      case R.AFTER_HEAD: {
        Cs(this, t);
        break;
      }
      case R.IN_BODY:
      case R.IN_CAPTION:
      case R.IN_CELL:
      case R.IN_TEMPLATE: {
        xb(this, t);
        break;
      }
      case R.TEXT:
      case R.IN_SELECT:
      case R.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case R.IN_TABLE:
      case R.IN_TABLE_BODY:
      case R.IN_ROW: {
        DV(this, t);
        break;
      }
      case R.IN_TABLE_TEXT: {
        kb(this, t);
        break;
      }
      case R.IN_COLUMN_GROUP: {
        lu(this, t);
        break;
      }
      case R.AFTER_BODY: {
        cu(this, t);
        break;
      }
      case R.AFTER_AFTER_BODY: {
        ko(this, t);
        break;
      }
    }
  }
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      XP(this, t);
      return;
    }
    switch (this.insertionMode) {
      case R.INITIAL: {
        ds(this, t);
        break;
      }
      case R.BEFORE_HTML: {
        vs(this, t);
        break;
      }
      case R.BEFORE_HEAD: {
        Ts(this, t);
        break;
      }
      case R.IN_HEAD: {
        ys(this, t);
        break;
      }
      case R.IN_HEAD_NO_SCRIPT: {
        _s(this, t);
        break;
      }
      case R.AFTER_HEAD: {
        Cs(this, t);
        break;
      }
      case R.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case R.IN_TABLE:
      case R.IN_TABLE_BODY:
      case R.IN_ROW: {
        DV(this, t);
        break;
      }
      case R.IN_COLUMN_GROUP: {
        lu(this, t);
        break;
      }
      case R.AFTER_BODY: {
        cu(this, t);
        break;
      }
      case R.AFTER_AFTER_BODY: {
        ko(this, t);
        break;
      }
    }
  }
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      Pc(this, t);
      return;
    }
    switch (this.insertionMode) {
      case R.INITIAL:
      case R.BEFORE_HTML:
      case R.BEFORE_HEAD:
      case R.IN_HEAD:
      case R.IN_HEAD_NO_SCRIPT:
      case R.AFTER_HEAD:
      case R.IN_BODY:
      case R.IN_TABLE:
      case R.IN_CAPTION:
      case R.IN_COLUMN_GROUP:
      case R.IN_TABLE_BODY:
      case R.IN_ROW:
      case R.IN_CELL:
      case R.IN_SELECT:
      case R.IN_SELECT_IN_TABLE:
      case R.IN_TEMPLATE:
      case R.IN_FRAMESET:
      case R.AFTER_FRAMESET: {
        Pc(this, t);
        break;
      }
      case R.IN_TABLE_TEXT: {
        hs(this, t);
        break;
      }
      case R.AFTER_BODY: {
        xL(this, t);
        break;
      }
      case R.AFTER_AFTER_BODY:
      case R.AFTER_AFTER_FRAMESET: {
        OL(this, t);
        break;
      }
    }
  }
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case R.INITIAL: {
        wL(this, t);
        break;
      }
      case R.BEFORE_HEAD:
      case R.IN_HEAD:
      case R.IN_HEAD_NO_SCRIPT:
      case R.AFTER_HEAD: {
        this._err(t, Z.misplacedDoctype);
        break;
      }
      case R.IN_TABLE_TEXT: {
        hs(this, t);
        break;
      }
    }
  }
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, Z.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? ZP(this, t) : this._startTagOutsideForeignContent(t);
  }
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case R.INITIAL: {
        ds(this, t);
        break;
      }
      case R.BEFORE_HTML: {
        IL(this, t);
        break;
      }
      case R.BEFORE_HEAD: {
        NL(this, t);
        break;
      }
      case R.IN_HEAD: {
        Cr(this, t);
        break;
      }
      case R.IN_HEAD_NO_SCRIPT: {
        PL(this, t);
        break;
      }
      case R.AFTER_HEAD: {
        ML(this, t);
        break;
      }
      case R.IN_BODY: {
        bn(this, t);
        break;
      }
      case R.IN_TABLE: {
        Fi(this, t);
        break;
      }
      case R.IN_TABLE_TEXT: {
        hs(this, t);
        break;
      }
      case R.IN_CAPTION: {
        kP(this, t);
        break;
      }
      case R.IN_COLUMN_GROUP: {
        Zf(this, t);
        break;
      }
      case R.IN_TABLE_BODY: {
        Bu(this, t);
        break;
      }
      case R.IN_ROW: {
        $u(this, t);
        break;
      }
      case R.IN_CELL: {
        DP(this, t);
        break;
      }
      case R.IN_SELECT: {
        Db(this, t);
        break;
      }
      case R.IN_SELECT_IN_TABLE: {
        FP(this, t);
        break;
      }
      case R.IN_TEMPLATE: {
        $P(this, t);
        break;
      }
      case R.AFTER_BODY: {
        HP(this, t);
        break;
      }
      case R.IN_FRAMESET: {
        jP(this, t);
        break;
      }
      case R.AFTER_FRAMESET: {
        GP(this, t);
        break;
      }
      case R.AFTER_AFTER_BODY: {
        WP(this, t);
        break;
      }
      case R.AFTER_AFTER_FRAMESET: {
        qP(this, t);
        break;
      }
    }
  }
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? QP(this, t) : this._endTagOutsideForeignContent(t);
  }
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case R.INITIAL: {
        ds(this, t);
        break;
      }
      case R.BEFORE_HTML: {
        RL(this, t);
        break;
      }
      case R.BEFORE_HEAD: {
        kL(this, t);
        break;
      }
      case R.IN_HEAD: {
        LL(this, t);
        break;
      }
      case R.IN_HEAD_NO_SCRIPT: {
        DL(this, t);
        break;
      }
      case R.AFTER_HEAD: {
        FL(this, t);
        break;
      }
      case R.IN_BODY: {
        Fu(this, t);
        break;
      }
      case R.TEXT: {
        yP(this, t);
        break;
      }
      case R.IN_TABLE: {
        Zs(this, t);
        break;
      }
      case R.IN_TABLE_TEXT: {
        hs(this, t);
        break;
      }
      case R.IN_CAPTION: {
        LP(this, t);
        break;
      }
      case R.IN_COLUMN_GROUP: {
        PP(this, t);
        break;
      }
      case R.IN_TABLE_BODY: {
        Dc(this, t);
        break;
      }
      case R.IN_ROW: {
        Pb(this, t);
        break;
      }
      case R.IN_CELL: {
        MP(this, t);
        break;
      }
      case R.IN_SELECT: {
        Mb(this, t);
        break;
      }
      case R.IN_SELECT_IN_TABLE: {
        BP(this, t);
        break;
      }
      case R.IN_TEMPLATE: {
        UP(this, t);
        break;
      }
      case R.AFTER_BODY: {
        Bb(this, t);
        break;
      }
      case R.IN_FRAMESET: {
        zP(this, t);
        break;
      }
      case R.AFTER_FRAMESET: {
        YP(this, t);
        break;
      }
      case R.AFTER_AFTER_BODY: {
        ko(this, t);
        break;
      }
    }
  }
  onEof(t) {
    switch (this.insertionMode) {
      case R.INITIAL: {
        ds(this, t);
        break;
      }
      case R.BEFORE_HTML: {
        vs(this, t);
        break;
      }
      case R.BEFORE_HEAD: {
        Ts(this, t);
        break;
      }
      case R.IN_HEAD: {
        ys(this, t);
        break;
      }
      case R.IN_HEAD_NO_SCRIPT: {
        _s(this, t);
        break;
      }
      case R.AFTER_HEAD: {
        Cs(this, t);
        break;
      }
      case R.IN_BODY:
      case R.IN_TABLE:
      case R.IN_CAPTION:
      case R.IN_COLUMN_GROUP:
      case R.IN_TABLE_BODY:
      case R.IN_ROW:
      case R.IN_CELL:
      case R.IN_SELECT:
      case R.IN_SELECT_IN_TABLE: {
        Rb(this, t);
        break;
      }
      case R.TEXT: {
        _P(this, t);
        break;
      }
      case R.IN_TABLE_TEXT: {
        hs(this, t);
        break;
      }
      case R.IN_TEMPLATE: {
        Fb(this, t);
        break;
      }
      case R.AFTER_BODY:
      case R.IN_FRAMESET:
      case R.AFTER_FRAMESET:
      case R.AFTER_AFTER_BODY:
      case R.AFTER_AFTER_FRAMESET: {
        Kf(this, t);
        break;
      }
    }
  }
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === T.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case R.IN_HEAD:
      case R.IN_HEAD_NO_SCRIPT:
      case R.AFTER_HEAD:
      case R.TEXT:
      case R.IN_COLUMN_GROUP:
      case R.IN_SELECT:
      case R.IN_SELECT_IN_TABLE:
      case R.IN_FRAMESET:
      case R.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case R.IN_BODY:
      case R.IN_CAPTION:
      case R.IN_CELL:
      case R.IN_TEMPLATE:
      case R.AFTER_BODY:
      case R.AFTER_AFTER_BODY:
      case R.AFTER_AFTER_FRAMESET: {
        Sb(this, t);
        break;
      }
      case R.IN_TABLE:
      case R.IN_TABLE_BODY:
      case R.IN_ROW: {
        DV(this, t);
        break;
      }
      case R.IN_TABLE_TEXT: {
        Nb(this, t);
        break;
      }
    }
  }
}
function vL(e, t) {
  let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : Ib(e, t), n;
}
function TL(e, t) {
  let n = null, r = e.openElements.stackTop;
  for (; r >= 0; r--) {
    const a = e.openElements.items[r];
    if (a === t.element)
      break;
    e._isSpecialElement(a, e.openElements.tagIDs[r]) && (n = a);
  }
  return n || (e.openElements.shortenToLength(r < 0 ? 0 : r), e.activeFormattingElements.removeEntry(t)), n;
}
function yL(e, t, n) {
  let r = t, a = e.openElements.getCommonAncestor(t);
  for (let i = 0, s = a; s !== n; i++, s = a) {
    a = e.openElements.getCommonAncestor(s);
    const o = e.activeFormattingElements.getElementEntry(s), u = o && i >= AL;
    !o || u ? (u && e.activeFormattingElements.removeEntry(o), e.openElements.remove(s)) : (s = _L(e, o), r === t && (e.activeFormattingElements.bookmark = o), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(s, r), r = s);
  }
  return r;
}
function _L(e, t) {
  const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs);
  return e.openElements.replace(t.element, r), t.element = r, r;
}
function CL(e, t, n) {
  const r = e.treeAdapter.getTagName(t), a = Ki(r);
  if (e._isElementCausesFosterParenting(a))
    e._fosterParentElement(n);
  else {
    const i = e.treeAdapter.getNamespaceURI(t);
    a === l.TEMPLATE && i === re.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n);
  }
}
function SL(e, t, n) {
  const r = e.treeAdapter.getNamespaceURI(n.element), { token: a } = n, i = e.treeAdapter.createElement(a.tagName, r, a.attrs);
  e._adoptNodes(t, i), e.treeAdapter.appendChild(t, i), e.activeFormattingElements.insertElementAfterBookmark(i, a), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, i, a.tagID);
}
function Xf(e, t) {
  for (let n = 0; n < bL; n++) {
    const r = vL(e, t);
    if (!r)
      break;
    const a = TL(e, r);
    if (!a)
      break;
    e.activeFormattingElements.bookmark = r;
    const i = yL(e, a, r.element), s = e.openElements.getCommonAncestor(r.element);
    e.treeAdapter.detachNode(i), s && CL(e, s, i), SL(e, a, r);
  }
}
function Pc(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function xL(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function OL(e, t) {
  e._appendCommentNode(t, e.document);
}
function Kf(e, t) {
  if (e.stopped = !0, t.location) {
    const n = e.fragmentContext ? 0 : 2;
    for (let r = e.openElements.stackTop; r >= n; r--)
      e._setEndLocation(e.openElements.items[r], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const r = e.openElements.items[0], a = e.treeAdapter.getNodeSourceCodeLocation(r);
      if (a && !a.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) {
        const i = e.openElements.items[1], s = e.treeAdapter.getNodeSourceCodeLocation(i);
        s && !s.endTag && e._setEndLocation(i, t);
      }
    }
  }
}
function wL(e, t) {
  e._setDocumentType(t);
  const n = t.forceQuirks ? Un.QUIRKS : iL(t);
  aL(t) || e._err(t, Z.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = R.BEFORE_HTML;
}
function ds(e, t) {
  e._err(t, Z.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, Un.QUIRKS), e.insertionMode = R.BEFORE_HTML, e._processToken(t);
}
function IL(e, t) {
  t.tagID === l.HTML ? (e._insertElement(t, re.HTML), e.insertionMode = R.BEFORE_HEAD) : vs(e, t);
}
function RL(e, t) {
  const n = t.tagID;
  (n === l.HTML || n === l.HEAD || n === l.BODY || n === l.BR) && vs(e, t);
}
function vs(e, t) {
  e._insertFakeRootElement(), e.insertionMode = R.BEFORE_HEAD, e._processToken(t);
}
function NL(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      bn(e, t);
      break;
    }
    case l.HEAD: {
      e._insertElement(t, re.HTML), e.headElement = e.openElements.current, e.insertionMode = R.IN_HEAD;
      break;
    }
    default:
      Ts(e, t);
  }
}
function kL(e, t) {
  const n = t.tagID;
  n === l.HEAD || n === l.BODY || n === l.HTML || n === l.BR ? Ts(e, t) : e._err(t, Z.endTagWithoutMatchingOpenElement);
}
function Ts(e, t) {
  e._insertFakeElement(Y.HEAD, l.HEAD), e.headElement = e.openElements.current, e.insertionMode = R.IN_HEAD, e._processToken(t);
}
function Cr(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      bn(e, t);
      break;
    }
    case l.BASE:
    case l.BASEFONT:
    case l.BGSOUND:
    case l.LINK:
    case l.META: {
      e._appendElement(t, re.HTML), t.ackSelfClosing = !0;
      break;
    }
    case l.TITLE: {
      e._switchToTextParsing(t, Gt.RCDATA);
      break;
    }
    case l.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, Gt.RAWTEXT) : (e._insertElement(t, re.HTML), e.insertionMode = R.IN_HEAD_NO_SCRIPT);
      break;
    }
    case l.NOFRAMES:
    case l.STYLE: {
      e._switchToTextParsing(t, Gt.RAWTEXT);
      break;
    }
    case l.SCRIPT: {
      e._switchToTextParsing(t, Gt.SCRIPT_DATA);
      break;
    }
    case l.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = R.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(R.IN_TEMPLATE);
      break;
    }
    case l.HEAD: {
      e._err(t, Z.misplacedStartTagForHeadElement);
      break;
    }
    default:
      ys(e, t);
  }
}
function LL(e, t) {
  switch (t.tagID) {
    case l.HEAD: {
      e.openElements.pop(), e.insertionMode = R.AFTER_HEAD;
      break;
    }
    case l.BODY:
    case l.BR:
    case l.HTML: {
      ys(e, t);
      break;
    }
    case l.TEMPLATE: {
      ii(e, t);
      break;
    }
    default:
      e._err(t, Z.endTagWithoutMatchingOpenElement);
  }
}
function ii(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== l.TEMPLATE && e._err(t, Z.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(l.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, Z.endTagWithoutMatchingOpenElement);
}
function ys(e, t) {
  e.openElements.pop(), e.insertionMode = R.AFTER_HEAD, e._processToken(t);
}
function PL(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      bn(e, t);
      break;
    }
    case l.BASEFONT:
    case l.BGSOUND:
    case l.HEAD:
    case l.LINK:
    case l.META:
    case l.NOFRAMES:
    case l.STYLE: {
      Cr(e, t);
      break;
    }
    case l.NOSCRIPT: {
      e._err(t, Z.nestedNoscriptInHead);
      break;
    }
    default:
      _s(e, t);
  }
}
function DL(e, t) {
  switch (t.tagID) {
    case l.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = R.IN_HEAD;
      break;
    }
    case l.BR: {
      _s(e, t);
      break;
    }
    default:
      e._err(t, Z.endTagWithoutMatchingOpenElement);
  }
}
function _s(e, t) {
  const n = t.type === Ze.EOF ? Z.openElementsLeftAfterEof : Z.disallowedContentInNoscriptInHead;
  e._err(t, n), e.openElements.pop(), e.insertionMode = R.IN_HEAD, e._processToken(t);
}
function ML(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      bn(e, t);
      break;
    }
    case l.BODY: {
      e._insertElement(t, re.HTML), e.framesetOk = !1, e.insertionMode = R.IN_BODY;
      break;
    }
    case l.FRAMESET: {
      e._insertElement(t, re.HTML), e.insertionMode = R.IN_FRAMESET;
      break;
    }
    case l.BASE:
    case l.BASEFONT:
    case l.BGSOUND:
    case l.LINK:
    case l.META:
    case l.NOFRAMES:
    case l.SCRIPT:
    case l.STYLE:
    case l.TEMPLATE:
    case l.TITLE: {
      e._err(t, Z.abandonedHeadElementChild), e.openElements.push(e.headElement, l.HEAD), Cr(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case l.HEAD: {
      e._err(t, Z.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Cs(e, t);
  }
}
function FL(e, t) {
  switch (t.tagID) {
    case l.BODY:
    case l.HTML:
    case l.BR: {
      Cs(e, t);
      break;
    }
    case l.TEMPLATE: {
      ii(e, t);
      break;
    }
    default:
      e._err(t, Z.endTagWithoutMatchingOpenElement);
  }
}
function Cs(e, t) {
  e._insertFakeElement(Y.BODY, l.BODY), e.insertionMode = R.IN_BODY, Mu(e, t);
}
function Mu(e, t) {
  switch (t.type) {
    case Ze.CHARACTER: {
      xb(e, t);
      break;
    }
    case Ze.WHITESPACE_CHARACTER: {
      Sb(e, t);
      break;
    }
    case Ze.COMMENT: {
      Pc(e, t);
      break;
    }
    case Ze.START_TAG: {
      bn(e, t);
      break;
    }
    case Ze.END_TAG: {
      Fu(e, t);
      break;
    }
    case Ze.EOF: {
      Rb(e, t);
      break;
    }
  }
}
function Sb(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function xb(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function BL(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function $L(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  n && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs));
}
function UL(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, re.HTML), e.insertionMode = R.IN_FRAMESET);
}
function HL(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, re.HTML);
}
function jL(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), mb(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, re.HTML);
}
function zL(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, re.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function GL(e, t) {
  const n = e.openElements.tmplCount > 0;
  (!e.formElement || n) && (e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, re.HTML), n || (e.formElement = e.openElements.current));
}
function YL(e, t) {
  e.framesetOk = !1;
  const n = t.tagID;
  for (let r = e.openElements.stackTop; r >= 0; r--) {
    const a = e.openElements.tagIDs[r];
    if (n === l.LI && a === l.LI || (n === l.DD || n === l.DT) && (a === l.DD || a === l.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(a), e.openElements.popUntilTagNamePopped(a);
      break;
    }
    if (a !== l.ADDRESS && a !== l.DIV && a !== l.P && e._isSpecialElement(e.openElements.items[r], a))
      break;
  }
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, re.HTML);
}
function WL(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, re.HTML), e.tokenizer.state = Gt.PLAINTEXT;
}
function qL(e, t) {
  e.openElements.hasInScope(l.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(l.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, re.HTML), e.framesetOk = !1;
}
function XL(e, t) {
  const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(Y.A);
  n && (Xf(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, re.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function KL(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, re.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function ZL(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(l.NOBR) && (Xf(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, re.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function QL(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, re.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function JL(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== Un.QUIRKS && e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._insertElement(t, re.HTML), e.framesetOk = !1, e.insertionMode = R.IN_TABLE;
}
function Ob(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, re.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function wb(e) {
  const t = fb(e, ga.TYPE);
  return t != null && t.toLowerCase() === gL;
}
function eP(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, re.HTML), wb(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function tP(e, t) {
  e._appendElement(t, re.HTML), t.ackSelfClosing = !0;
}
function nP(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._appendElement(t, re.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function rP(e, t) {
  t.tagName = Y.IMG, t.tagID = l.IMG, Ob(e, t);
}
function aP(e, t) {
  e._insertElement(t, re.HTML), e.skipNextNewLine = !0, e.tokenizer.state = Gt.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = R.TEXT;
}
function iP(e, t) {
  e.openElements.hasInButtonScope(l.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, Gt.RAWTEXT);
}
function sP(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, Gt.RAWTEXT);
}
function Om(e, t) {
  e._switchToTextParsing(t, Gt.RAWTEXT);
}
function oP(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, re.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === R.IN_TABLE || e.insertionMode === R.IN_CAPTION || e.insertionMode === R.IN_TABLE_BODY || e.insertionMode === R.IN_ROW || e.insertionMode === R.IN_CELL ? R.IN_SELECT_IN_TABLE : R.IN_SELECT;
}
function uP(e, t) {
  e.openElements.currentTagId === l.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, re.HTML);
}
function VP(e, t) {
  e.openElements.hasInScope(l.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, re.HTML);
}
function lP(e, t) {
  e.openElements.hasInScope(l.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(l.RTC), e._insertElement(t, re.HTML);
}
function cP(e, t) {
  e._reconstructActiveFormattingElements(), yb(t), qf(t), t.selfClosing ? e._appendElement(t, re.MATHML) : e._insertElement(t, re.MATHML), t.ackSelfClosing = !0;
}
function fP(e, t) {
  e._reconstructActiveFormattingElements(), _b(t), qf(t), t.selfClosing ? e._appendElement(t, re.SVG) : e._insertElement(t, re.SVG), t.ackSelfClosing = !0;
}
function wm(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, re.HTML);
}
function bn(e, t) {
  switch (t.tagID) {
    case l.I:
    case l.S:
    case l.B:
    case l.U:
    case l.EM:
    case l.TT:
    case l.BIG:
    case l.CODE:
    case l.FONT:
    case l.SMALL:
    case l.STRIKE:
    case l.STRONG: {
      KL(e, t);
      break;
    }
    case l.A: {
      XL(e, t);
      break;
    }
    case l.H1:
    case l.H2:
    case l.H3:
    case l.H4:
    case l.H5:
    case l.H6: {
      jL(e, t);
      break;
    }
    case l.P:
    case l.DL:
    case l.OL:
    case l.UL:
    case l.DIV:
    case l.DIR:
    case l.NAV:
    case l.MAIN:
    case l.MENU:
    case l.ASIDE:
    case l.CENTER:
    case l.FIGURE:
    case l.FOOTER:
    case l.HEADER:
    case l.HGROUP:
    case l.DIALOG:
    case l.DETAILS:
    case l.ADDRESS:
    case l.ARTICLE:
    case l.SECTION:
    case l.SUMMARY:
    case l.FIELDSET:
    case l.BLOCKQUOTE:
    case l.FIGCAPTION: {
      HL(e, t);
      break;
    }
    case l.LI:
    case l.DD:
    case l.DT: {
      YL(e, t);
      break;
    }
    case l.BR:
    case l.IMG:
    case l.WBR:
    case l.AREA:
    case l.EMBED:
    case l.KEYGEN: {
      Ob(e, t);
      break;
    }
    case l.HR: {
      nP(e, t);
      break;
    }
    case l.RB:
    case l.RTC: {
      VP(e, t);
      break;
    }
    case l.RT:
    case l.RP: {
      lP(e, t);
      break;
    }
    case l.PRE:
    case l.LISTING: {
      zL(e, t);
      break;
    }
    case l.XMP: {
      iP(e, t);
      break;
    }
    case l.SVG: {
      fP(e, t);
      break;
    }
    case l.HTML: {
      BL(e, t);
      break;
    }
    case l.BASE:
    case l.LINK:
    case l.META:
    case l.STYLE:
    case l.TITLE:
    case l.SCRIPT:
    case l.BGSOUND:
    case l.BASEFONT:
    case l.TEMPLATE: {
      Cr(e, t);
      break;
    }
    case l.BODY: {
      $L(e, t);
      break;
    }
    case l.FORM: {
      GL(e, t);
      break;
    }
    case l.NOBR: {
      ZL(e, t);
      break;
    }
    case l.MATH: {
      cP(e, t);
      break;
    }
    case l.TABLE: {
      JL(e, t);
      break;
    }
    case l.INPUT: {
      eP(e, t);
      break;
    }
    case l.PARAM:
    case l.TRACK:
    case l.SOURCE: {
      tP(e, t);
      break;
    }
    case l.IMAGE: {
      rP(e, t);
      break;
    }
    case l.BUTTON: {
      qL(e, t);
      break;
    }
    case l.APPLET:
    case l.OBJECT:
    case l.MARQUEE: {
      QL(e, t);
      break;
    }
    case l.IFRAME: {
      sP(e, t);
      break;
    }
    case l.SELECT: {
      oP(e, t);
      break;
    }
    case l.OPTION:
    case l.OPTGROUP: {
      uP(e, t);
      break;
    }
    case l.NOEMBED: {
      Om(e, t);
      break;
    }
    case l.FRAMESET: {
      UL(e, t);
      break;
    }
    case l.TEXTAREA: {
      aP(e, t);
      break;
    }
    case l.NOSCRIPT: {
      e.options.scriptingEnabled ? Om(e, t) : wm(e, t);
      break;
    }
    case l.PLAINTEXT: {
      WL(e, t);
      break;
    }
    case l.COL:
    case l.TH:
    case l.TD:
    case l.TR:
    case l.HEAD:
    case l.FRAME:
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD:
    case l.CAPTION:
    case l.COLGROUP:
      break;
    default:
      wm(e, t);
  }
}
function dP(e, t) {
  if (e.openElements.hasInScope(l.BODY) && (e.insertionMode = R.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const n = e.openElements.tryPeekProperlyNestedBodyElement();
    n && e._setEndLocation(n, t);
  }
}
function hP(e, t) {
  e.openElements.hasInScope(l.BODY) && (e.insertionMode = R.AFTER_BODY, Bb(e, t));
}
function mP(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n));
}
function pP(e) {
  const t = e.openElements.tmplCount > 0, { formElement: n } = e;
  t || (e.formElement = null), (n || t) && e.openElements.hasInScope(l.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(l.FORM) : n && e.openElements.remove(n));
}
function gP(e) {
  e.openElements.hasInButtonScope(l.P) || e._insertFakeElement(Y.P, l.P), e._closePElement();
}
function bP(e) {
  e.openElements.hasInListItemScope(l.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(l.LI), e.openElements.popUntilTagNamePopped(l.LI));
}
function AP(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n));
}
function EP(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function vP(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker());
}
function TP(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(Y.BR, l.BR), e.openElements.pop(), e.framesetOk = !1;
}
function Ib(e, t) {
  const n = t.tagName, r = t.tagID;
  for (let a = e.openElements.stackTop; a > 0; a--) {
    const i = e.openElements.items[a], s = e.openElements.tagIDs[a];
    if (r === s && (r !== l.UNKNOWN || e.treeAdapter.getTagName(i) === n)) {
      e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= a && e.openElements.shortenToLength(a);
      break;
    }
    if (e._isSpecialElement(i, s))
      break;
  }
}
function Fu(e, t) {
  switch (t.tagID) {
    case l.A:
    case l.B:
    case l.I:
    case l.S:
    case l.U:
    case l.EM:
    case l.TT:
    case l.BIG:
    case l.CODE:
    case l.FONT:
    case l.NOBR:
    case l.SMALL:
    case l.STRIKE:
    case l.STRONG: {
      Xf(e, t);
      break;
    }
    case l.P: {
      gP(e);
      break;
    }
    case l.DL:
    case l.UL:
    case l.OL:
    case l.DIR:
    case l.DIV:
    case l.NAV:
    case l.PRE:
    case l.MAIN:
    case l.MENU:
    case l.ASIDE:
    case l.BUTTON:
    case l.CENTER:
    case l.FIGURE:
    case l.FOOTER:
    case l.HEADER:
    case l.HGROUP:
    case l.DIALOG:
    case l.ADDRESS:
    case l.ARTICLE:
    case l.DETAILS:
    case l.SECTION:
    case l.SUMMARY:
    case l.LISTING:
    case l.FIELDSET:
    case l.BLOCKQUOTE:
    case l.FIGCAPTION: {
      mP(e, t);
      break;
    }
    case l.LI: {
      bP(e);
      break;
    }
    case l.DD:
    case l.DT: {
      AP(e, t);
      break;
    }
    case l.H1:
    case l.H2:
    case l.H3:
    case l.H4:
    case l.H5:
    case l.H6: {
      EP(e);
      break;
    }
    case l.BR: {
      TP(e);
      break;
    }
    case l.BODY: {
      dP(e, t);
      break;
    }
    case l.HTML: {
      hP(e, t);
      break;
    }
    case l.FORM: {
      pP(e);
      break;
    }
    case l.APPLET:
    case l.OBJECT:
    case l.MARQUEE: {
      vP(e, t);
      break;
    }
    case l.TEMPLATE: {
      ii(e, t);
      break;
    }
    default:
      Ib(e, t);
  }
}
function Rb(e, t) {
  e.tmplInsertionModeStack.length > 0 ? Fb(e, t) : Kf(e, t);
}
function yP(e, t) {
  var n;
  t.tagID === l.SCRIPT && ((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function _P(e, t) {
  e._err(t, Z.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function DV(e, t) {
  if (Cb.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = R.IN_TABLE_TEXT, t.type) {
      case Ze.CHARACTER: {
        kb(e, t);
        break;
      }
      case Ze.WHITESPACE_CHARACTER: {
        Nb(e, t);
        break;
      }
    }
  else
    ao(e, t);
}
function CP(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, re.HTML), e.insertionMode = R.IN_CAPTION;
}
function SP(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, re.HTML), e.insertionMode = R.IN_COLUMN_GROUP;
}
function xP(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(Y.COLGROUP, l.COLGROUP), e.insertionMode = R.IN_COLUMN_GROUP, Zf(e, t);
}
function OP(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, re.HTML), e.insertionMode = R.IN_TABLE_BODY;
}
function wP(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(Y.TBODY, l.TBODY), e.insertionMode = R.IN_TABLE_BODY, Bu(e, t);
}
function IP(e, t) {
  e.openElements.hasInTableScope(l.TABLE) && (e.openElements.popUntilTagNamePopped(l.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function RP(e, t) {
  wb(t) ? e._appendElement(t, re.HTML) : ao(e, t), t.ackSelfClosing = !0;
}
function NP(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, re.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function Fi(e, t) {
  switch (t.tagID) {
    case l.TD:
    case l.TH:
    case l.TR: {
      wP(e, t);
      break;
    }
    case l.STYLE:
    case l.SCRIPT:
    case l.TEMPLATE: {
      Cr(e, t);
      break;
    }
    case l.COL: {
      xP(e, t);
      break;
    }
    case l.FORM: {
      NP(e, t);
      break;
    }
    case l.TABLE: {
      IP(e, t);
      break;
    }
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD: {
      OP(e, t);
      break;
    }
    case l.INPUT: {
      RP(e, t);
      break;
    }
    case l.CAPTION: {
      CP(e, t);
      break;
    }
    case l.COLGROUP: {
      SP(e, t);
      break;
    }
    default:
      ao(e, t);
  }
}
function Zs(e, t) {
  switch (t.tagID) {
    case l.TABLE: {
      e.openElements.hasInTableScope(l.TABLE) && (e.openElements.popUntilTagNamePopped(l.TABLE), e._resetInsertionMode());
      break;
    }
    case l.TEMPLATE: {
      ii(e, t);
      break;
    }
    case l.BODY:
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.HTML:
    case l.TBODY:
    case l.TD:
    case l.TFOOT:
    case l.TH:
    case l.THEAD:
    case l.TR:
      break;
    default:
      ao(e, t);
  }
}
function ao(e, t) {
  const n = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, Mu(e, t), e.fosterParentingEnabled = n;
}
function Nb(e, t) {
  e.pendingCharacterTokens.push(t);
}
function kb(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function hs(e, t) {
  let n = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; n < e.pendingCharacterTokens.length; n++)
      ao(e, e.pendingCharacterTokens[n]);
  else
    for (; n < e.pendingCharacterTokens.length; n++)
      e._insertCharacters(e.pendingCharacterTokens[n]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const Lb = /* @__PURE__ */ new Set([l.CAPTION, l.COL, l.COLGROUP, l.TBODY, l.TD, l.TFOOT, l.TH, l.THEAD, l.TR]);
function kP(e, t) {
  const n = t.tagID;
  Lb.has(n) ? e.openElements.hasInTableScope(l.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(l.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = R.IN_TABLE, Fi(e, t)) : bn(e, t);
}
function LP(e, t) {
  const n = t.tagID;
  switch (n) {
    case l.CAPTION:
    case l.TABLE: {
      e.openElements.hasInTableScope(l.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(l.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = R.IN_TABLE, n === l.TABLE && Zs(e, t));
      break;
    }
    case l.BODY:
    case l.COL:
    case l.COLGROUP:
    case l.HTML:
    case l.TBODY:
    case l.TD:
    case l.TFOOT:
    case l.TH:
    case l.THEAD:
    case l.TR:
      break;
    default:
      Fu(e, t);
  }
}
function Zf(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      bn(e, t);
      break;
    }
    case l.COL: {
      e._appendElement(t, re.HTML), t.ackSelfClosing = !0;
      break;
    }
    case l.TEMPLATE: {
      Cr(e, t);
      break;
    }
    default:
      lu(e, t);
  }
}
function PP(e, t) {
  switch (t.tagID) {
    case l.COLGROUP: {
      e.openElements.currentTagId === l.COLGROUP && (e.openElements.pop(), e.insertionMode = R.IN_TABLE);
      break;
    }
    case l.TEMPLATE: {
      ii(e, t);
      break;
    }
    case l.COL:
      break;
    default:
      lu(e, t);
  }
}
function lu(e, t) {
  e.openElements.currentTagId === l.COLGROUP && (e.openElements.pop(), e.insertionMode = R.IN_TABLE, e._processToken(t));
}
function Bu(e, t) {
  switch (t.tagID) {
    case l.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, re.HTML), e.insertionMode = R.IN_ROW;
      break;
    }
    case l.TH:
    case l.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(Y.TR, l.TR), e.insertionMode = R.IN_ROW, $u(e, t);
      break;
    }
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = R.IN_TABLE, Fi(e, t));
      break;
    }
    default:
      Fi(e, t);
  }
}
function Dc(e, t) {
  const n = t.tagID;
  switch (t.tagID) {
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD: {
      e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = R.IN_TABLE);
      break;
    }
    case l.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = R.IN_TABLE, Zs(e, t));
      break;
    }
    case l.BODY:
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.HTML:
    case l.TD:
    case l.TH:
    case l.TR:
      break;
    default:
      Zs(e, t);
  }
}
function $u(e, t) {
  switch (t.tagID) {
    case l.TH:
    case l.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, re.HTML), e.insertionMode = R.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD:
    case l.TR: {
      e.openElements.hasInTableScope(l.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = R.IN_TABLE_BODY, Bu(e, t));
      break;
    }
    default:
      Fi(e, t);
  }
}
function Pb(e, t) {
  switch (t.tagID) {
    case l.TR: {
      e.openElements.hasInTableScope(l.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = R.IN_TABLE_BODY);
      break;
    }
    case l.TABLE: {
      e.openElements.hasInTableScope(l.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = R.IN_TABLE_BODY, Dc(e, t));
      break;
    }
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(l.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = R.IN_TABLE_BODY, Dc(e, t));
      break;
    }
    case l.BODY:
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.HTML:
    case l.TD:
    case l.TH:
      break;
    default:
      Zs(e, t);
  }
}
function DP(e, t) {
  const n = t.tagID;
  Lb.has(n) ? (e.openElements.hasInTableScope(l.TD) || e.openElements.hasInTableScope(l.TH)) && (e._closeTableCell(), $u(e, t)) : bn(e, t);
}
function MP(e, t) {
  const n = t.tagID;
  switch (n) {
    case l.TD:
    case l.TH: {
      e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = R.IN_ROW);
      break;
    }
    case l.TABLE:
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD:
    case l.TR: {
      e.openElements.hasInTableScope(n) && (e._closeTableCell(), Pb(e, t));
      break;
    }
    case l.BODY:
    case l.CAPTION:
    case l.COL:
    case l.COLGROUP:
    case l.HTML:
      break;
    default:
      Fu(e, t);
  }
}
function Db(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      bn(e, t);
      break;
    }
    case l.OPTION: {
      e.openElements.currentTagId === l.OPTION && e.openElements.pop(), e._insertElement(t, re.HTML);
      break;
    }
    case l.OPTGROUP: {
      e.openElements.currentTagId === l.OPTION && e.openElements.pop(), e.openElements.currentTagId === l.OPTGROUP && e.openElements.pop(), e._insertElement(t, re.HTML);
      break;
    }
    case l.INPUT:
    case l.KEYGEN:
    case l.TEXTAREA:
    case l.SELECT: {
      e.openElements.hasInSelectScope(l.SELECT) && (e.openElements.popUntilTagNamePopped(l.SELECT), e._resetInsertionMode(), t.tagID !== l.SELECT && e._processStartTag(t));
      break;
    }
    case l.SCRIPT:
    case l.TEMPLATE: {
      Cr(e, t);
      break;
    }
  }
}
function Mb(e, t) {
  switch (t.tagID) {
    case l.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === l.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === l.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === l.OPTGROUP && e.openElements.pop();
      break;
    }
    case l.OPTION: {
      e.openElements.currentTagId === l.OPTION && e.openElements.pop();
      break;
    }
    case l.SELECT: {
      e.openElements.hasInSelectScope(l.SELECT) && (e.openElements.popUntilTagNamePopped(l.SELECT), e._resetInsertionMode());
      break;
    }
    case l.TEMPLATE: {
      ii(e, t);
      break;
    }
  }
}
function FP(e, t) {
  const n = t.tagID;
  n === l.CAPTION || n === l.TABLE || n === l.TBODY || n === l.TFOOT || n === l.THEAD || n === l.TR || n === l.TD || n === l.TH ? (e.openElements.popUntilTagNamePopped(l.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : Db(e, t);
}
function BP(e, t) {
  const n = t.tagID;
  n === l.CAPTION || n === l.TABLE || n === l.TBODY || n === l.TFOOT || n === l.THEAD || n === l.TR || n === l.TD || n === l.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(l.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : Mb(e, t);
}
function $P(e, t) {
  switch (t.tagID) {
    case l.BASE:
    case l.BASEFONT:
    case l.BGSOUND:
    case l.LINK:
    case l.META:
    case l.NOFRAMES:
    case l.SCRIPT:
    case l.STYLE:
    case l.TEMPLATE:
    case l.TITLE: {
      Cr(e, t);
      break;
    }
    case l.CAPTION:
    case l.COLGROUP:
    case l.TBODY:
    case l.TFOOT:
    case l.THEAD: {
      e.tmplInsertionModeStack[0] = R.IN_TABLE, e.insertionMode = R.IN_TABLE, Fi(e, t);
      break;
    }
    case l.COL: {
      e.tmplInsertionModeStack[0] = R.IN_COLUMN_GROUP, e.insertionMode = R.IN_COLUMN_GROUP, Zf(e, t);
      break;
    }
    case l.TR: {
      e.tmplInsertionModeStack[0] = R.IN_TABLE_BODY, e.insertionMode = R.IN_TABLE_BODY, Bu(e, t);
      break;
    }
    case l.TD:
    case l.TH: {
      e.tmplInsertionModeStack[0] = R.IN_ROW, e.insertionMode = R.IN_ROW, $u(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = R.IN_BODY, e.insertionMode = R.IN_BODY, bn(e, t);
  }
}
function UP(e, t) {
  t.tagID === l.TEMPLATE && ii(e, t);
}
function Fb(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(l.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : Kf(e, t);
}
function HP(e, t) {
  t.tagID === l.HTML ? bn(e, t) : cu(e, t);
}
function Bb(e, t) {
  var n;
  if (t.tagID === l.HTML) {
    if (e.fragmentContext || (e.insertionMode = R.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === l.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const r = e.openElements.items[1];
      r && !(!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && e._setEndLocation(r, t);
    }
  } else
    cu(e, t);
}
function cu(e, t) {
  e.insertionMode = R.IN_BODY, Mu(e, t);
}
function jP(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      bn(e, t);
      break;
    }
    case l.FRAMESET: {
      e._insertElement(t, re.HTML);
      break;
    }
    case l.FRAME: {
      e._appendElement(t, re.HTML), t.ackSelfClosing = !0;
      break;
    }
    case l.NOFRAMES: {
      Cr(e, t);
      break;
    }
  }
}
function zP(e, t) {
  t.tagID === l.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== l.FRAMESET && (e.insertionMode = R.AFTER_FRAMESET));
}
function GP(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      bn(e, t);
      break;
    }
    case l.NOFRAMES: {
      Cr(e, t);
      break;
    }
  }
}
function YP(e, t) {
  t.tagID === l.HTML && (e.insertionMode = R.AFTER_AFTER_FRAMESET);
}
function WP(e, t) {
  t.tagID === l.HTML ? bn(e, t) : ko(e, t);
}
function ko(e, t) {
  e.insertionMode = R.IN_BODY, Mu(e, t);
}
function qP(e, t) {
  switch (t.tagID) {
    case l.HTML: {
      bn(e, t);
      break;
    }
    case l.NOFRAMES: {
      Cr(e, t);
      break;
    }
  }
}
function XP(e, t) {
  t.chars = Pt, e._insertCharacters(t);
}
function KP(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function $b(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== re.HTML && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function ZP(e, t) {
  if (fL(t))
    $b(e), e._startTagOutsideForeignContent(t);
  else {
    const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n);
    r === re.MATHML ? yb(t) : r === re.SVG && (dL(t), _b(t)), qf(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0;
  }
}
function QP(e, t) {
  if (t.tagID === l.P || t.tagID === l.BR) {
    $b(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let n = e.openElements.stackTop; n > 0; n--) {
    const r = e.openElements.items[n];
    if (e.treeAdapter.getNamespaceURI(r) === re.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const a = e.treeAdapter.getTagName(r);
    if (a.toLowerCase() === t.tagName) {
      t.tagName = a, e.openElements.shortenToLength(n);
      break;
    }
  }
}
Y.AREA, Y.BASE, Y.BASEFONT, Y.BGSOUND, Y.BR, Y.COL, Y.EMBED, Y.FRAME, Y.HR, Y.IMG, Y.INPUT, Y.KEYGEN, Y.LINK, Y.META, Y.PARAM, Y.SOURCE, Y.TRACK, Y.WBR;
const Ub = Hb("end"), si = Hb("start");
function Hb(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
const Uu = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return nD;
    if (typeof e == "function")
      return Hu(e);
    if (typeof e == "object")
      return Array.isArray(e) ? JP(e) : eD(e);
    if (typeof e == "string")
      return tD(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function JP(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Uu(e[n]);
  return Hu(r);
  function r(...a) {
    let i = -1;
    for (; ++i < t.length; )
      if (t[i].apply(this, a))
        return !0;
    return !1;
  }
}
function eD(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Hu(n);
  function n(r) {
    const a = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let i;
    for (i in e)
      if (a[i] !== t[i])
        return !1;
    return !0;
  }
}
function tD(e) {
  return Hu(t);
  function t(n) {
    return n && n.type === e;
  }
}
function Hu(e) {
  return t;
  function t(n, r, a) {
    return !!(rD(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      a || void 0
    ));
  }
}
function nD() {
  return !0;
}
function rD(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const jb = [], aD = !0, Mc = !1, iD = "skip";
function zb(e, t, n, r) {
  let a;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : a = t;
  const i = Uu(a), s = r ? -1 : 1;
  o(e, void 0, [])();
  function o(u, V, c) {
    const f = (
      /** @type {Record<string, unknown>} */
      u && typeof u == "object" ? u : {}
    );
    if (typeof f.type == "string") {
      const h = (
        // `hast`
        typeof f.tagName == "string" ? f.tagName : (
          // `xast`
          typeof f.name == "string" ? f.name : void 0
        )
      );
      Object.defineProperty(p, "name", {
        value: "node (" + (u.type + (h ? "<" + h + ">" : "")) + ")"
      });
    }
    return p;
    function p() {
      let h = jb, g, b, v;
      if ((!t || i(u, V, c[c.length - 1] || void 0)) && (h = sD(n(u, c)), h[0] === Mc))
        return h;
      if ("children" in u && u.children) {
        const x = (
          /** @type {UnistParent} */
          u
        );
        if (x.children && h[0] !== iD)
          for (b = (r ? x.children.length : -1) + s, v = c.concat(x); b > -1 && b < x.children.length; ) {
            const E = x.children[b];
            if (g = o(E, b, v)(), g[0] === Mc)
              return g;
            b = typeof g[1] == "number" ? g[1] : b + s;
          }
      }
      return h;
    }
  }
}
function sD(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [aD, e] : e == null ? jb : [e];
}
function ju(e, t, n, r) {
  let a, i, s;
  typeof t == "function" && typeof n != "function" ? (i = void 0, s = t, a = n) : (i = t, s = n, a = r), zb(e, i, o, a);
  function o(u, V) {
    const c = V[V.length - 1], f = c ? c.children.indexOf(u) : void 0;
    return s(u, f, c);
  }
}
const oD = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), Im = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function Gb(e, t) {
  const n = gD(e), r = ob("type", {
    handlers: { root: uD, element: VD, text: lD, comment: Wb, doctype: cD, raw: dD },
    unknown: hD
  }), a = {
    parser: n ? new xm(Im) : xm.getFragmentParser(void 0, Im),
    handle(o) {
      r(o, a);
    },
    stitches: !1,
    options: t || {}
  };
  r(e, a), Zi(a, si());
  const i = n ? a.parser.document : a.parser.getFragment(), s = c8(i, {
    // To do: support `space`?
    file: a.options.file
  });
  return a.stitches && ju(s, "comment", function(o, u, V) {
    const c = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (c.value.stitch && V && u !== void 0) {
      const f = V.children;
      return f[u] = c.value.stitch, u;
    }
  }), s.type === "root" && s.children.length === 1 && s.children[0].type === e.type ? s.children[0] : s;
}
function Yb(e, t) {
  let n = -1;
  if (e)
    for (; ++n < e.length; )
      t.handle(e[n]);
}
function uD(e, t) {
  Yb(e.children, t);
}
function VD(e, t) {
  mD(e, t), Yb(e.children, t), pD(e, t);
}
function lD(e, t) {
  const n = {
    type: Ze.CHARACTER,
    chars: e.value,
    location: io(e)
  };
  Zi(t, si(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function cD(e, t) {
  const n = {
    type: Ze.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: io(e)
  };
  Zi(t, si(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function fD(e, t) {
  t.stitches = !0;
  const n = bD(e);
  if ("children" in e && "children" in n) {
    const r = (
      /** @type {Root} */
      Gb({ type: "root", children: e.children }, t.options)
    );
    n.children = r.children;
  }
  Wb({ type: "comment", value: { stitch: n } }, t);
}
function Wb(e, t) {
  const n = e.value, r = {
    type: Ze.COMMENT,
    data: n,
    location: io(e)
  };
  Zi(t, si(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function dD(e, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, qb(t, si(e)), t.parser.tokenizer.write(e.value, !1), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const n = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(n);
  }
}
function hD(e, t) {
  const n = (
    /** @type {Nodes} */
    e
  );
  if (t.options.passThrough && t.options.passThrough.includes(n.type))
    fD(n, t);
  else {
    let r = "";
    throw oD.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r);
  }
}
function Zi(e, t) {
  qb(e, t);
  const n = e.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = Gt.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function qb(e, t) {
  if (t && t.offset !== void 0) {
    const n = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n;
  }
}
function mD(e, t) {
  if (t.parser.tokenizer.state === Gt.PLAINTEXT)
    return;
  Zi(t, si(e));
  const n = t.parser.openElements.current;
  let r = "namespaceURI" in n ? n.namespaceURI : Ba.html;
  r === Ba.html && e.tagName === "svg" && (r = Ba.svg);
  const a = p8(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e, children: [] },
    { space: r === Ba.svg ? "svg" : "html" }
  ), i = "attrs" in a ? a.attrs : [], s = {
    type: Ze.START_TAG,
    tagName: e.tagName,
    tagID: Ki(e.tagName),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: i,
    location: io(e)
  };
  t.parser.currentToken = s, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = e.tagName;
}
function pD(e, t) {
  if (!t.parser.tokenizer.inForeignNode && _8.includes(e.tagName) || t.parser.tokenizer.state === Gt.PLAINTEXT)
    return;
  Zi(t, Ub(e));
  const n = {
    type: Ze.END_TAG,
    tagName: e.tagName,
    tagID: Ki(e.tagName),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: io(e)
  };
  t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  n.tagName === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === Gt.RCDATA || // `<iframe>`, `<noembed>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === Gt.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === Gt.SCRIPT_DATA) && (t.parser.tokenizer.state = Gt.DATA);
}
function gD(e) {
  const t = e.type === "root" ? e.children[0] : e;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName === "html"));
}
function io(e) {
  const t = si(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = Ub(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function bD(e) {
  return "children" in e ? Ja({ ...e, children: [] }) : Ja(e);
}
function Xb(e) {
  return function(t, n) {
    return (
      /** @type {Root} */
      Gb(t, { ...e, file: n })
    );
  };
}
const AD = /[ \t\n\f\r]/g;
function ED(e) {
  return typeof e == "object" ? e.type === "text" ? Rm(e.value) : !1 : Rm(e);
}
function Rm(e) {
  return e.replace(AD, "") === "";
}
var Qf = { exports: {} }, Nm = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, vD = /\n/g, TD = /^\s*/, yD = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, _D = /^:\s*/, CD = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, SD = /^[;\s]*/, xD = /^\s+|\s+$/g, OD = `
`, km = "/", Lm = "*", Da = "", wD = "comment", ID = "declaration", RD = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  t = t || {};
  var n = 1, r = 1;
  function a(g) {
    var b = g.match(vD);
    b && (n += b.length);
    var v = g.lastIndexOf(OD);
    r = ~v ? g.length - v : r + g.length;
  }
  function i() {
    var g = { line: n, column: r };
    return function(b) {
      return b.position = new s(g), V(), b;
    };
  }
  function s(g) {
    this.start = g, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function o(g) {
    var b = new Error(
      t.source + ":" + n + ":" + r + ": " + g
    );
    if (b.reason = g, b.filename = t.source, b.line = n, b.column = r, b.source = e, !t.silent)
      throw b;
  }
  function u(g) {
    var b = g.exec(e);
    if (b) {
      var v = b[0];
      return a(v), e = e.slice(v.length), b;
    }
  }
  function V() {
    u(TD);
  }
  function c(g) {
    var b;
    for (g = g || []; b = f(); )
      b !== !1 && g.push(b);
    return g;
  }
  function f() {
    var g = i();
    if (!(km != e.charAt(0) || Lm != e.charAt(1))) {
      for (var b = 2; Da != e.charAt(b) && (Lm != e.charAt(b) || km != e.charAt(b + 1)); )
        ++b;
      if (b += 2, Da === e.charAt(b - 1))
        return o("End of comment missing");
      var v = e.slice(2, b - 2);
      return r += 2, a(v), e = e.slice(b), r += 2, g({
        type: wD,
        comment: v
      });
    }
  }
  function p() {
    var g = i(), b = u(yD);
    if (b) {
      if (f(), !u(_D))
        return o("property missing ':'");
      var v = u(CD), x = g({
        type: ID,
        property: Pm(b[0].replace(Nm, Da)),
        value: v ? Pm(v[0].replace(Nm, Da)) : Da
      });
      return u(SD), x;
    }
  }
  function h() {
    var g = [];
    c(g);
    for (var b; b = p(); )
      b !== !1 && (g.push(b), c(g));
    return g;
  }
  return V(), h();
};
function Pm(e) {
  return e ? e.replace(xD, Da) : Da;
}
var ND = RD;
function Kb(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  for (var r, a = ND(e), i = typeof t == "function", s, o, u = 0, V = a.length; u < V; u++)
    r = a[u], s = r.property, o = r.value, i ? t(s, o, r) : o && (n || (n = {}), n[s] = o);
  return n;
}
Qf.exports = Kb;
Qf.exports.default = Kb;
var kD = Qf.exports;
const LD = /* @__PURE__ */ pn(kD), PD = DD("start");
function DD(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function Ss(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Dm(e.position) : "start" in e || "end" in e ? Dm(e) : "line" in e || "column" in e ? Fc(e) : "";
}
function Fc(e) {
  return Mm(e && e.line) + ":" + Mm(e && e.column);
}
function Dm(e) {
  return Fc(e && e.start) + "-" + Fc(e && e.end);
}
function Mm(e) {
  return e && typeof e == "number" ? e : 1;
}
class wn extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let a = "", i = {}, s = !1;
    if (n && ("line" in n && "column" in n ? i = { place: n } : "start" in n && "end" in n ? i = { place: n } : "type" in n ? i = {
      ancestors: [n],
      place: n.position
    } : i = { ...n }), typeof t == "string" ? a = t : !i.cause && t && (s = !0, a = t.message, i.cause = t), !i.ruleId && !i.source && typeof r == "string") {
      const u = r.indexOf(":");
      u === -1 ? i.ruleId = r : (i.source = r.slice(0, u), i.ruleId = r.slice(u + 1));
    }
    if (!i.place && i.ancestors && i.ancestors) {
      const u = i.ancestors[i.ancestors.length - 1];
      u && (i.place = u.position);
    }
    const o = i.place && "start" in i.place ? i.place.start : i.place;
    this.ancestors = i.ancestors || void 0, this.cause = i.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file, this.message = a, this.line = o ? o.line : void 0, this.name = Ss(i.place) || "1:1", this.place = i.place || void 0, this.reason = this.message, this.ruleId = i.ruleId || void 0, this.source = i.source || void 0, this.stack = s && i.cause && typeof i.cause.stack == "string" ? i.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
wn.prototype.file = "";
wn.prototype.name = "";
wn.prototype.reason = "";
wn.prototype.message = "";
wn.prototype.stack = "";
wn.prototype.column = void 0;
wn.prototype.line = void 0;
wn.prototype.ancestors = void 0;
wn.prototype.cause = void 0;
wn.prototype.fatal = void 0;
wn.prototype.place = void 0;
wn.prototype.ruleId = void 0;
wn.prototype.source = void 0;
const Jf = {}.hasOwnProperty, MD = /* @__PURE__ */ new Map(), FD = /[A-Z]/g, BD = /-([a-z])/g, $D = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), UD = /* @__PURE__ */ new Set(["td", "th"]);
function HD(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = zD(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = jD(n, t.jsx, t.jsxs);
  }
  const a = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? ai : ro,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, i = Zb(a, e, void 0);
  return i && typeof i != "string" ? i : a.create(
    e,
    a.Fragment,
    { children: i || void 0 },
    void 0
  );
}
function Zb(e, t, n) {
  if (t.type === "element" || t.type === "root") {
    const r = e.schema;
    let a = r;
    t.type === "element" && t.tagName.toLowerCase() === "svg" && r.space === "html" && (a = ai, e.schema = a), e.ancestors.push(t);
    let i = GD(e, t);
    const s = YD(e, e.ancestors);
    let o = e.Fragment;
    if (e.ancestors.pop(), t.type === "element")
      if (i && $D.has(t.tagName) && (i = i.filter(function(u) {
        return typeof u == "string" ? !ED(u) : !0;
      })), Jf.call(e.components, t.tagName)) {
        const u = (
          /** @type {keyof JSX.IntrinsicElements} */
          t.tagName
        );
        o = e.components[u], typeof o != "string" && o !== e.Fragment && e.passNode && (s.node = t);
      } else
        o = t.tagName;
    if (i.length > 0) {
      const u = i.length > 1 ? i : i[0];
      u && (s.children = u);
    }
    return e.schema = r, e.create(t, o, s, n);
  }
  if (t.type === "text")
    return t.value;
}
function jD(e, t, n) {
  return r;
  function r(a, i, s, o) {
    const V = Array.isArray(s.children) ? n : t;
    return o ? V(i, s, o) : V(i, s);
  }
}
function zD(e, t) {
  return n;
  function n(r, a, i, s) {
    const o = Array.isArray(i.children), u = PD(r);
    return t(
      a,
      i,
      s,
      o,
      {
        columnNumber: u ? u.column - 1 : void 0,
        fileName: e,
        lineNumber: u ? u.line : void 0
      },
      void 0
    );
  }
}
function GD(e, t) {
  const n = [];
  let r = -1;
  const a = e.passKeys ? /* @__PURE__ */ new Map() : MD;
  for (; ++r < t.children.length; ) {
    const i = t.children[r];
    let s;
    if (e.passKeys && i.type === "element") {
      const u = a.get(i.tagName) || 0;
      s = i.tagName + "-" + u, a.set(i.tagName, u + 1);
    }
    const o = Zb(e, i, s);
    o !== void 0 && n.push(o);
  }
  return n;
}
function YD(e, t) {
  const n = t[t.length - 1], r = {};
  let a;
  if ("properties" in n && n.properties) {
    let i;
    for (a in n.properties)
      if (a !== "children" && Jf.call(n.properties, a)) {
        const s = WD(
          e,
          t,
          a,
          n.properties[a]
        );
        if (s) {
          const [o, u] = s;
          e.tableCellAlignToStyle && o === "align" && typeof u == "string" && UD.has(n.tagName) ? i = u : r[o] = u;
        }
      }
    if (i) {
      const s = (
        /** @type {Style} */
        r.style || (r.style = {})
      );
      s[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = i;
    }
  }
  return r;
}
function WD(e, t, n, r) {
  const a = Du(e.schema, n);
  if (!(r == null || typeof r == "number" && Number.isNaN(r))) {
    if (Array.isArray(r) && (r = a.commaSeparated ? nb(r) : rb(r)), a.property === "style") {
      let i = typeof r == "object" ? r : qD(e, t, String(r));
      return e.stylePropertyNameCase === "css" && (i = XD(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && a.space ? J5[a.property] || a.property : a.attribute,
      r
    ];
  }
}
function qD(e, t, n) {
  const r = {};
  try {
    LD(n, a);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const s = (
        /** @type {Error} */
        i
      ), o = new wn("Cannot parse `style` attribute", {
        ancestors: t,
        cause: s,
        source: "hast-util-to-jsx-runtime",
        ruleId: "style"
      });
      throw o.file = e.filePath || void 0, o.url = "https://github.com/syntax-tree/hast-util-to-jsx-runtime#cannot-parse-style-attribute", o;
    }
  }
  return r;
  function a(i, s) {
    let o = i;
    o.slice(0, 2) !== "--" && (o.slice(0, 4) === "-ms-" && (o = "ms-" + o.slice(4)), o = o.replace(BD, ZD)), r[o] = s;
  }
}
function XD(e) {
  const t = {};
  let n;
  for (n in e)
    Jf.call(e, n) && (t[KD(n)] = e[n]);
  return t;
}
function KD(e) {
  let t = e.replace(FD, QD);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function ZD(e, t) {
  return t.toUpperCase();
}
function QD(e) {
  return "-" + e.toLowerCase();
}
const MV = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, JD = ya(new RegExp("\\p{P}", "u")), xn = ya(/[A-Za-z]/), hn = ya(/[\dA-Za-z]/), eM = ya(/[#-'*+\--9=?A-Z^-~]/);
function fu(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const Bc = ya(/\d/), tM = ya(/[\dA-Fa-f]/), Qb = ya(/[!-/:-@[-`{-~]/);
function Ne(e) {
  return e !== null && e < -2;
}
function yt(e) {
  return e !== null && (e < 0 || e === 32);
}
function et(e) {
  return e === -2 || e === -1 || e === 32;
}
function zu(e) {
  return Qb(e) || JD(e);
}
const ei = ya(/\s/);
function ya(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
const nM = { '"': "quot", "&": "amp", "<": "lt", ">": "gt" };
function rM(e) {
  return e.replace(/["&<>]/g, t);
  function t(n) {
    return "&" + nM[n] + ";";
  }
}
function aM(e, t) {
  const n = rM(oi(e || ""));
  if (!t)
    return n;
  const r = n.indexOf(":"), a = n.indexOf("?"), i = n.indexOf("#"), s = n.indexOf("/");
  return (
    // If there is no protocol, its relative.
    r < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    s > -1 && r > s || a > -1 && r > a || i > -1 && r > i || // It is a protocol, it should be allowed.
    t.test(n.slice(0, r)) ? n : ""
  );
}
function oi(e) {
  const t = [];
  let n = -1, r = 0, a = 0;
  for (; ++n < e.length; ) {
    const i = e.charCodeAt(n);
    let s = "";
    if (i === 37 && hn(e.charCodeAt(n + 1)) && hn(e.charCodeAt(n + 2)))
      a = 2;
    else if (i < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (s = String.fromCharCode(i));
    else if (i > 55295 && i < 57344) {
      const o = e.charCodeAt(n + 1);
      i < 56320 && o > 56319 && o < 57344 ? (s = String.fromCharCode(i, o), a = 1) : s = "";
    } else
      s = String.fromCharCode(i);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + a + 1, s = ""), a && (n += a, a = 0);
  }
  return t.join("") + e.slice(r);
}
const iM = {};
function sM(e, t) {
  const n = t || iM, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, a = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return Jb(e, r, a);
}
function Jb(e, t, n) {
  if (oM(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Fm(e.children, t, n);
  }
  return Array.isArray(e) ? Fm(e, t, n) : "";
}
function Fm(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; )
    r[a] = Jb(e[a], t, n);
  return r.join("");
}
function oM(e) {
  return !!(e && typeof e == "object");
}
const Bm = document.createElement("i");
function ed(e) {
  const t = "&" + e + ";";
  Bm.innerHTML = t;
  const n = Bm.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function zn(e, t, n, r) {
  const a = e.length;
  let i = 0, s;
  if (t < 0 ? t = -t > a ? 0 : a + t : t = t > a ? a : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); i < r.length; )
      s = r.slice(i, i + 1e4), s.unshift(t, 0), e.splice(...s), i += 1e4, t += 1e4;
}
function Jn(e, t) {
  return e.length > 0 ? (zn(e, e.length, 0, t), e) : t;
}
const $m = {}.hasOwnProperty;
function eA(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    uM(t, e[n]);
  return t;
}
function uM(e, t) {
  let n;
  for (n in t) {
    const a = ($m.call(e, n) ? e[n] : void 0) || (e[n] = {}), i = t[n];
    let s;
    if (i)
      for (s in i) {
        $m.call(a, s) || (a[s] = []);
        const o = i[s];
        VM(
          // @ts-expect-error Looks like a list.
          a[s],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function VM(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  zn(e, 0, 0, r);
}
function tA(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Er(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
function ut(e, t, n, r) {
  const a = r ? r - 1 : Number.POSITIVE_INFINITY;
  let i = 0;
  return s;
  function s(u) {
    return et(u) ? (e.enter(n), o(u)) : t(u);
  }
  function o(u) {
    return et(u) && i++ < a ? (e.consume(u), o) : (e.exit(n), t(u));
  }
}
const lM = {
  tokenize: cM
};
function cM(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    a
  );
  let n;
  return t;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), ut(e, t, "linePrefix");
  }
  function a(o) {
    return e.enter("paragraph"), i(o);
  }
  function i(o) {
    const u = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = u), n = u, s(o);
  }
  function s(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return Ne(o) ? (e.consume(o), e.exit("chunkText"), i) : (e.consume(o), s);
  }
}
const fM = {
  tokenize: dM
}, Um = {
  tokenize: hM
};
function dM(e) {
  const t = this, n = [];
  let r = 0, a, i, s;
  return o;
  function o(S) {
    if (r < n.length) {
      const $ = n[r];
      return t.containerState = $[1], e.attempt(
        $[0].continuation,
        u,
        V
      )(S);
    }
    return V(S);
  }
  function u(S) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, a && E();
      const $ = t.events.length;
      let U = $, y;
      for (; U--; )
        if (t.events[U][0] === "exit" && t.events[U][1].type === "chunkFlow") {
          y = t.events[U][1].end;
          break;
        }
      x(r);
      let j = $;
      for (; j < t.events.length; )
        t.events[j][1].end = Object.assign({}, y), j++;
      return zn(
        t.events,
        U + 1,
        0,
        t.events.slice($)
      ), t.events.length = j, V(S);
    }
    return o(S);
  }
  function V(S) {
    if (r === n.length) {
      if (!a)
        return p(S);
      if (a.currentConstruct && a.currentConstruct.concrete)
        return g(S);
      t.interrupt = !!(a.currentConstruct && !a._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      Um,
      c,
      f
    )(S);
  }
  function c(S) {
    return a && E(), x(r), p(S);
  }
  function f(S) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, g(S);
  }
  function p(S) {
    return t.containerState = {}, e.attempt(
      Um,
      h,
      g
    )(S);
  }
  function h(S) {
    return r++, n.push([t.currentConstruct, t.containerState]), p(S);
  }
  function g(S) {
    if (S === null) {
      a && E(), x(0), e.consume(S);
      return;
    }
    return a = a || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: i,
      _tokenizer: a
    }), b(S);
  }
  function b(S) {
    if (S === null) {
      v(e.exit("chunkFlow"), !0), x(0), e.consume(S);
      return;
    }
    return Ne(S) ? (e.consume(S), v(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, o) : (e.consume(S), b);
  }
  function v(S, $) {
    const U = t.sliceStream(S);
    if ($ && U.push(null), S.previous = i, i && (i.next = S), i = S, a.defineSkip(S.start), a.write(U), t.parser.lazy[S.start.line]) {
      let y = a.events.length;
      for (; y--; )
        if (
          // The token starts before the line ending
          a.events[y][1].start.offset < s && // and either is not ended yet
          (!a.events[y][1].end || // or ends after it.
          a.events[y][1].end.offset > s)
        )
          return;
      const j = t.events.length;
      let q = j, Q, I;
      for (; q--; )
        if (t.events[q][0] === "exit" && t.events[q][1].type === "chunkFlow") {
          if (Q) {
            I = t.events[q][1].end;
            break;
          }
          Q = !0;
        }
      for (x(r), y = j; y < t.events.length; )
        t.events[y][1].end = Object.assign({}, I), y++;
      zn(
        t.events,
        q + 1,
        0,
        t.events.slice(j)
      ), t.events.length = y;
    }
  }
  function x(S) {
    let $ = n.length;
    for (; $-- > S; ) {
      const U = n[$];
      t.containerState = U[1], U[0].exit.call(t, e);
    }
    n.length = S;
  }
  function E() {
    a.write([null]), i = void 0, a = void 0, t.containerState._closeFlow = void 0;
  }
}
function hM(e, t, n) {
  return ut(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function du(e) {
  if (e === null || yt(e) || ei(e))
    return 1;
  if (zu(e))
    return 2;
}
function Gu(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; ) {
    const i = e[a].resolveAll;
    i && !r.includes(i) && (t = i(t, n), r.push(i));
  }
  return t;
}
const $c = {
  name: "attention",
  tokenize: pM,
  resolveAll: mM
};
function mM(e, t) {
  let n = -1, r, a, i, s, o, u, V, c;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          u = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, e[r][1].end), p = Object.assign({}, e[n][1].start);
          Hm(f, -u), Hm(p, u), s = {
            type: u > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, e[r][1].end)
          }, o = {
            type: u > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: p
          }, i = {
            type: u > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, a = {
            type: u > 1 ? "strong" : "emphasis",
            start: Object.assign({}, s.start),
            end: Object.assign({}, o.end)
          }, e[r][1].end = Object.assign({}, s.start), e[n][1].start = Object.assign({}, o.end), V = [], e[r][1].end.offset - e[r][1].start.offset && (V = Jn(V, [
            ["enter", e[r][1], t],
            ["exit", e[r][1], t]
          ])), V = Jn(V, [
            ["enter", a, t],
            ["enter", s, t],
            ["exit", s, t],
            ["enter", i, t]
          ]), V = Jn(
            V,
            Gu(
              t.parser.constructs.insideSpan.null,
              e.slice(r + 1, n),
              t
            )
          ), V = Jn(V, [
            ["exit", i, t],
            ["enter", o, t],
            ["exit", o, t],
            ["exit", a, t]
          ]), e[n][1].end.offset - e[n][1].start.offset ? (c = 2, V = Jn(V, [
            ["enter", e[n][1], t],
            ["exit", e[n][1], t]
          ])) : c = 0, zn(e, r - 1, n - r + 3, V), n = r + V.length - c - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function pM(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, a = du(r);
  let i;
  return s;
  function s(u) {
    return i = u, e.enter("attentionSequence"), o(u);
  }
  function o(u) {
    if (u === i)
      return e.consume(u), o;
    const V = e.exit("attentionSequence"), c = du(u), f = !c || c === 2 && a || n.includes(u), p = !a || a === 2 && c || n.includes(r);
    return V._open = !!(i === 42 ? f : f && (a || !p)), V._close = !!(i === 42 ? p : p && (c || !f)), t(u);
  }
}
function Hm(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const gM = {
  name: "autolink",
  tokenize: bM
};
function bM(e, t, n) {
  let r = 0;
  return a;
  function a(h) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), i;
  }
  function i(h) {
    return xn(h) ? (e.consume(h), s) : V(h);
  }
  function s(h) {
    return h === 43 || h === 45 || h === 46 || hn(h) ? (r = 1, o(h)) : V(h);
  }
  function o(h) {
    return h === 58 ? (e.consume(h), r = 0, u) : (h === 43 || h === 45 || h === 46 || hn(h)) && r++ < 32 ? (e.consume(h), o) : (r = 0, V(h));
  }
  function u(h) {
    return h === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : h === null || h === 32 || h === 60 || fu(h) ? n(h) : (e.consume(h), u);
  }
  function V(h) {
    return h === 64 ? (e.consume(h), c) : eM(h) ? (e.consume(h), V) : n(h);
  }
  function c(h) {
    return hn(h) ? f(h) : n(h);
  }
  function f(h) {
    return h === 46 ? (e.consume(h), r = 0, c) : h === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : p(h);
  }
  function p(h) {
    if ((h === 45 || hn(h)) && r++ < 63) {
      const g = h === 45 ? p : f;
      return e.consume(h), g;
    }
    return n(h);
  }
}
const so = {
  tokenize: AM,
  partial: !0
};
function AM(e, t, n) {
  return r;
  function r(i) {
    return et(i) ? ut(e, a, "linePrefix")(i) : a(i);
  }
  function a(i) {
    return i === null || Ne(i) ? t(i) : n(i);
  }
}
const nA = {
  name: "blockQuote",
  tokenize: EM,
  continuation: {
    tokenize: vM
  },
  exit: TM
};
function EM(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    if (s === 62) {
      const o = r.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), i;
    }
    return n(s);
  }
  function i(s) {
    return et(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function vM(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return et(s) ? ut(
      e,
      i,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(s) : i(s);
  }
  function i(s) {
    return e.attempt(nA, t, n)(s);
  }
}
function TM(e) {
  e.exit("blockQuote");
}
const rA = {
  name: "characterEscape",
  tokenize: yM
};
function yM(e, t, n) {
  return r;
  function r(i) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(i), e.exit("escapeMarker"), a;
  }
  function a(i) {
    return Qb(i) ? (e.enter("characterEscapeValue"), e.consume(i), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(i);
  }
}
const aA = {
  name: "characterReference",
  tokenize: _M
};
function _M(e, t, n) {
  const r = this;
  let a = 0, i, s;
  return o;
  function o(f) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), u;
  }
  function u(f) {
    return f === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(f), e.exit("characterReferenceMarkerNumeric"), V) : (e.enter("characterReferenceValue"), i = 31, s = hn, c(f));
  }
  function V(f) {
    return f === 88 || f === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(f), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), i = 6, s = tM, c) : (e.enter("characterReferenceValue"), i = 7, s = Bc, c(f));
  }
  function c(f) {
    if (f === 59 && a) {
      const p = e.exit("characterReferenceValue");
      return s === hn && !ed(r.sliceSerialize(p)) ? n(f) : (e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(f) && a++ < i ? (e.consume(f), c) : n(f);
  }
}
const jm = {
  tokenize: SM,
  partial: !0
}, zm = {
  name: "codeFenced",
  tokenize: CM,
  concrete: !0
};
function CM(e, t, n) {
  const r = this, a = {
    tokenize: U,
    partial: !0
  };
  let i = 0, s = 0, o;
  return u;
  function u(y) {
    return V(y);
  }
  function V(y) {
    const j = r.events[r.events.length - 1];
    return i = j && j[1].type === "linePrefix" ? j[2].sliceSerialize(j[1], !0).length : 0, o = y, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), c(y);
  }
  function c(y) {
    return y === o ? (s++, e.consume(y), c) : s < 3 ? n(y) : (e.exit("codeFencedFenceSequence"), et(y) ? ut(e, f, "whitespace")(y) : f(y));
  }
  function f(y) {
    return y === null || Ne(y) ? (e.exit("codeFencedFence"), r.interrupt ? t(y) : e.check(jm, b, $)(y)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), p(y));
  }
  function p(y) {
    return y === null || Ne(y) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), f(y)) : et(y) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), ut(e, h, "whitespace")(y)) : y === 96 && y === o ? n(y) : (e.consume(y), p);
  }
  function h(y) {
    return y === null || Ne(y) ? f(y) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), g(y));
  }
  function g(y) {
    return y === null || Ne(y) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), f(y)) : y === 96 && y === o ? n(y) : (e.consume(y), g);
  }
  function b(y) {
    return e.attempt(a, $, v)(y);
  }
  function v(y) {
    return e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), x;
  }
  function x(y) {
    return i > 0 && et(y) ? ut(
      e,
      E,
      "linePrefix",
      i + 1
    )(y) : E(y);
  }
  function E(y) {
    return y === null || Ne(y) ? e.check(jm, b, $)(y) : (e.enter("codeFlowValue"), S(y));
  }
  function S(y) {
    return y === null || Ne(y) ? (e.exit("codeFlowValue"), E(y)) : (e.consume(y), S);
  }
  function $(y) {
    return e.exit("codeFenced"), t(y);
  }
  function U(y, j, q) {
    let Q = 0;
    return I;
    function I(N) {
      return y.enter("lineEnding"), y.consume(N), y.exit("lineEnding"), ie;
    }
    function ie(N) {
      return y.enter("codeFencedFence"), et(N) ? ut(
        y,
        z,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(N) : z(N);
    }
    function z(N) {
      return N === o ? (y.enter("codeFencedFenceSequence"), H(N)) : q(N);
    }
    function H(N) {
      return N === o ? (Q++, y.consume(N), H) : Q >= s ? (y.exit("codeFencedFenceSequence"), et(N) ? ut(y, P, "whitespace")(N) : P(N)) : q(N);
    }
    function P(N) {
      return N === null || Ne(N) ? (y.exit("codeFencedFence"), j(N)) : q(N);
    }
  }
}
function SM(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i);
  }
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const FV = {
  name: "codeIndented",
  tokenize: OM
}, xM = {
  tokenize: wM,
  partial: !0
};
function OM(e, t, n) {
  const r = this;
  return a;
  function a(V) {
    return e.enter("codeIndented"), ut(e, i, "linePrefix", 5)(V);
  }
  function i(V) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? s(V) : n(V);
  }
  function s(V) {
    return V === null ? u(V) : Ne(V) ? e.attempt(xM, s, u)(V) : (e.enter("codeFlowValue"), o(V));
  }
  function o(V) {
    return V === null || Ne(V) ? (e.exit("codeFlowValue"), s(V)) : (e.consume(V), o);
  }
  function u(V) {
    return e.exit("codeIndented"), t(V);
  }
}
function wM(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : Ne(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a) : ut(e, i, "linePrefix", 5)(s);
  }
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(s) : Ne(s) ? a(s) : n(s);
  }
}
const IM = {
  name: "codeText",
  tokenize: kM,
  resolve: RM,
  previous: NM
};
function RM(e) {
  let t = e.length - 4, n = 3, r, a;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    a === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (a = r) : (r === t || e[r][1].type === "lineEnding") && (e[a][1].type = "codeTextData", r !== a + 2 && (e[a][1].end = e[r - 1][1].end, e.splice(a + 2, r - a - 2), t -= r - a - 2, r = a + 2), a = void 0);
  return e;
}
function NM(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function kM(e, t, n) {
  let r = 0, a, i;
  return s;
  function s(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(f);
  }
  function o(f) {
    return f === 96 ? (e.consume(f), r++, o) : (e.exit("codeTextSequence"), u(f));
  }
  function u(f) {
    return f === null ? n(f) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), u) : f === 96 ? (i = e.enter("codeTextSequence"), a = 0, c(f)) : Ne(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), u) : (e.enter("codeTextData"), V(f));
  }
  function V(f) {
    return f === null || f === 32 || f === 96 || Ne(f) ? (e.exit("codeTextData"), u(f)) : (e.consume(f), V);
  }
  function c(f) {
    return f === 96 ? (e.consume(f), a++, c) : a === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(f)) : (i.type = "codeTextData", V(f));
  }
}
function iA(e) {
  const t = {};
  let n = -1, r, a, i, s, o, u, V;
  for (; ++n < e.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = e[n], n && r[1].type === "chunkFlow" && e[n - 1][1].type === "listItemPrefix" && (u = r[1]._tokenizer.events, i = 0, i < u.length && u[i][1].type === "lineEndingBlank" && (i += 2), i < u.length && u[i][1].type === "content"))
      for (; ++i < u.length && u[i][1].type !== "content"; )
        u[i][1].type === "chunkText" && (u[i][1]._isInFirstContentOfListItem = !0, i++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, LM(e, n)), n = t[n], V = !0);
    else if (r[1]._container) {
      for (i = n, a = void 0; i-- && (s = e[i], s[1].type === "lineEnding" || s[1].type === "lineEndingBlank"); )
        s[0] === "enter" && (a && (e[a][1].type = "lineEndingBlank"), s[1].type = "lineEnding", a = i);
      a && (r[1].end = Object.assign({}, e[a][1].start), o = e.slice(a, n), o.unshift(r), zn(e, a, n - a + 1, o));
    }
  }
  return !V;
}
function LM(e, t) {
  const n = e[t][1], r = e[t][2];
  let a = t - 1;
  const i = [], s = n._tokenizer || r.parser[n.contentType](n.start), o = s.events, u = [], V = {};
  let c, f, p = -1, h = n, g = 0, b = 0;
  const v = [b];
  for (; h; ) {
    for (; e[++a][1] !== h; )
      ;
    i.push(a), h._tokenizer || (c = r.sliceStream(h), h.next || c.push(null), f && s.defineSkip(h.start), h._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(c), h._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), f = h, h = h.next;
  }
  for (h = n; ++p < o.length; )
    // Find a void token that includes a break.
    o[p][0] === "exit" && o[p - 1][0] === "enter" && o[p][1].type === o[p - 1][1].type && o[p][1].start.line !== o[p][1].end.line && (b = p + 1, v.push(b), h._tokenizer = void 0, h.previous = void 0, h = h.next);
  for (s.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : v.pop(), p = v.length; p--; ) {
    const x = o.slice(v[p], v[p + 1]), E = i.pop();
    u.unshift([E, E + x.length - 1]), zn(e, E, 2, x);
  }
  for (p = -1; ++p < u.length; )
    V[g + u[p][0]] = g + u[p][1], g += u[p][1] - u[p][0] - 1;
  return V;
}
const PM = {
  tokenize: FM,
  resolve: MM
}, DM = {
  tokenize: BM,
  partial: !0
};
function MM(e) {
  return iA(e), e;
}
function FM(e, t) {
  let n;
  return r;
  function r(o) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), a(o);
  }
  function a(o) {
    return o === null ? i(o) : Ne(o) ? e.check(
      DM,
      s,
      i
    )(o) : (e.consume(o), a);
  }
  function i(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function s(o) {
    return e.consume(o), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, a;
  }
}
function BM(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), ut(e, i, "linePrefix");
  }
  function i(s) {
    if (s === null || Ne(s))
      return n(s);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function sA(e, t, n, r, a, i, s, o, u) {
  const V = u || Number.POSITIVE_INFINITY;
  let c = 0;
  return f;
  function f(x) {
    return x === 60 ? (e.enter(r), e.enter(a), e.enter(i), e.consume(x), e.exit(i), p) : x === null || x === 32 || x === 41 || fu(x) ? n(x) : (e.enter(r), e.enter(s), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), b(x));
  }
  function p(x) {
    return x === 62 ? (e.enter(i), e.consume(x), e.exit(i), e.exit(a), e.exit(r), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), h(x));
  }
  function h(x) {
    return x === 62 ? (e.exit("chunkString"), e.exit(o), p(x)) : x === null || x === 60 || Ne(x) ? n(x) : (e.consume(x), x === 92 ? g : h);
  }
  function g(x) {
    return x === 60 || x === 62 || x === 92 ? (e.consume(x), h) : h(x);
  }
  function b(x) {
    return !c && (x === null || x === 41 || yt(x)) ? (e.exit("chunkString"), e.exit(o), e.exit(s), e.exit(r), t(x)) : c < V && x === 40 ? (e.consume(x), c++, b) : x === 41 ? (e.consume(x), c--, b) : x === null || x === 32 || x === 40 || fu(x) ? n(x) : (e.consume(x), x === 92 ? v : b);
  }
  function v(x) {
    return x === 40 || x === 41 || x === 92 ? (e.consume(x), b) : b(x);
  }
}
function oA(e, t, n, r, a, i) {
  const s = this;
  let o = 0, u;
  return V;
  function V(h) {
    return e.enter(r), e.enter(a), e.consume(h), e.exit(a), e.enter(i), c;
  }
  function c(h) {
    return o > 999 || h === null || h === 91 || h === 93 && !u || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    h === 94 && !o && "_hiddenFootnoteSupport" in s.parser.constructs ? n(h) : h === 93 ? (e.exit(i), e.enter(a), e.consume(h), e.exit(a), e.exit(r), t) : Ne(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c) : (e.enter("chunkString", {
      contentType: "string"
    }), f(h));
  }
  function f(h) {
    return h === null || h === 91 || h === 93 || Ne(h) || o++ > 999 ? (e.exit("chunkString"), c(h)) : (e.consume(h), u || (u = !et(h)), h === 92 ? p : f);
  }
  function p(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), o++, f) : f(h);
  }
}
function uA(e, t, n, r, a, i) {
  let s;
  return o;
  function o(p) {
    return p === 34 || p === 39 || p === 40 ? (e.enter(r), e.enter(a), e.consume(p), e.exit(a), s = p === 40 ? 41 : p, u) : n(p);
  }
  function u(p) {
    return p === s ? (e.enter(a), e.consume(p), e.exit(a), e.exit(r), t) : (e.enter(i), V(p));
  }
  function V(p) {
    return p === s ? (e.exit(i), u(s)) : p === null ? n(p) : Ne(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), ut(e, V, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), c(p));
  }
  function c(p) {
    return p === s || p === null || Ne(p) ? (e.exit("chunkString"), V(p)) : (e.consume(p), p === 92 ? f : c);
  }
  function f(p) {
    return p === s || p === 92 ? (e.consume(p), c) : c(p);
  }
}
function xs(e, t) {
  let n;
  return r;
  function r(a) {
    return Ne(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), n = !0, r) : et(a) ? ut(
      e,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(a) : t(a);
  }
}
const $M = {
  name: "definition",
  tokenize: HM
}, UM = {
  tokenize: jM,
  partial: !0
};
function HM(e, t, n) {
  const r = this;
  let a;
  return i;
  function i(h) {
    return e.enter("definition"), s(h);
  }
  function s(h) {
    return oA.call(
      r,
      e,
      o,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(h);
  }
  function o(h) {
    return a = Er(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), u) : n(h);
  }
  function u(h) {
    return yt(h) ? xs(e, V)(h) : V(h);
  }
  function V(h) {
    return sA(
      e,
      c,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(h);
  }
  function c(h) {
    return e.attempt(UM, f, f)(h);
  }
  function f(h) {
    return et(h) ? ut(e, p, "whitespace")(h) : p(h);
  }
  function p(h) {
    return h === null || Ne(h) ? (e.exit("definition"), r.parser.defined.push(a), t(h)) : n(h);
  }
}
function jM(e, t, n) {
  return r;
  function r(o) {
    return yt(o) ? xs(e, a)(o) : n(o);
  }
  function a(o) {
    return uA(
      e,
      i,
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o);
  }
  function i(o) {
    return et(o) ? ut(e, s, "whitespace")(o) : s(o);
  }
  function s(o) {
    return o === null || Ne(o) ? t(o) : n(o);
  }
}
const zM = {
  name: "hardBreakEscape",
  tokenize: GM
};
function GM(e, t, n) {
  return r;
  function r(i) {
    return e.enter("hardBreakEscape"), e.consume(i), a;
  }
  function a(i) {
    return Ne(i) ? (e.exit("hardBreakEscape"), t(i)) : n(i);
  }
}
const YM = {
  name: "headingAtx",
  tokenize: qM,
  resolve: WM
};
function WM(e, t) {
  let n = e.length - 2, r = 3, a, i;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (a = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, i = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, zn(e, r, n - r + 1, [
    ["enter", a, t],
    ["enter", i, t],
    ["exit", i, t],
    ["exit", a, t]
  ])), e;
}
function qM(e, t, n) {
  let r = 0;
  return a;
  function a(c) {
    return e.enter("atxHeading"), i(c);
  }
  function i(c) {
    return e.enter("atxHeadingSequence"), s(c);
  }
  function s(c) {
    return c === 35 && r++ < 6 ? (e.consume(c), s) : c === null || yt(c) ? (e.exit("atxHeadingSequence"), o(c)) : n(c);
  }
  function o(c) {
    return c === 35 ? (e.enter("atxHeadingSequence"), u(c)) : c === null || Ne(c) ? (e.exit("atxHeading"), t(c)) : et(c) ? ut(e, o, "whitespace")(c) : (e.enter("atxHeadingText"), V(c));
  }
  function u(c) {
    return c === 35 ? (e.consume(c), u) : (e.exit("atxHeadingSequence"), o(c));
  }
  function V(c) {
    return c === null || c === 35 || yt(c) ? (e.exit("atxHeadingText"), o(c)) : (e.consume(c), V);
  }
}
const XM = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Gm = ["pre", "script", "style", "textarea"], KM = {
  name: "htmlFlow",
  tokenize: e9,
  resolveTo: JM,
  concrete: !0
}, ZM = {
  tokenize: n9,
  partial: !0
}, QM = {
  tokenize: t9,
  partial: !0
};
function JM(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function e9(e, t, n) {
  const r = this;
  let a, i, s, o, u;
  return V;
  function V(w) {
    return c(w);
  }
  function c(w) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(w), f;
  }
  function f(w) {
    return w === 33 ? (e.consume(w), p) : w === 47 ? (e.consume(w), i = !0, b) : w === 63 ? (e.consume(w), a = 3, r.interrupt ? t : C) : xn(w) ? (e.consume(w), s = String.fromCharCode(w), v) : n(w);
  }
  function p(w) {
    return w === 45 ? (e.consume(w), a = 2, h) : w === 91 ? (e.consume(w), a = 5, o = 0, g) : xn(w) ? (e.consume(w), a = 4, r.interrupt ? t : C) : n(w);
  }
  function h(w) {
    return w === 45 ? (e.consume(w), r.interrupt ? t : C) : n(w);
  }
  function g(w) {
    const De = "CDATA[";
    return w === De.charCodeAt(o++) ? (e.consume(w), o === De.length ? r.interrupt ? t : z : g) : n(w);
  }
  function b(w) {
    return xn(w) ? (e.consume(w), s = String.fromCharCode(w), v) : n(w);
  }
  function v(w) {
    if (w === null || w === 47 || w === 62 || yt(w)) {
      const De = w === 47, $e = s.toLowerCase();
      return !De && !i && Gm.includes($e) ? (a = 1, r.interrupt ? t(w) : z(w)) : XM.includes(s.toLowerCase()) ? (a = 6, De ? (e.consume(w), x) : r.interrupt ? t(w) : z(w)) : (a = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(w) : i ? E(w) : S(w));
    }
    return w === 45 || hn(w) ? (e.consume(w), s += String.fromCharCode(w), v) : n(w);
  }
  function x(w) {
    return w === 62 ? (e.consume(w), r.interrupt ? t : z) : n(w);
  }
  function E(w) {
    return et(w) ? (e.consume(w), E) : I(w);
  }
  function S(w) {
    return w === 47 ? (e.consume(w), I) : w === 58 || w === 95 || xn(w) ? (e.consume(w), $) : et(w) ? (e.consume(w), S) : I(w);
  }
  function $(w) {
    return w === 45 || w === 46 || w === 58 || w === 95 || hn(w) ? (e.consume(w), $) : U(w);
  }
  function U(w) {
    return w === 61 ? (e.consume(w), y) : et(w) ? (e.consume(w), U) : S(w);
  }
  function y(w) {
    return w === null || w === 60 || w === 61 || w === 62 || w === 96 ? n(w) : w === 34 || w === 39 ? (e.consume(w), u = w, j) : et(w) ? (e.consume(w), y) : q(w);
  }
  function j(w) {
    return w === u ? (e.consume(w), u = null, Q) : w === null || Ne(w) ? n(w) : (e.consume(w), j);
  }
  function q(w) {
    return w === null || w === 34 || w === 39 || w === 47 || w === 60 || w === 61 || w === 62 || w === 96 || yt(w) ? U(w) : (e.consume(w), q);
  }
  function Q(w) {
    return w === 47 || w === 62 || et(w) ? S(w) : n(w);
  }
  function I(w) {
    return w === 62 ? (e.consume(w), ie) : n(w);
  }
  function ie(w) {
    return w === null || Ne(w) ? z(w) : et(w) ? (e.consume(w), ie) : n(w);
  }
  function z(w) {
    return w === 45 && a === 2 ? (e.consume(w), K) : w === 60 && a === 1 ? (e.consume(w), D) : w === 62 && a === 4 ? (e.consume(w), ge) : w === 63 && a === 3 ? (e.consume(w), C) : w === 93 && a === 5 ? (e.consume(w), ee) : Ne(w) && (a === 6 || a === 7) ? (e.exit("htmlFlowData"), e.check(
      ZM,
      pe,
      H
    )(w)) : w === null || Ne(w) ? (e.exit("htmlFlowData"), H(w)) : (e.consume(w), z);
  }
  function H(w) {
    return e.check(
      QM,
      P,
      pe
    )(w);
  }
  function P(w) {
    return e.enter("lineEnding"), e.consume(w), e.exit("lineEnding"), N;
  }
  function N(w) {
    return w === null || Ne(w) ? H(w) : (e.enter("htmlFlowData"), z(w));
  }
  function K(w) {
    return w === 45 ? (e.consume(w), C) : z(w);
  }
  function D(w) {
    return w === 47 ? (e.consume(w), s = "", J) : z(w);
  }
  function J(w) {
    if (w === 62) {
      const De = s.toLowerCase();
      return Gm.includes(De) ? (e.consume(w), ge) : z(w);
    }
    return xn(w) && s.length < 8 ? (e.consume(w), s += String.fromCharCode(w), J) : z(w);
  }
  function ee(w) {
    return w === 93 ? (e.consume(w), C) : z(w);
  }
  function C(w) {
    return w === 62 ? (e.consume(w), ge) : w === 45 && a === 2 ? (e.consume(w), C) : z(w);
  }
  function ge(w) {
    return w === null || Ne(w) ? (e.exit("htmlFlowData"), pe(w)) : (e.consume(w), ge);
  }
  function pe(w) {
    return e.exit("htmlFlow"), t(w);
  }
}
function t9(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return Ne(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : n(s);
  }
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function n9(e, t, n) {
  return r;
  function r(a) {
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), e.attempt(so, t, n);
  }
}
const r9 = {
  name: "htmlText",
  tokenize: a9
};
function a9(e, t, n) {
  const r = this;
  let a, i, s;
  return o;
  function o(C) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(C), u;
  }
  function u(C) {
    return C === 33 ? (e.consume(C), V) : C === 47 ? (e.consume(C), U) : C === 63 ? (e.consume(C), S) : xn(C) ? (e.consume(C), q) : n(C);
  }
  function V(C) {
    return C === 45 ? (e.consume(C), c) : C === 91 ? (e.consume(C), i = 0, g) : xn(C) ? (e.consume(C), E) : n(C);
  }
  function c(C) {
    return C === 45 ? (e.consume(C), h) : n(C);
  }
  function f(C) {
    return C === null ? n(C) : C === 45 ? (e.consume(C), p) : Ne(C) ? (s = f, D(C)) : (e.consume(C), f);
  }
  function p(C) {
    return C === 45 ? (e.consume(C), h) : f(C);
  }
  function h(C) {
    return C === 62 ? K(C) : C === 45 ? p(C) : f(C);
  }
  function g(C) {
    const ge = "CDATA[";
    return C === ge.charCodeAt(i++) ? (e.consume(C), i === ge.length ? b : g) : n(C);
  }
  function b(C) {
    return C === null ? n(C) : C === 93 ? (e.consume(C), v) : Ne(C) ? (s = b, D(C)) : (e.consume(C), b);
  }
  function v(C) {
    return C === 93 ? (e.consume(C), x) : b(C);
  }
  function x(C) {
    return C === 62 ? K(C) : C === 93 ? (e.consume(C), x) : b(C);
  }
  function E(C) {
    return C === null || C === 62 ? K(C) : Ne(C) ? (s = E, D(C)) : (e.consume(C), E);
  }
  function S(C) {
    return C === null ? n(C) : C === 63 ? (e.consume(C), $) : Ne(C) ? (s = S, D(C)) : (e.consume(C), S);
  }
  function $(C) {
    return C === 62 ? K(C) : S(C);
  }
  function U(C) {
    return xn(C) ? (e.consume(C), y) : n(C);
  }
  function y(C) {
    return C === 45 || hn(C) ? (e.consume(C), y) : j(C);
  }
  function j(C) {
    return Ne(C) ? (s = j, D(C)) : et(C) ? (e.consume(C), j) : K(C);
  }
  function q(C) {
    return C === 45 || hn(C) ? (e.consume(C), q) : C === 47 || C === 62 || yt(C) ? Q(C) : n(C);
  }
  function Q(C) {
    return C === 47 ? (e.consume(C), K) : C === 58 || C === 95 || xn(C) ? (e.consume(C), I) : Ne(C) ? (s = Q, D(C)) : et(C) ? (e.consume(C), Q) : K(C);
  }
  function I(C) {
    return C === 45 || C === 46 || C === 58 || C === 95 || hn(C) ? (e.consume(C), I) : ie(C);
  }
  function ie(C) {
    return C === 61 ? (e.consume(C), z) : Ne(C) ? (s = ie, D(C)) : et(C) ? (e.consume(C), ie) : Q(C);
  }
  function z(C) {
    return C === null || C === 60 || C === 61 || C === 62 || C === 96 ? n(C) : C === 34 || C === 39 ? (e.consume(C), a = C, H) : Ne(C) ? (s = z, D(C)) : et(C) ? (e.consume(C), z) : (e.consume(C), P);
  }
  function H(C) {
    return C === a ? (e.consume(C), a = void 0, N) : C === null ? n(C) : Ne(C) ? (s = H, D(C)) : (e.consume(C), H);
  }
  function P(C) {
    return C === null || C === 34 || C === 39 || C === 60 || C === 61 || C === 96 ? n(C) : C === 47 || C === 62 || yt(C) ? Q(C) : (e.consume(C), P);
  }
  function N(C) {
    return C === 47 || C === 62 || yt(C) ? Q(C) : n(C);
  }
  function K(C) {
    return C === 62 ? (e.consume(C), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(C);
  }
  function D(C) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(C), e.exit("lineEnding"), J;
  }
  function J(C) {
    return et(C) ? ut(
      e,
      ee,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(C) : ee(C);
  }
  function ee(C) {
    return e.enter("htmlTextData"), s(C);
  }
}
const td = {
  name: "labelEnd",
  tokenize: l9,
  resolveTo: V9,
  resolveAll: u9
}, i9 = {
  tokenize: c9
}, s9 = {
  tokenize: f9
}, o9 = {
  tokenize: d9
};
function u9(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function V9(e, t) {
  let n = e.length, r = 0, a, i, s, o;
  for (; n--; )
    if (a = e[n][1], i) {
      if (a.type === "link" || a.type === "labelLink" && a._inactive)
        break;
      e[n][0] === "enter" && a.type === "labelLink" && (a._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (a.type === "labelImage" || a.type === "labelLink") && !a._balanced && (i = n, a.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else
      a.type === "labelEnd" && (s = n);
  const u = {
    type: e[i][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, V = {
    type: "label",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[s][1].end)
  }, c = {
    type: "labelText",
    start: Object.assign({}, e[i + r + 2][1].end),
    end: Object.assign({}, e[s - 2][1].start)
  };
  return o = [
    ["enter", u, t],
    ["enter", V, t]
  ], o = Jn(o, e.slice(i + 1, i + r + 3)), o = Jn(o, [["enter", c, t]]), o = Jn(
    o,
    Gu(
      t.parser.constructs.insideSpan.null,
      e.slice(i + r + 4, s - 3),
      t
    )
  ), o = Jn(o, [
    ["exit", c, t],
    e[s - 2],
    e[s - 1],
    ["exit", V, t]
  ]), o = Jn(o, e.slice(s + 1)), o = Jn(o, [["exit", u, t]]), zn(e, i, e.length, o), e;
}
function l9(e, t, n) {
  const r = this;
  let a = r.events.length, i, s;
  for (; a--; )
    if ((r.events[a][1].type === "labelImage" || r.events[a][1].type === "labelLink") && !r.events[a][1]._balanced) {
      i = r.events[a][1];
      break;
    }
  return o;
  function o(p) {
    return i ? i._inactive ? f(p) : (s = r.parser.defined.includes(
      Er(
        r.sliceSerialize({
          start: i.end,
          end: r.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(p), e.exit("labelMarker"), e.exit("labelEnd"), u) : n(p);
  }
  function u(p) {
    return p === 40 ? e.attempt(
      i9,
      c,
      s ? c : f
    )(p) : p === 91 ? e.attempt(
      s9,
      c,
      s ? V : f
    )(p) : s ? c(p) : f(p);
  }
  function V(p) {
    return e.attempt(
      o9,
      c,
      f
    )(p);
  }
  function c(p) {
    return t(p);
  }
  function f(p) {
    return i._balanced = !0, n(p);
  }
}
function c9(e, t, n) {
  return r;
  function r(f) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), a;
  }
  function a(f) {
    return yt(f) ? xs(e, i)(f) : i(f);
  }
  function i(f) {
    return f === 41 ? c(f) : sA(
      e,
      s,
      o,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(f);
  }
  function s(f) {
    return yt(f) ? xs(e, u)(f) : c(f);
  }
  function o(f) {
    return n(f);
  }
  function u(f) {
    return f === 34 || f === 39 || f === 40 ? uA(
      e,
      V,
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(f) : c(f);
  }
  function V(f) {
    return yt(f) ? xs(e, c)(f) : c(f);
  }
  function c(f) {
    return f === 41 ? (e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), e.exit("resource"), t) : n(f);
  }
}
function f9(e, t, n) {
  const r = this;
  return a;
  function a(o) {
    return oA.call(
      r,
      e,
      i,
      s,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o);
  }
  function i(o) {
    return r.parser.defined.includes(
      Er(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(o) : n(o);
  }
  function s(o) {
    return n(o);
  }
}
function d9(e, t, n) {
  return r;
  function r(i) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), a;
  }
  function a(i) {
    return i === 93 ? (e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), e.exit("reference"), t) : n(i);
  }
}
const h9 = {
  name: "labelStartImage",
  tokenize: m9,
  resolveAll: td.resolveAll
};
function m9(e, t, n) {
  const r = this;
  return a;
  function a(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), i;
  }
  function i(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), s) : n(o);
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const p9 = {
  name: "labelStartLink",
  tokenize: g9,
  resolveAll: td.resolveAll
};
function g9(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), i;
  }
  function i(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const BV = {
  name: "lineEnding",
  tokenize: b9
};
function b9(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), ut(e, t, "linePrefix");
  }
}
const Lo = {
  name: "thematicBreak",
  tokenize: A9
};
function A9(e, t, n) {
  let r = 0, a;
  return i;
  function i(V) {
    return e.enter("thematicBreak"), s(V);
  }
  function s(V) {
    return a = V, o(V);
  }
  function o(V) {
    return V === a ? (e.enter("thematicBreakSequence"), u(V)) : r >= 3 && (V === null || Ne(V)) ? (e.exit("thematicBreak"), t(V)) : n(V);
  }
  function u(V) {
    return V === a ? (e.consume(V), r++, u) : (e.exit("thematicBreakSequence"), et(V) ? ut(e, o, "whitespace")(V) : o(V));
  }
}
const Ln = {
  name: "list",
  tokenize: T9,
  continuation: {
    tokenize: y9
  },
  exit: C9
}, E9 = {
  tokenize: S9,
  partial: !0
}, v9 = {
  tokenize: _9,
  partial: !0
};
function T9(e, t, n) {
  const r = this, a = r.events[r.events.length - 1];
  let i = a && a[1].type === "linePrefix" ? a[2].sliceSerialize(a[1], !0).length : 0, s = 0;
  return o;
  function o(h) {
    const g = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (g === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : Bc(h)) {
      if (r.containerState.type || (r.containerState.type = g, e.enter(g, {
        _container: !0
      })), g === "listUnordered")
        return e.enter("listItemPrefix"), h === 42 || h === 45 ? e.check(Lo, n, V)(h) : V(h);
      if (!r.interrupt || h === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), u(h);
    }
    return n(h);
  }
  function u(h) {
    return Bc(h) && ++s < 10 ? (e.consume(h), u) : (!r.interrupt || s < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (e.exit("listItemValue"), V(h)) : n(h);
  }
  function V(h) {
    return e.enter("listItemMarker"), e.consume(h), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, e.check(
      so,
      // Cant be empty when interrupting.
      r.interrupt ? n : c,
      e.attempt(
        E9,
        p,
        f
      )
    );
  }
  function c(h) {
    return r.containerState.initialBlankLine = !0, i++, p(h);
  }
  function f(h) {
    return et(h) ? (e.enter("listItemPrefixWhitespace"), e.consume(h), e.exit("listItemPrefixWhitespace"), p) : n(h);
  }
  function p(h) {
    return r.containerState.size = i + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(h);
  }
}
function y9(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(so, a, i);
  function a(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, ut(
      e,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(o);
  }
  function i(o) {
    return r.containerState.furtherBlankLines || !et(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(v9, t, s)(o));
  }
  function s(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, ut(
      e,
      e.attempt(Ln, t, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o);
  }
}
function _9(e, t, n) {
  const r = this;
  return ut(
    e,
    a,
    "listItemIndent",
    r.containerState.size + 1
  );
  function a(i) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(i) : n(i);
  }
}
function C9(e) {
  e.exit(this.containerState.type);
}
function S9(e, t, n) {
  const r = this;
  return ut(
    e,
    a,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function a(i) {
    const s = r.events[r.events.length - 1];
    return !et(i) && s && s[1].type === "listItemPrefixWhitespace" ? t(i) : n(i);
  }
}
const Ym = {
  name: "setextUnderline",
  tokenize: O9,
  resolveTo: x9
};
function x9(e, t) {
  let n = e.length, r, a, i;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (a = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !i && e[n][1].type === "definition" && (i = n);
  const s = {
    type: "setextHeading",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[a][1].type = "setextHeadingText", i ? (e.splice(a, 0, ["enter", s, t]), e.splice(i + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[i][1].end)) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function O9(e, t, n) {
  const r = this;
  let a;
  return i;
  function i(V) {
    let c = r.events.length, f;
    for (; c--; )
      if (r.events[c][1].type !== "lineEnding" && r.events[c][1].type !== "linePrefix" && r.events[c][1].type !== "content") {
        f = r.events[c][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || f) ? (e.enter("setextHeadingLine"), a = V, s(V)) : n(V);
  }
  function s(V) {
    return e.enter("setextHeadingLineSequence"), o(V);
  }
  function o(V) {
    return V === a ? (e.consume(V), o) : (e.exit("setextHeadingLineSequence"), et(V) ? ut(e, u, "lineSuffix")(V) : u(V));
  }
  function u(V) {
    return V === null || Ne(V) ? (e.exit("setextHeadingLine"), t(V)) : n(V);
  }
}
const w9 = {
  tokenize: I9
};
function I9(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    so,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      a,
      ut(
        e,
        e.attempt(
          this.parser.constructs.flow,
          a,
          e.attempt(PM, a)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(i) {
    if (i === null) {
      e.consume(i);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(i), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function a(i) {
    if (i === null) {
      e.consume(i);
      return;
    }
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const R9 = {
  resolveAll: lA()
}, N9 = VA("string"), k9 = VA("text");
function VA(e) {
  return {
    tokenize: t,
    resolveAll: lA(
      e === "text" ? L9 : void 0
    )
  };
  function t(n) {
    const r = this, a = this.parser.constructs[e], i = n.attempt(a, s, o);
    return s;
    function s(c) {
      return V(c) ? i(c) : o(c);
    }
    function o(c) {
      if (c === null) {
        n.consume(c);
        return;
      }
      return n.enter("data"), n.consume(c), u;
    }
    function u(c) {
      return V(c) ? (n.exit("data"), i(c)) : (n.consume(c), u);
    }
    function V(c) {
      if (c === null)
        return !0;
      const f = a[c];
      let p = -1;
      if (f)
        for (; ++p < f.length; ) {
          const h = f[p];
          if (!h.previous || h.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function lA(e) {
  return t;
  function t(n, r) {
    let a = -1, i;
    for (; ++a <= n.length; )
      i === void 0 ? n[a] && n[a][1].type === "data" && (i = a, a++) : (!n[a] || n[a][1].type !== "data") && (a !== i + 2 && (n[i][1].end = n[a - 1][1].end, n.splice(i + 2, a - i - 2), a = i + 2), i = void 0);
    return e ? e(n, r) : n;
  }
}
function L9(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], a = t.sliceStream(r);
      let i = a.length, s = -1, o = 0, u;
      for (; i--; ) {
        const V = a[i];
        if (typeof V == "string") {
          for (s = V.length; V.charCodeAt(s - 1) === 32; )
            o++, s--;
          if (s)
            break;
          s = -1;
        } else if (V === -2)
          u = !0, o++;
        else if (V !== -1) {
          i++;
          break;
        }
      }
      if (o) {
        const V = {
          type: n === e.length || u || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o,
            _index: r.start._index + i,
            _bufferIndex: i ? s : r.start._bufferIndex + s
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, V.start), r.start.offset === r.end.offset ? Object.assign(r, V) : (e.splice(
          n,
          0,
          ["enter", V, t],
          ["exit", V, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function P9(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const a = {}, i = [];
  let s = [], o = [];
  const u = {
    consume: E,
    enter: S,
    exit: $,
    attempt: j(U),
    check: j(y),
    interrupt: j(y, {
      interrupt: !0
    })
  }, V = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: h,
    sliceSerialize: p,
    now: g,
    defineSkip: b,
    write: f
  };
  let c = t.tokenize.call(V, u);
  return t.resolveAll && i.push(t), V;
  function f(ie) {
    return s = Jn(s, ie), v(), s[s.length - 1] !== null ? [] : (q(t, 0), V.events = Gu(i, V.events, V), V.events);
  }
  function p(ie, z) {
    return M9(h(ie), z);
  }
  function h(ie) {
    return D9(s, ie);
  }
  function g() {
    const { line: ie, column: z, offset: H, _index: P, _bufferIndex: N } = r;
    return {
      line: ie,
      column: z,
      offset: H,
      _index: P,
      _bufferIndex: N
    };
  }
  function b(ie) {
    a[ie.line] = ie.column, I();
  }
  function v() {
    let ie;
    for (; r._index < s.length; ) {
      const z = s[r._index];
      if (typeof z == "string")
        for (ie = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === ie && r._bufferIndex < z.length; )
          x(z.charCodeAt(r._bufferIndex));
      else
        x(z);
    }
  }
  function x(ie) {
    c = c(ie);
  }
  function E(ie) {
    Ne(ie) ? (r.line++, r.column = 1, r.offset += ie === -3 ? 2 : 1, I()) : ie !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === s[r._index].length && (r._bufferIndex = -1, r._index++)), V.previous = ie;
  }
  function S(ie, z) {
    const H = z || {};
    return H.type = ie, H.start = g(), V.events.push(["enter", H, V]), o.push(H), H;
  }
  function $(ie) {
    const z = o.pop();
    return z.end = g(), V.events.push(["exit", z, V]), z;
  }
  function U(ie, z) {
    q(ie, z.from);
  }
  function y(ie, z) {
    z.restore();
  }
  function j(ie, z) {
    return H;
    function H(P, N, K) {
      let D, J, ee, C;
      return Array.isArray(P) ? pe(P) : "tokenize" in P ? (
        // @ts-expect-error Looks like a construct.
        pe([P])
      ) : ge(P);
      function ge(Me) {
        return ct;
        function ct(Ye) {
          const Oe = Ye !== null && Me[Ye], We = Ye !== null && Me.null, At = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Oe) ? Oe : Oe ? [Oe] : [],
            ...Array.isArray(We) ? We : We ? [We] : []
          ];
          return pe(At)(Ye);
        }
      }
      function pe(Me) {
        return D = Me, J = 0, Me.length === 0 ? K : w(Me[J]);
      }
      function w(Me) {
        return ct;
        function ct(Ye) {
          return C = Q(), ee = Me, Me.partial || (V.currentConstruct = Me), Me.name && V.parser.constructs.disable.null.includes(Me.name) ? $e() : Me.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            z ? Object.assign(Object.create(V), z) : V,
            u,
            De,
            $e
          )(Ye);
        }
      }
      function De(Me) {
        return ie(ee, C), N;
      }
      function $e(Me) {
        return C.restore(), ++J < D.length ? w(D[J]) : K;
      }
    }
  }
  function q(ie, z) {
    ie.resolveAll && !i.includes(ie) && i.push(ie), ie.resolve && zn(
      V.events,
      z,
      V.events.length - z,
      ie.resolve(V.events.slice(z), V)
    ), ie.resolveTo && (V.events = ie.resolveTo(V.events, V));
  }
  function Q() {
    const ie = g(), z = V.previous, H = V.currentConstruct, P = V.events.length, N = Array.from(o);
    return {
      restore: K,
      from: P
    };
    function K() {
      r = ie, V.previous = z, V.currentConstruct = H, V.events.length = P, o = N, I();
    }
  }
  function I() {
    r.line in a && r.column < 2 && (r.column = a[r.line], r.offset += a[r.line] - 1);
  }
}
function D9(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, a = t.end._index, i = t.end._bufferIndex;
  let s;
  if (n === a)
    s = [e[n].slice(r, i)];
  else {
    if (s = e.slice(n, a), r > -1) {
      const o = s[0];
      typeof o == "string" ? s[0] = o.slice(r) : s.shift();
    }
    i > 0 && s.push(e[a].slice(0, i));
  }
  return s;
}
function M9(e, t) {
  let n = -1;
  const r = [];
  let a;
  for (; ++n < e.length; ) {
    const i = e[n];
    let s;
    if (typeof i == "string")
      s = i;
    else
      switch (i) {
        case -5: {
          s = "\r";
          break;
        }
        case -4: {
          s = `
`;
          break;
        }
        case -3: {
          s = `\r
`;
          break;
        }
        case -2: {
          s = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && a)
            continue;
          s = " ";
          break;
        }
        default:
          s = String.fromCharCode(i);
      }
    a = i === -2, r.push(s);
  }
  return r.join("");
}
const F9 = {
  42: Ln,
  43: Ln,
  45: Ln,
  48: Ln,
  49: Ln,
  50: Ln,
  51: Ln,
  52: Ln,
  53: Ln,
  54: Ln,
  55: Ln,
  56: Ln,
  57: Ln,
  62: nA
}, B9 = {
  91: $M
}, $9 = {
  [-2]: FV,
  [-1]: FV,
  32: FV
}, U9 = {
  35: YM,
  42: Lo,
  45: [Ym, Lo],
  60: KM,
  61: Ym,
  95: Lo,
  96: zm,
  126: zm
}, H9 = {
  38: aA,
  92: rA
}, j9 = {
  [-5]: BV,
  [-4]: BV,
  [-3]: BV,
  33: h9,
  38: aA,
  42: $c,
  60: [gM, r9],
  91: p9,
  92: [zM, rA],
  93: td,
  95: $c,
  96: IM
}, z9 = {
  null: [$c, R9]
}, G9 = {
  null: [42, 95]
}, Y9 = {
  null: []
}, W9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: G9,
  contentInitial: B9,
  disable: Y9,
  document: F9,
  flow: U9,
  flowInitial: $9,
  insideSpan: z9,
  string: H9,
  text: j9
}, Symbol.toStringTag, { value: "Module" }));
function q9(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    eA([W9, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: a(lM),
    document: a(fM),
    flow: a(w9),
    string: a(N9),
    text: a(k9)
  };
  return r;
  function a(i) {
    return s;
    function s(o) {
      return P9(r, i, o);
    }
  }
}
function X9(e) {
  for (; !iA(e); )
    ;
  return e;
}
const Wm = /[\0\t\n\r]/g;
function K9() {
  let e = 1, t = "", n = !0, r;
  return a;
  function a(i, s, o) {
    const u = [];
    let V, c, f, p, h;
    for (i = t + (typeof i == "string" ? i.toString() : new TextDecoder(s || void 0).decode(i)), f = 0, t = "", n && (i.charCodeAt(0) === 65279 && f++, n = void 0); f < i.length; ) {
      if (Wm.lastIndex = f, V = Wm.exec(i), p = V && V.index !== void 0 ? V.index : i.length, h = i.charCodeAt(p), !V) {
        t = i.slice(f);
        break;
      }
      if (h === 10 && f === p && r)
        u.push(-3), r = void 0;
      else
        switch (r && (u.push(-5), r = void 0), f < p && (u.push(i.slice(f, p)), e += p - f), h) {
          case 0: {
            u.push(65533), e++;
            break;
          }
          case 9: {
            for (c = Math.ceil(e / 4) * 4, u.push(-2); e++ < c; )
              u.push(-1);
            break;
          }
          case 10: {
            u.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      f = p + 1;
    }
    return o && (r && u.push(-5), t && u.push(t), u.push(null)), u;
  }
}
const Z9 = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Q9(e) {
  return e.replace(Z9, J9);
}
function J9(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const a = n.charCodeAt(1), i = a === 120 || a === 88;
    return tA(n.slice(i ? 2 : 1), i ? 16 : 10);
  }
  return ed(n) || e;
}
const cA = {}.hasOwnProperty;
function e7(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), t7(n)(
    X9(
      q9(n).document().write(K9()(e, t, !0))
    )
  );
}
function t7(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: i(vn),
      autolinkProtocol: Q,
      autolinkEmail: Q,
      atxHeading: i(tn),
      blockQuote: i(Oe),
      characterEscape: Q,
      characterReference: Q,
      codeFenced: i(We),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: i(We, s),
      codeText: i(At, s),
      codeTextData: Q,
      data: Q,
      codeFlowValue: Q,
      definition: i(xt),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: i(en),
      hardBreakEscape: i(An),
      hardBreakTrailing: i(An),
      htmlFlow: i(En, s),
      htmlFlowData: Q,
      htmlText: i(En, s),
      htmlTextData: Q,
      image: i(Xn),
      label: s,
      link: i(vn),
      listItem: i(Tn),
      listItemValue: p,
      listOrdered: i(rr, f),
      listUnordered: i(rr),
      paragraph: i(Kn),
      reference: w,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: i(tn),
      strong: i(ln),
      thematicBreak: i(ar)
    },
    exit: {
      atxHeading: u(),
      atxHeadingSequence: U,
      autolink: u(),
      autolinkEmail: Ye,
      autolinkProtocol: ct,
      blockQuote: u(),
      characterEscapeValue: I,
      characterReferenceMarkerHexadecimal: $e,
      characterReferenceMarkerNumeric: $e,
      characterReferenceValue: Me,
      codeFenced: u(v),
      codeFencedFence: b,
      codeFencedFenceInfo: h,
      codeFencedFenceMeta: g,
      codeFlowValue: I,
      codeIndented: u(x),
      codeText: u(N),
      codeTextData: I,
      data: I,
      definition: u(),
      definitionDestinationString: $,
      definitionLabelString: E,
      definitionTitleString: S,
      emphasis: u(),
      hardBreakEscape: u(z),
      hardBreakTrailing: u(z),
      htmlFlow: u(H),
      htmlFlowData: I,
      htmlText: u(P),
      htmlTextData: I,
      image: u(D),
      label: ee,
      labelText: J,
      lineEnding: ie,
      link: u(K),
      listItem: u(),
      listOrdered: u(),
      listUnordered: u(),
      paragraph: u(),
      referenceString: De,
      resourceDestinationString: C,
      resourceTitleString: ge,
      resource: pe,
      setextHeading: u(q),
      setextHeadingLineSequence: j,
      setextHeadingText: y,
      strong: u(),
      thematicBreak: u()
    }
  };
  fA(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(te) {
    let de = {
      type: "root",
      children: []
    };
    const xe = {
      stack: [de],
      tokenStack: [],
      config: t,
      enter: o,
      exit: V,
      buffer: s,
      resume: c,
      data: n
    }, Ie = [];
    let He = -1;
    for (; ++He < te.length; )
      if (te[He][1].type === "listOrdered" || te[He][1].type === "listUnordered")
        if (te[He][0] === "enter")
          Ie.push(He);
        else {
          const Dt = Ie.pop();
          He = a(te, Dt, He);
        }
    for (He = -1; ++He < te.length; ) {
      const Dt = t[te[He][0]];
      cA.call(Dt, te[He][1].type) && Dt[te[He][1].type].call(
        Object.assign(
          {
            sliceSerialize: te[He][2].sliceSerialize
          },
          xe
        ),
        te[He][1]
      );
    }
    if (xe.tokenStack.length > 0) {
      const Dt = xe.tokenStack[xe.tokenStack.length - 1];
      (Dt[1] || qm).call(xe, void 0, Dt[0]);
    }
    for (de.position = {
      start: Va(
        te.length > 0 ? te[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: Va(
        te.length > 0 ? te[te.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, He = -1; ++He < t.transforms.length; )
      de = t.transforms[He](de) || de;
    return de;
  }
  function a(te, de, xe) {
    let Ie = de - 1, He = -1, Dt = !1, Mt, Yt, In, Ot;
    for (; ++Ie <= xe; ) {
      const rt = te[Ie];
      switch (rt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          rt[0] === "enter" ? He++ : He--, Ot = void 0;
          break;
        }
        case "lineEndingBlank": {
          rt[0] === "enter" && (Mt && !Ot && !He && !In && (In = Ie), Ot = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Ot = void 0;
      }
      if (!He && rt[0] === "enter" && rt[1].type === "listItemPrefix" || He === -1 && rt[0] === "exit" && (rt[1].type === "listUnordered" || rt[1].type === "listOrdered")) {
        if (Mt) {
          let Ft = Ie;
          for (Yt = void 0; Ft--; ) {
            const Nt = te[Ft];
            if (Nt[1].type === "lineEnding" || Nt[1].type === "lineEndingBlank") {
              if (Nt[0] === "exit")
                continue;
              Yt && (te[Yt][1].type = "lineEndingBlank", Dt = !0), Nt[1].type = "lineEnding", Yt = Ft;
            } else if (!(Nt[1].type === "linePrefix" || Nt[1].type === "blockQuotePrefix" || Nt[1].type === "blockQuotePrefixWhitespace" || Nt[1].type === "blockQuoteMarker" || Nt[1].type === "listItemIndent"))
              break;
          }
          In && (!Yt || In < Yt) && (Mt._spread = !0), Mt.end = Object.assign(
            {},
            Yt ? te[Yt][1].start : rt[1].end
          ), te.splice(Yt || Ie, 0, ["exit", Mt, rt[2]]), Ie++, xe++;
        }
        if (rt[1].type === "listItemPrefix") {
          const Ft = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, rt[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          Mt = Ft, te.splice(Ie, 0, ["enter", Ft, rt[2]]), Ie++, xe++, In = void 0, Ot = !0;
        }
      }
    }
    return te[de][1]._spread = Dt, xe;
  }
  function i(te, de) {
    return xe;
    function xe(Ie) {
      o.call(this, te(Ie), Ie), de && de.call(this, Ie);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(te, de, xe) {
    this.stack[this.stack.length - 1].children.push(te), this.stack.push(te), this.tokenStack.push([de, xe]), te.position = {
      start: Va(de.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function u(te) {
    return de;
    function de(xe) {
      te && te.call(this, xe), V.call(this, xe);
    }
  }
  function V(te, de) {
    const xe = this.stack.pop(), Ie = this.tokenStack.pop();
    if (Ie)
      Ie[0].type !== te.type && (de ? de.call(this, te, Ie[0]) : (Ie[1] || qm).call(this, te, Ie[0]));
    else
      throw new Error(
        "Cannot close `" + te.type + "` (" + Ss({
          start: te.start,
          end: te.end
        }) + "): its not open"
      );
    xe.position.end = Va(te.end);
  }
  function c() {
    return sM(this.stack.pop());
  }
  function f() {
    this.data.expectingFirstListItemValue = !0;
  }
  function p(te) {
    if (this.data.expectingFirstListItemValue) {
      const de = this.stack[this.stack.length - 2];
      de.start = Number.parseInt(this.sliceSerialize(te), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function h() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.lang = te;
  }
  function g() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.meta = te;
  }
  function b() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function v() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.value = te.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function x() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.value = te.replace(/(\r?\n|\r)$/g, "");
  }
  function E(te) {
    const de = this.resume(), xe = this.stack[this.stack.length - 1];
    xe.label = de, xe.identifier = Er(
      this.sliceSerialize(te)
    ).toLowerCase();
  }
  function S() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.title = te;
  }
  function $() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.url = te;
  }
  function U(te) {
    const de = this.stack[this.stack.length - 1];
    if (!de.depth) {
      const xe = this.sliceSerialize(te).length;
      de.depth = xe;
    }
  }
  function y() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function j(te) {
    const de = this.stack[this.stack.length - 1];
    de.depth = this.sliceSerialize(te).codePointAt(0) === 61 ? 1 : 2;
  }
  function q() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function Q(te) {
    const xe = this.stack[this.stack.length - 1].children;
    let Ie = xe[xe.length - 1];
    (!Ie || Ie.type !== "text") && (Ie = Mn(), Ie.position = {
      start: Va(te.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, xe.push(Ie)), this.stack.push(Ie);
  }
  function I(te) {
    const de = this.stack.pop();
    de.value += this.sliceSerialize(te), de.position.end = Va(te.end);
  }
  function ie(te) {
    const de = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const xe = de.children[de.children.length - 1];
      xe.position.end = Va(te.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(de.type) && (Q.call(this, te), I.call(this, te));
  }
  function z() {
    this.data.atHardBreak = !0;
  }
  function H() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.value = te;
  }
  function P() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.value = te;
  }
  function N() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.value = te;
  }
  function K() {
    const te = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const de = this.data.referenceType || "shortcut";
      te.type += "Reference", te.referenceType = de, delete te.url, delete te.title;
    } else
      delete te.identifier, delete te.label;
    this.data.referenceType = void 0;
  }
  function D() {
    const te = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const de = this.data.referenceType || "shortcut";
      te.type += "Reference", te.referenceType = de, delete te.url, delete te.title;
    } else
      delete te.identifier, delete te.label;
    this.data.referenceType = void 0;
  }
  function J(te) {
    const de = this.sliceSerialize(te), xe = this.stack[this.stack.length - 2];
    xe.label = Q9(de), xe.identifier = Er(de).toLowerCase();
  }
  function ee() {
    const te = this.stack[this.stack.length - 1], de = this.resume(), xe = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, xe.type === "link") {
      const Ie = te.children;
      xe.children = Ie;
    } else
      xe.alt = de;
  }
  function C() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.url = te;
  }
  function ge() {
    const te = this.resume(), de = this.stack[this.stack.length - 1];
    de.title = te;
  }
  function pe() {
    this.data.inReference = void 0;
  }
  function w() {
    this.data.referenceType = "collapsed";
  }
  function De(te) {
    const de = this.resume(), xe = this.stack[this.stack.length - 1];
    xe.label = de, xe.identifier = Er(
      this.sliceSerialize(te)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function $e(te) {
    this.data.characterReferenceType = te.type;
  }
  function Me(te) {
    const de = this.sliceSerialize(te), xe = this.data.characterReferenceType;
    let Ie;
    xe ? (Ie = tA(
      de,
      xe === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : Ie = ed(de);
    const He = this.stack.pop();
    He.value += Ie, He.position.end = Va(te.end);
  }
  function ct(te) {
    I.call(this, te);
    const de = this.stack[this.stack.length - 1];
    de.url = this.sliceSerialize(te);
  }
  function Ye(te) {
    I.call(this, te);
    const de = this.stack[this.stack.length - 1];
    de.url = "mailto:" + this.sliceSerialize(te);
  }
  function Oe() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function We() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function At() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function xt() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function en() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function tn() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function An() {
    return {
      type: "break"
    };
  }
  function En() {
    return {
      type: "html",
      value: ""
    };
  }
  function Xn() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function vn() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function rr(te) {
    return {
      type: "list",
      ordered: te.type === "listOrdered",
      start: null,
      spread: te._spread,
      children: []
    };
  }
  function Tn(te) {
    return {
      type: "listItem",
      spread: te._spread,
      checked: null,
      children: []
    };
  }
  function Kn() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ln() {
    return {
      type: "strong",
      children: []
    };
  }
  function Mn() {
    return {
      type: "text",
      value: ""
    };
  }
  function ar() {
    return {
      type: "thematicBreak"
    };
  }
}
function Va(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function fA(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? fA(e, r) : n7(e, r);
  }
}
function n7(e, t) {
  let n;
  for (n in t)
    if (cA.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function qm(e, t) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + Ss({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + Ss({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + Ss({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function r7(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return e7(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function a7(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function i7(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function s7(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let a = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (a.data = { meta: t.meta }), e.patch(t, a), a = e.applyData(t, a), a = { type: "element", tagName: "pre", properties: {}, children: [a] }, e.patch(t, a), a;
}
function o7(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function u7(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function V7(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), a = oi(r.toLowerCase()), i = e.footnoteOrder.indexOf(r);
  let s, o = e.footnoteCounts.get(r);
  o === void 0 ? (o = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = i + 1, o += 1, e.footnoteCounts.set(r, o);
  const u = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + a,
      id: n + "fnref-" + a + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, u);
  const V = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [u]
  };
  return e.patch(t, V), e.applyData(t, V);
}
function l7(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function c7(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function dA(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const a = e.all(t), i = a[0];
  i && i.type === "text" ? i.value = "[" + i.value : a.unshift({ type: "text", value: "[" });
  const s = a[a.length - 1];
  return s && s.type === "text" ? s.value += r : a.push({ type: "text", value: r }), a;
}
function f7(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return dA(e, t);
  const a = { src: oi(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (a.title = r.title);
  const i = { type: "element", tagName: "img", properties: a, children: [] };
  return e.patch(t, i), e.applyData(t, i);
}
function d7(e, t) {
  const n = { src: oi(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function h7(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function m7(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return dA(e, t);
  const a = { href: oi(r.url || "") };
  r.title !== null && r.title !== void 0 && (a.title = r.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: a,
    children: e.all(t)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function p7(e, t) {
  const n = { href: oi(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function g7(e, t, n) {
  const r = e.all(t), a = n ? b7(n) : hA(t), i = {}, s = [];
  if (typeof t.checked == "boolean") {
    const c = r[0];
    let f;
    c && c.type === "element" && c.tagName === "p" ? f = c : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), i.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const c = r[o];
    (a || o !== 0 || c.type !== "element" || c.tagName !== "p") && s.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !a ? s.push(...c.children) : s.push(c);
  }
  const u = r[r.length - 1];
  u && (a || u.type !== "element" || u.tagName !== "p") && s.push({ type: "text", value: `
` });
  const V = { type: "element", tagName: "li", properties: i, children: s };
  return e.patch(t, V), e.applyData(t, V);
}
function b7(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = hA(n[r]);
  }
  return t;
}
function hA(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function A7(e, t) {
  const n = {}, r = e.all(t);
  let a = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++a < r.length; ) {
    const s = r[a];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const i = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function E7(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function v7(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function T7(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const mA = gA("end"), pA = gA("start");
function gA(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function y7(e) {
  const t = pA(e), n = mA(e);
  if (t && n)
    return { start: t, end: n };
}
function _7(e, t) {
  const n = e.all(t), r = n.shift(), a = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), a.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, o = pA(t.children[1]), u = mA(t.children[t.children.length - 1]);
    o && u && (s.position = { start: o, end: u }), a.push(s);
  }
  const i = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(a, !0)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function C7(e, t, n) {
  const r = n ? n.children : void 0, i = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, o = s ? s.length : t.children.length;
  let u = -1;
  const V = [];
  for (; ++u < o; ) {
    const f = t.children[u], p = {}, h = s ? s[u] : void 0;
    h && (p.align = h);
    let g = { type: "element", tagName: i, properties: p, children: [] };
    f && (g.children = e.all(f), e.patch(f, g), g = e.applyData(f, g)), V.push(g);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(V, !0)
  };
  return e.patch(t, c), e.applyData(t, c);
}
function S7(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Xm = 9, Km = 32;
function x7(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), a = 0;
  const i = [];
  for (; r; )
    i.push(
      Zm(t.slice(a, r.index), a > 0, !0),
      r[0]
    ), a = r.index + r[0].length, r = n.exec(t);
  return i.push(Zm(t.slice(a), a > 0, !1)), i.join("");
}
function Zm(e, t, n) {
  let r = 0, a = e.length;
  if (t) {
    let i = e.codePointAt(r);
    for (; i === Xm || i === Km; )
      r++, i = e.codePointAt(r);
  }
  if (n) {
    let i = e.codePointAt(a - 1);
    for (; i === Xm || i === Km; )
      a--, i = e.codePointAt(a - 1);
  }
  return a > r ? e.slice(r, a) : "";
}
function O7(e, t) {
  const n = { type: "text", value: x7(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function w7(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const I7 = {
  blockquote: a7,
  break: i7,
  code: s7,
  delete: o7,
  emphasis: u7,
  footnoteReference: V7,
  heading: l7,
  html: c7,
  imageReference: f7,
  image: d7,
  inlineCode: h7,
  linkReference: m7,
  link: p7,
  listItem: g7,
  list: A7,
  paragraph: E7,
  // @ts-expect-error: root is different, but hard to type.
  root: v7,
  strong: T7,
  table: _7,
  tableCell: S7,
  tableRow: C7,
  text: O7,
  thematicBreak: w7,
  toml: _o,
  yaml: _o,
  definition: _o,
  footnoteDefinition: _o
};
function _o() {
}
function R7(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function N7(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function k7(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || R7, r = e.options.footnoteBackLabel || N7, a = e.options.footnoteLabel || "Footnotes", i = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let u = -1;
  for (; ++u < e.footnoteOrder.length; ) {
    const V = e.footnoteById.get(e.footnoteOrder[u]);
    if (!V)
      continue;
    const c = e.all(V), f = String(V.identifier).toUpperCase(), p = oi(f.toLowerCase());
    let h = 0;
    const g = [], b = e.footnoteCounts.get(f);
    for (; b !== void 0 && ++h <= b; ) {
      g.length > 0 && g.push({ type: "text", value: " " });
      let E = typeof n == "string" ? n : n(u, h);
      typeof E == "string" && (E = { type: "text", value: E }), g.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + p + (h > 1 ? "-" + h : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(u, h),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(E) ? E : [E]
      });
    }
    const v = c[c.length - 1];
    if (v && v.type === "element" && v.tagName === "p") {
      const E = v.children[v.children.length - 1];
      E && E.type === "text" ? E.value += " " : v.children.push({ type: "text", value: " " }), v.children.push(...g);
    } else
      c.push(...g);
    const x = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + p },
      children: e.wrap(c, !0)
    };
    e.patch(V, x), o.push(x);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: i,
          properties: {
            ...Ja(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: a }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Uc = {}.hasOwnProperty, L7 = {};
function P7(e, t) {
  const n = t || L7, r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = { ...I7, ...n.handlers }, o = {
    all: V,
    applyData: M7,
    definitionById: r,
    footnoteById: a,
    footnoteCounts: i,
    footnoteOrder: [],
    handlers: s,
    one: u,
    options: n,
    patch: D7,
    wrap: B7
  };
  return ju(e, function(c) {
    if (c.type === "definition" || c.type === "footnoteDefinition") {
      const f = c.type === "definition" ? r : a, p = String(c.identifier).toUpperCase();
      f.has(p) || f.set(p, c);
    }
  }), o;
  function u(c, f) {
    const p = c.type, h = o.handlers[p];
    if (Uc.call(o.handlers, p) && h)
      return h(o, c, f);
    if (o.options.passThrough && o.options.passThrough.includes(p)) {
      if ("children" in c) {
        const { children: b, ...v } = c, x = Ja(v);
        return x.children = o.all(c), x;
      }
      return Ja(c);
    }
    return (o.options.unknownHandler || F7)(o, c, f);
  }
  function V(c) {
    const f = [];
    if ("children" in c) {
      const p = c.children;
      let h = -1;
      for (; ++h < p.length; ) {
        const g = o.one(p[h], c);
        if (g) {
          if (h && p[h - 1].type === "break" && (!Array.isArray(g) && g.type === "text" && (g.value = Qm(g.value)), !Array.isArray(g) && g.type === "element")) {
            const b = g.children[0];
            b && b.type === "text" && (b.value = Qm(b.value));
          }
          Array.isArray(g) ? f.push(...g) : f.push(g);
        }
      }
    }
    return f;
  }
}
function D7(e, t) {
  e.position && (t.position = y7(e));
}
function M7(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, a = e.data.hChildren, i = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && i && Object.assign(n.properties, Ja(i)), "children" in n && n.children && a !== null && a !== void 0 && (n.children = a);
  }
  return n;
}
function F7(e, t) {
  const n = t.data || {}, r = "value" in t && !(Uc.call(n, "hProperties") || Uc.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function B7(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Qm(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function Jm(e, t) {
  const n = P7(e, t), r = n.one(e, void 0), a = k7(n), i = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return a && i.children.push({ type: "text", value: `
` }, a), i;
}
function $7(e, t) {
  return e && "run" in e ? async function(n, r) {
    const a = (
      /** @type {HastRoot} */
      Jm(n, t)
    );
    await e.run(a, r);
  } : function(n) {
    return (
      /** @type {HastRoot} */
      Jm(n, t || e)
    );
  };
}
function ep(e) {
  if (e)
    throw e;
}
var Po = Object.prototype.hasOwnProperty, bA = Object.prototype.toString, tp = Object.defineProperty, np = Object.getOwnPropertyDescriptor, rp = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : bA.call(t) === "[object Array]";
}, ap = function(t) {
  if (!t || bA.call(t) !== "[object Object]")
    return !1;
  var n = Po.call(t, "constructor"), r = t.constructor && t.constructor.prototype && Po.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var a;
  for (a in t)
    ;
  return typeof a > "u" || Po.call(t, a);
}, ip = function(t, n) {
  tp && n.name === "__proto__" ? tp(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, sp = function(t, n) {
  if (n === "__proto__")
    if (Po.call(t, n)) {
      if (np)
        return np(t, n).value;
    } else
      return;
  return t[n];
}, U7 = function e() {
  var t, n, r, a, i, s, o = arguments[0], u = 1, V = arguments.length, c = !1;
  for (typeof o == "boolean" && (c = o, o = arguments[1] || {}, u = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); u < V; ++u)
    if (t = arguments[u], t != null)
      for (n in t)
        r = sp(o, n), a = sp(t, n), o !== a && (c && a && (ap(a) || (i = rp(a))) ? (i ? (i = !1, s = r && rp(r) ? r : []) : s = r && ap(r) ? r : {}, ip(o, { name: n, newValue: e(c, s, a) })) : typeof a < "u" && ip(o, { name: n, newValue: a }));
  return o;
};
const $V = /* @__PURE__ */ pn(U7);
function Hc(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function H7() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...a) {
    let i = -1;
    const s = a.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    o(null, ...a);
    function o(u, ...V) {
      const c = e[++i];
      let f = -1;
      if (u) {
        s(u);
        return;
      }
      for (; ++f < a.length; )
        (V[f] === null || V[f] === void 0) && (V[f] = a[f]);
      a = V, c ? j7(c, o)(...V) : s(null, ...V);
    }
  }
  function r(a) {
    if (typeof a != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + a
      );
    return e.push(a), t;
  }
}
function j7(e, t) {
  let n;
  return r;
  function r(...s) {
    const o = e.length > s.length;
    let u;
    o && s.push(a);
    try {
      u = e.apply(this, s);
    } catch (V) {
      const c = (
        /** @type {Error} */
        V
      );
      if (o && n)
        throw c;
      return a(c);
    }
    o || (u instanceof Promise ? u.then(i, a) : u instanceof Error ? a(u) : i(u));
  }
  function a(s, ...o) {
    n || (n = !0, t(s, ...o));
  }
  function i(s) {
    a(null, s);
  }
}
const wr = { basename: z7, dirname: G7, extname: Y7, join: W7, sep: "/" };
function z7(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  oo(e);
  let n = 0, r = -1, a = e.length, i;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; a--; )
      if (e.codePointAt(a) === 47) {
        if (i) {
          n = a + 1;
          break;
        }
      } else
        r < 0 && (i = !0, r = a + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, o = t.length - 1;
  for (; a--; )
    if (e.codePointAt(a) === 47) {
      if (i) {
        n = a + 1;
        break;
      }
    } else
      s < 0 && (i = !0, s = a + 1), o > -1 && (e.codePointAt(a) === t.codePointAt(o--) ? o < 0 && (r = a) : (o = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function G7(e) {
  if (oo(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else
      r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function Y7(e) {
  oo(e);
  let t = e.length, n = -1, r = 0, a = -1, i = 0, s;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), o === 46 ? a < 0 ? a = t : i !== 1 && (i = 1) : a > -1 && (i = -1);
  }
  return a < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  i === 0 || // The (right-most) trimmed path component is exactly `..`.
  i === 1 && a === n - 1 && a === r + 1 ? "" : e.slice(a, n);
}
function W7(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    oo(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : q7(n);
}
function q7(e) {
  oo(e);
  const t = e.codePointAt(0) === 47;
  let n = X7(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function X7(e, t) {
  let n = "", r = 0, a = -1, i = 0, s = -1, o, u;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      o = e.codePointAt(s);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(a === s - 1 || i === 1))
        if (a !== s - 1 && i === 2) {
          if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              if (u = n.lastIndexOf("/"), u !== n.length - 1) {
                u < 0 ? (n = "", r = 0) : (n = n.slice(0, u), r = n.length - 1 - n.lastIndexOf("/")), a = s, i = 0;
                continue;
              }
            } else if (n.length > 0) {
              n = "", r = 0, a = s, i = 0;
              continue;
            }
          }
          t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
        } else
          n.length > 0 ? n += "/" + e.slice(a + 1, s) : n = e.slice(a + 1, s), r = s - a - 1;
      a = s, i = 0;
    } else
      o === 46 && i > -1 ? i++ : i = -1;
  }
  return n;
}
function oo(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const K7 = { cwd: Z7 };
function Z7() {
  return "/";
}
function jc(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function Q7(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!jc(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return J7(e);
}
function J7(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const a = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw a.code = "ERR_INVALID_FILE_URL_PATH", a;
      }
    }
  return decodeURIComponent(t);
}
const UV = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class AA {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? jc(t) ? n = { path: t } : typeof t == "string" || eF(t) ? n = { value: t } : n = t : n = {}, this.cwd = K7.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < UV.length; ) {
      const i = UV[r];
      i in n && n[i] !== void 0 && n[i] !== null && (this[i] = i === "history" ? [...n[i]] : n[i]);
    }
    let a;
    for (a in n)
      UV.includes(a) || (this[a] = n[a]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? wr.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    jV(t, "basename"), HV(t, "basename"), this.path = wr.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? wr.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    op(this.basename, "dirname"), this.path = wr.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? wr.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (HV(t, "extname"), op(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = wr.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    jc(t) && (t = Q7(t)), jV(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? wr.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    jV(t, "stem"), HV(t, "stem"), this.path = wr.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const a = this.message(t, n, r);
    throw a.fatal = !0, a;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const a = this.message(t, n, r);
    return a.fatal = void 0, a;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const a = new wn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (a.name = this.path + ":" + a.name, a.file = this.path), a.fatal = !1, this.messages.push(a), a;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function HV(e, t) {
  if (e && e.includes(wr.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + wr.sep + "`"
    );
}
function jV(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function op(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function eF(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const tF = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), a = r[e], i = function() {
      return a.apply(i, arguments);
    };
    Object.setPrototypeOf(i, r);
    const s = Object.getOwnPropertyNames(a);
    for (const o of s) {
      const u = Object.getOwnPropertyDescriptor(a, o);
      u && Object.defineProperty(i, o, u);
    }
    return i;
  }
), nF = {}.hasOwnProperty;
class nd extends tF {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = H7();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new nd()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data($V(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * >  **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * >  **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (YV("data", this.frozen), this.namespace[t] = n, this) : nF.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (YV("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const a = n.call(t, ...r);
      typeof a == "function" && this.transformers.use(a);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * >  **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Co(t), r = this.parser || this.Parser;
    return zV("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * >  **Note**: `process` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), zV("process", this.parser || this.Parser), GV("process", this.compiler || this.Compiler), n ? a(void 0, n) : new Promise(a);
    function a(i, s) {
      const o = Co(t), u = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(u, o, function(c, f, p) {
        if (c || !f || !p)
          return V(c);
        const h = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          f
        ), g = r.stringify(h, p);
        iF(g) ? p.value = g : p.result = g, V(
          c,
          /** @type {VFileWithOutput<CompileResult>} */
          p
        );
      });
      function V(c, f) {
        c || !f ? s(c) : i ? i(f) : n(void 0, f);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), zV("processSync", this.parser || this.Parser), GV("processSync", this.compiler || this.Compiler), this.process(t, a), Vp("processSync", "process", n), r;
    function a(i, s) {
      n = !0, ep(i), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * >  **Note**: `run` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    up(t), this.freeze();
    const a = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? i(void 0, r) : new Promise(i);
    function i(s, o) {
      const u = Co(n);
      a.run(t, u, V);
      function V(c, f, p) {
        const h = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          f || t
        );
        c ? o(c) : s ? s(h) : r(void 0, h, p);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, a;
    return this.run(t, n, i), Vp("runSync", "run", r), a;
    function i(s, o) {
      ep(s), a = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * >  **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Co(n), a = this.compiler || this.Compiler;
    return GV("stringify", a), up(t), a(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * >  **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, a = this.namespace;
    if (YV("use", this.frozen), t != null)
      if (typeof t == "function")
        u(t, n);
      else if (typeof t == "object")
        Array.isArray(t) ? o(t) : s(t);
      else
        throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function i(V) {
      if (typeof V == "function")
        u(V, []);
      else if (typeof V == "object")
        if (Array.isArray(V)) {
          const [c, ...f] = (
            /** @type {PluginTuple<Array<unknown>>} */
            V
          );
          u(c, f);
        } else
          s(V);
      else
        throw new TypeError("Expected usable value, not `" + V + "`");
    }
    function s(V) {
      if (!("plugins" in V) && !("settings" in V))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(V.plugins), V.settings && (a.settings = $V(!0, a.settings, V.settings));
    }
    function o(V) {
      let c = -1;
      if (V != null)
        if (Array.isArray(V))
          for (; ++c < V.length; ) {
            const f = V[c];
            i(f);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + V + "`");
    }
    function u(V, c) {
      let f = -1, p = -1;
      for (; ++f < r.length; )
        if (r[f][0] === V) {
          p = f;
          break;
        }
      if (p === -1)
        r.push([V, ...c]);
      else if (c.length > 0) {
        let [h, ...g] = c;
        const b = r[p][1];
        Hc(b) && Hc(h) && (h = $V(!0, b, h)), r[p] = [V, h, ...g];
      }
    }
  }
}
const rF = new nd().freeze();
function zV(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function GV(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function YV(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function up(e) {
  if (!Hc(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Vp(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Co(e) {
  return aF(e) ? e : new AA(e);
}
function aF(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function iF(e) {
  return typeof e == "string" || sF(e);
}
function sF(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const lp = {}.hasOwnProperty, oF = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", cp = [], fp = { allowDangerousHtml: !0 }, uF = /^(https?|ircs?|mailto|xmpp)$/i, VF = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function lF(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", a = e.className, i = e.components, s = e.disallowedElements, o = e.rehypePlugins || cp, u = e.remarkPlugins || cp, V = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...fp } : fp, c = e.skipHtml, f = e.unwrapDisallowed, p = e.urlTransform || cF, h = rF().use(r7).use(u).use($7, V).use(o), g = new AA();
  typeof r == "string" && (g.value = r);
  for (const E of VF)
    Object.hasOwn(e, E.from) && ("" + E.from + (E.to ? "use `" + E.to + "` instead" : "remove it") + oF + E.id, void 0);
  const b = h.parse(g);
  let v = h.runSync(b, g);
  return a && (v = {
    type: "element",
    tagName: "div",
    properties: { className: a },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      v.type === "root" ? v.children : [v]
    )
  }), ju(v, x), HD(v, {
    Fragment: X.Fragment,
    components: i,
    ignoreInvalidStyle: !0,
    jsx: X.jsx,
    jsxs: X.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function x(E, S, $) {
    if (E.type === "raw" && $ && typeof S == "number")
      return c ? $.children.splice(S, 1) : $.children[S] = { type: "text", value: E.value }, S;
    if (E.type === "element") {
      let U;
      for (U in MV)
        if (lp.call(MV, U) && lp.call(E.properties, U)) {
          const y = E.properties[U], j = MV[U];
          (j === null || j.includes(E.tagName)) && (E.properties[U] = p(String(y || ""), U, E));
        }
    }
    if (E.type === "element") {
      let U = t ? !t.includes(E.tagName) : s ? s.includes(E.tagName) : !1;
      if (!U && n && typeof S == "number" && (U = !n(E, S, $)), U && $ && typeof S == "number")
        return f && E.children ? $.children.splice(S, 1, ...E.children) : $.children.splice(S, 1), S;
    }
  }
}
function cF(e) {
  return aM(e, uF);
}
const fF = EA("end"), dF = EA("start");
function EA(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function hF(e) {
  const t = dF(e), n = fF(e);
  if (t && n)
    return { start: t, end: n };
}
const Na = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"], Ma = {
  ancestors: {
    tbody: ["table"],
    td: ["table"],
    th: ["table"],
    thead: ["table"],
    tfoot: ["table"],
    tr: ["table"]
  },
  attributes: {
    a: [
      ...Na,
      // Note: these 3 are used by GFM footnotes, they do work on all links.
      "dataFootnoteBackref",
      "dataFootnoteRef",
      ["className", "data-footnote-backref"],
      "href"
    ],
    blockquote: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `code` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    code: [["className", /^language-./]],
    del: ["cite"],
    div: ["itemScope", "itemType"],
    dl: [...Na],
    // Note: this is used by GFM footnotes.
    h2: [["className", "sr-only"]],
    img: [...Na, "longDesc", "src"],
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We cant do that, so we have to allow it.
    input: [
      ["disabled", !0],
      ["type", "checkbox"]
    ],
    ins: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `li` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    li: [["className", "task-list-item"]],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    ol: [...Na, ["className", "contains-task-list"]],
    q: ["cite"],
    section: ["dataFootnotes", ["className", "footnotes"]],
    source: ["srcSet"],
    summary: [...Na],
    table: [...Na],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    ul: [...Na, ["className", "contains-task-list"]],
    "*": [
      "abbr",
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "align",
      "alt",
      "axis",
      "border",
      "cellPadding",
      "cellSpacing",
      "char",
      "charOff",
      "charSet",
      "checked",
      "clear",
      "colSpan",
      "color",
      "cols",
      "compact",
      "coords",
      "dateTime",
      "dir",
      // Note: `disabled` is technically allowed on all elements by GH.
      // But it is useless on everything except `input`.
      // Because `input`s are normally not allowed, but we allow them for
      // checkboxes due to tasklists, we allow `disabled` only there.
      "encType",
      "frame",
      "hSpace",
      "headers",
      "height",
      "hrefLang",
      "htmlFor",
      "id",
      "isMap",
      "itemProp",
      "label",
      "lang",
      "maxLength",
      "media",
      "method",
      "multiple",
      "name",
      "noHref",
      "noShade",
      "noWrap",
      "open",
      "prompt",
      "readOnly",
      "rev",
      "rowSpan",
      "rows",
      "rules",
      "scope",
      "selected",
      "shape",
      "size",
      "span",
      "start",
      "summary",
      "tabIndex",
      "title",
      "useMap",
      "vAlign",
      "value",
      "width"
    ]
  },
  clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
  clobberPrefix: "user-content-",
  protocols: {
    cite: ["http", "https"],
    href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
    longDesc: ["http", "https"],
    src: ["http", "https"]
  },
  required: {
    input: { disabled: !0, type: "checkbox" }
  },
  strip: ["script"],
  tagNames: [
    "a",
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "del",
    "details",
    "div",
    "dl",
    "dt",
    "em",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We cant do that, so we have to allow it.
    "input",
    "ins",
    "kbd",
    "li",
    "ol",
    "p",
    "picture",
    "pre",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "source",
    "span",
    "strike",
    "strong",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr",
    "tt",
    "ul",
    "var"
  ]
}, ha = {}.hasOwnProperty;
function mF(e, t) {
  let n = { type: "root", children: [] };
  const r = {
    schema: t ? { ...Ma, ...t } : Ma,
    stack: []
  }, a = vA(r, e);
  return a && (Array.isArray(a) ? a.length === 1 ? n = a[0] : n.children = a : n = a), n;
}
function vA(e, t) {
  if (t && typeof t == "object") {
    const n = (
      /** @type {Record<string, Readonly<unknown>>} */
      t
    );
    switch (typeof n.type == "string" ? n.type : "") {
      case "comment":
        return pF(e, n);
      case "doctype":
        return gF(e, n);
      case "element":
        return bF(e, n);
      case "root":
        return AF(e, n);
      case "text":
        return EF(e, n);
    }
  }
}
function pF(e, t) {
  if (e.schema.allowComments) {
    const n = typeof t.value == "string" ? t.value : "", r = n.indexOf("-->"), i = { type: "comment", value: r < 0 ? n : n.slice(0, r) };
    return uo(i, t), i;
  }
}
function gF(e, t) {
  if (e.schema.allowDoctypes) {
    const n = { type: "doctype" };
    return uo(n, t), n;
  }
}
function bF(e, t) {
  const n = typeof t.tagName == "string" ? t.tagName : "";
  e.stack.push(n);
  const r = (
    /** @type {Array<ElementContent>} */
    TA(e, t.children)
  ), a = vF(e, t.properties);
  e.stack.pop();
  let i = !1;
  if (n && n !== "*" && (!e.schema.tagNames || e.schema.tagNames.includes(n)) && (i = !0, e.schema.ancestors && ha.call(e.schema.ancestors, n))) {
    const o = e.schema.ancestors[n];
    let u = -1;
    for (i = !1; ++u < o.length; )
      e.stack.includes(o[u]) && (i = !0);
  }
  if (!i)
    return e.schema.strip && !e.schema.strip.includes(n) ? r : void 0;
  const s = {
    type: "element",
    tagName: n,
    properties: a,
    children: r
  };
  return uo(s, t), s;
}
function AF(e, t) {
  const r = { type: "root", children: (
    /** @type {Array<RootContent>} */
    TA(e, t.children)
  ) };
  return uo(r, t), r;
}
function EF(e, t) {
  const r = { type: "text", value: typeof t.value == "string" ? t.value : "" };
  return uo(r, t), r;
}
function TA(e, t) {
  const n = [];
  if (Array.isArray(t)) {
    const r = (
      /** @type {Array<Readonly<unknown>>} */
      t
    );
    let a = -1;
    for (; ++a < r.length; ) {
      const i = vA(e, r[a]);
      i && (Array.isArray(i) ? n.push(...i) : n.push(i));
    }
  }
  return n;
}
function vF(e, t) {
  const n = e.stack[e.stack.length - 1], r = e.schema.attributes, a = e.schema.required, i = r && ha.call(r, n) ? r[n] : void 0, s = r && ha.call(r, "*") ? r["*"] : void 0, o = (
    /** @type {Readonly<Record<string, Readonly<unknown>>>} */
    t && typeof t == "object" ? t : {}
  ), u = {};
  let V;
  for (V in o)
    if (ha.call(o, V)) {
      const c = o[V];
      let f = dp(
        e,
        hp(i, V),
        V,
        c
      );
      f == null && (f = dp(e, hp(s, V), V, c)), f != null && (u[V] = f);
    }
  if (a && ha.call(a, n)) {
    const c = a[n];
    for (V in c)
      ha.call(c, V) && !ha.call(u, V) && (u[V] = c[V]);
  }
  return u;
}
function dp(e, t, n, r) {
  return t ? Array.isArray(r) ? TF(e, t, n, r) : yA(e, t, n, r) : void 0;
}
function TF(e, t, n, r) {
  let a = -1;
  const i = [];
  for (; ++a < r.length; ) {
    const s = yA(e, t, n, r[a]);
    (typeof s == "number" || typeof s == "string") && i.push(s);
  }
  return i;
}
function yA(e, t, n, r) {
  if (!(typeof r != "boolean" && typeof r != "number" && typeof r != "string") && yF(e, n, r)) {
    if (typeof t == "object" && t.length > 1) {
      let a = !1, i = 0;
      for (; ++i < t.length; ) {
        const s = t[i];
        if (s && typeof s == "object" && "flags" in s) {
          if (s.test(String(r))) {
            a = !0;
            break;
          }
        } else if (s === r) {
          a = !0;
          break;
        }
      }
      if (!a)
        return;
    }
    return e.schema.clobber && e.schema.clobberPrefix && e.schema.clobber.includes(n) ? e.schema.clobberPrefix + r : r;
  }
}
function yF(e, t, n) {
  const r = e.schema.protocols && ha.call(e.schema.protocols, t) ? e.schema.protocols[t] : void 0;
  if (!r || r.length === 0)
    return !0;
  const a = String(n), i = a.indexOf(":"), s = a.indexOf("?"), o = a.indexOf("#"), u = a.indexOf("/");
  if (i < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
  u > -1 && i > u || s > -1 && i > s || o > -1 && i > o)
    return !0;
  let V = -1;
  for (; ++V < r.length; ) {
    const c = r[V];
    if (i === c.length && a.slice(0, c.length) === c)
      return !0;
  }
  return !1;
}
function uo(e, t) {
  const n = hF(
    // @ts-expect-error: looks like a node.
    t
  );
  t.data && (e.data = Ja(t.data)), n && (e.position = n);
}
function hp(e, t) {
  let n, r = -1;
  if (e)
    for (; ++r < e.length; ) {
      const a = e[r], i = typeof a == "string" ? a : a[0];
      if (i === t)
        return a;
      i === "data*" && (n = a);
    }
  if (t.length > 4 && t.slice(0, 4).toLowerCase() === "data")
    return n;
}
function _F(e) {
  return function(t) {
    return (
      /** @type {Root} */
      mF(t, e)
    );
  };
}
function mp(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, a = n.indexOf(t);
  for (; a !== -1; )
    r++, a = n.indexOf(t, a + t.length);
  return r;
}
function CF(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function SF(e, t, n) {
  const a = Uu((n || {}).ignore || []), i = xF(t);
  let s = -1;
  for (; ++s < i.length; )
    zb(e, "text", o);
  function o(V, c) {
    let f = -1, p;
    for (; ++f < c.length; ) {
      const h = c[f], g = p ? p.children : void 0;
      if (a(
        h,
        g ? g.indexOf(h) : void 0,
        p
      ))
        return;
      p = h;
    }
    if (p)
      return u(V, c);
  }
  function u(V, c) {
    const f = c[c.length - 1], p = i[s][0], h = i[s][1];
    let g = 0;
    const v = f.children.indexOf(V);
    let x = !1, E = [];
    p.lastIndex = 0;
    let S = p.exec(V.value);
    for (; S; ) {
      const $ = S.index, U = {
        index: S.index,
        input: S.input,
        stack: [...c, V]
      };
      let y = h(...S, U);
      if (typeof y == "string" && (y = y.length > 0 ? { type: "text", value: y } : void 0), y === !1 ? p.lastIndex = $ + 1 : (g !== $ && E.push({
        type: "text",
        value: V.value.slice(g, $)
      }), Array.isArray(y) ? E.push(...y) : y && E.push(y), g = $ + S[0].length, x = !0), !p.global)
        break;
      S = p.exec(V.value);
    }
    return x ? (g < V.value.length && E.push({ type: "text", value: V.value.slice(g) }), f.children.splice(v, 1, ...E)) : E = [V], v + E.length;
  }
}
function xF(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const a = n[r];
    t.push([OF(a[0]), wF(a[1])]);
  }
  return t;
}
function OF(e) {
  return typeof e == "string" ? new RegExp(CF(e), "g") : e;
}
function wF(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const WV = "phrasing", qV = ["autolink", "link", "image", "label"];
function IF() {
  return {
    transforms: [MF],
    enter: {
      literalAutolink: NF,
      literalAutolinkEmail: XV,
      literalAutolinkHttp: XV,
      literalAutolinkWww: XV
    },
    exit: {
      literalAutolink: DF,
      literalAutolinkEmail: PF,
      literalAutolinkHttp: kF,
      literalAutolinkWww: LF
    }
  };
}
function RF() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: WV,
        notInConstruct: qV
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: WV,
        notInConstruct: qV
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: WV,
        notInConstruct: qV
      }
    ]
  };
}
function NF(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function XV(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function kF(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function LF(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function PF(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function DF(e) {
  this.exit(e);
}
function MF(e) {
  SF(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, FF],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, BF]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function FF(e, t, n, r, a) {
  let i = "";
  if (!_A(a) || (/^w/i.test(t) && (n = t + n, t = "", i = "http://"), !$F(n)))
    return !1;
  const s = UF(n + r);
  if (!s[0])
    return !1;
  const o = {
    type: "link",
    title: null,
    url: i + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [o, { type: "text", value: s[1] }] : o;
}
function BF(e, t, n, r) {
  return (
    // Not an expected previous character.
    !_A(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function $F(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function UF(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const a = mp(e, "(");
  let i = mp(e, ")");
  for (; r !== -1 && a > i; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), i++;
  return [e, n];
}
function _A(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || ei(n) || zu(n)) && (!t || n !== 47);
}
CA.peek = QF;
function HF() {
  return {
    enter: {
      gfmFootnoteDefinition: zF,
      gfmFootnoteDefinitionLabelString: GF,
      gfmFootnoteCall: qF,
      gfmFootnoteCallString: XF
    },
    exit: {
      gfmFootnoteDefinition: WF,
      gfmFootnoteDefinitionLabelString: YF,
      gfmFootnoteCall: ZF,
      gfmFootnoteCallString: KF
    }
  };
}
function jF() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: JF, footnoteReference: CA }
  };
}
function zF(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function GF() {
  this.buffer();
}
function YF(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = Er(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function WF(e) {
  this.exit(e);
}
function qF(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function XF() {
  this.buffer();
}
function KF(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = Er(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function ZF(e) {
  this.exit(e);
}
function CA(e, t, n, r) {
  const a = n.createTracker(r);
  let i = a.move("[^");
  const s = n.enter("footnoteReference"), o = n.enter("reference");
  return i += a.move(
    n.safe(n.associationId(e), {
      ...a.current(),
      before: i,
      after: "]"
    })
  ), o(), s(), i += a.move("]"), i;
}
function QF() {
  return "[";
}
function JF(e, t, n, r) {
  const a = n.createTracker(r);
  let i = a.move("[^");
  const s = n.enter("footnoteDefinition"), o = n.enter("label");
  return i += a.move(
    n.safe(n.associationId(e), {
      ...a.current(),
      before: i,
      after: "]"
    })
  ), o(), i += a.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), a.shift(4), i += a.move(
    n.indentLines(n.containerFlow(e, a.current()), eB)
  ), s(), i;
}
function eB(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const tB = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
SA.peek = sB;
function nB() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: aB },
    exit: { strikethrough: iB }
  };
}
function rB() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: tB
      }
    ],
    handlers: { delete: SA }
  };
}
function aB(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function iB(e) {
  this.exit(e);
}
function SA(e, t, n, r) {
  const a = n.createTracker(r), i = n.enter("strikethrough");
  let s = a.move("~~");
  return s += n.containerPhrasing(e, {
    ...a.current(),
    before: s,
    after: "~"
  }), s += a.move("~~"), i(), s;
}
function sB() {
  return "~";
}
function oB(e, t = {}) {
  const n = (t.align || []).concat(), r = t.stringLength || VB, a = [], i = [], s = [], o = [];
  let u = 0, V = -1;
  for (; ++V < e.length; ) {
    const g = [], b = [];
    let v = -1;
    for (e[V].length > u && (u = e[V].length); ++v < e[V].length; ) {
      const x = uB(e[V][v]);
      if (t.alignDelimiters !== !1) {
        const E = r(x);
        b[v] = E, (o[v] === void 0 || E > o[v]) && (o[v] = E);
      }
      g.push(x);
    }
    i[V] = g, s[V] = b;
  }
  let c = -1;
  if (typeof n == "object" && "length" in n)
    for (; ++c < u; )
      a[c] = pp(n[c]);
  else {
    const g = pp(n);
    for (; ++c < u; )
      a[c] = g;
  }
  c = -1;
  const f = [], p = [];
  for (; ++c < u; ) {
    const g = a[c];
    let b = "", v = "";
    g === 99 ? (b = ":", v = ":") : g === 108 ? b = ":" : g === 114 && (v = ":");
    let x = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      o[c] - b.length - v.length
    );
    const E = b + "-".repeat(x) + v;
    t.alignDelimiters !== !1 && (x = b.length + x + v.length, x > o[c] && (o[c] = x), p[c] = x), f[c] = E;
  }
  i.splice(1, 0, f), s.splice(1, 0, p), V = -1;
  const h = [];
  for (; ++V < i.length; ) {
    const g = i[V], b = s[V];
    c = -1;
    const v = [];
    for (; ++c < u; ) {
      const x = g[c] || "";
      let E = "", S = "";
      if (t.alignDelimiters !== !1) {
        const $ = o[c] - (b[c] || 0), U = a[c];
        U === 114 ? E = " ".repeat($) : U === 99 ? $ % 2 ? (E = " ".repeat($ / 2 + 0.5), S = " ".repeat($ / 2 - 0.5)) : (E = " ".repeat($ / 2), S = E) : S = " ".repeat($);
      }
      t.delimiterStart !== !1 && !c && v.push("|"), t.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && x === "") && (t.delimiterStart !== !1 || c) && v.push(" "), t.alignDelimiters !== !1 && v.push(E), v.push(x), t.alignDelimiters !== !1 && v.push(S), t.padding !== !1 && v.push(" "), (t.delimiterEnd !== !1 || c !== u - 1) && v.push("|");
    }
    h.push(
      t.delimiterEnd === !1 ? v.join("").replace(/ +$/, "") : v.join("")
    );
  }
  return h.join(`
`);
}
function uB(e) {
  return e == null ? "" : String(e);
}
function VB(e) {
  return e.length;
}
function pp(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function lB(e, t, n, r) {
  const a = n.enter("blockquote"), i = n.createTracker(r);
  i.move("> "), i.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, i.current()),
    cB
  );
  return a(), s;
}
function cB(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function fB(e, t) {
  return gp(e, t.inConstruct, !0) && !gp(e, t.notInConstruct, !1);
}
function gp(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function bp(e, t, n, r) {
  let a = -1;
  for (; ++a < n.unsafe.length; )
    if (n.unsafe[a].character === `
` && fB(n.stack, n.unsafe[a]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function dB(e, t) {
  const n = String(e);
  let r = n.indexOf(t), a = r, i = 0, s = 0;
  if (typeof t != "string" || t.length !== 1)
    throw new Error("Expected character");
  for (; r !== -1; )
    r === a ? ++i > s && (s = i) : i = 1, a = r + 1, r = n.indexOf(t, a);
  return s;
}
function hB(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function mB(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function pB(e, t, n, r) {
  const a = mB(n), i = e.value || "", s = a === "`" ? "GraveAccent" : "Tilde";
  if (hB(e, n)) {
    const f = n.enter("codeIndented"), p = n.indentLines(i, gB);
    return f(), p;
  }
  const o = n.createTracker(r), u = a.repeat(Math.max(dB(i, a) + 1, 3)), V = n.enter("codeFenced");
  let c = o.move(u);
  if (e.lang) {
    const f = n.enter(`codeFencedLang${s}`);
    c += o.move(
      n.safe(e.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), f();
  }
  if (e.lang && e.meta) {
    const f = n.enter(`codeFencedMeta${s}`);
    c += o.move(" "), c += o.move(
      n.safe(e.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), f();
  }
  return c += o.move(`
`), i && (c += o.move(i + `
`)), c += o.move(u), V(), c;
}
function gB(e, t, n) {
  return (n ? "" : "    ") + e;
}
function rd(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function bB(e, t, n, r) {
  const a = rd(n), i = a === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let V = u.move("[");
  return V += u.move(
    n.safe(n.associationId(e), {
      before: V,
      after: "]",
      ...u.current()
    })
  ), V += u.move("]: "), o(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), V += u.move("<"), V += u.move(
    n.safe(e.url, { before: V, after: ">", ...u.current() })
  ), V += u.move(">")) : (o = n.enter("destinationRaw"), V += u.move(
    n.safe(e.url, {
      before: V,
      after: e.title ? " " : `
`,
      ...u.current()
    })
  )), o(), e.title && (o = n.enter(`title${i}`), V += u.move(" " + a), V += u.move(
    n.safe(e.title, {
      before: V,
      after: a,
      ...u.current()
    })
  ), V += u.move(a), o()), s(), V;
}
function AB(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
xA.peek = EB;
function xA(e, t, n, r) {
  const a = AB(n), i = n.enter("emphasis"), s = n.createTracker(r);
  let o = s.move(a);
  return o += s.move(
    n.containerPhrasing(e, {
      before: o,
      after: a,
      ...s.current()
    })
  ), o += s.move(a), i(), o;
}
function EB(e, t, n) {
  return n.options.emphasis || "*";
}
const vB = {};
function OA(e, t) {
  const n = t || vB, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, a = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return wA(e, r, a);
}
function wA(e, t, n) {
  if (TB(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Ap(e.children, t, n);
  }
  return Array.isArray(e) ? Ap(e, t, n) : "";
}
function Ap(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; )
    r[a] = wA(e[a], t, n);
  return r.join("");
}
function TB(e) {
  return !!(e && typeof e == "object");
}
function yB(e, t) {
  let n = !1;
  return ju(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Mc;
  }), !!((!e.depth || e.depth < 3) && OA(e) && (t.options.setext || n));
}
function _B(e, t, n, r) {
  const a = Math.max(Math.min(6, e.depth || 1), 1), i = n.createTracker(r);
  if (yB(e, n)) {
    const c = n.enter("headingSetext"), f = n.enter("phrasing"), p = n.containerPhrasing(e, {
      ...i.current(),
      before: `
`,
      after: `
`
    });
    return f(), c(), p + `
` + (a === 1 ? "=" : "-").repeat(
      // The whole size
      p.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(p.lastIndexOf("\r"), p.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(a), o = n.enter("headingAtx"), u = n.enter("phrasing");
  i.move(s + " ");
  let V = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...i.current()
  });
  return /^[\t ]/.test(V) && (V = "&#x" + V.charCodeAt(0).toString(16).toUpperCase() + ";" + V.slice(1)), V = V ? s + " " + V : s, n.options.closeAtx && (V += " " + s), u(), o(), V;
}
IA.peek = CB;
function IA(e) {
  return e.value || "";
}
function CB() {
  return "<";
}
RA.peek = SB;
function RA(e, t, n, r) {
  const a = rd(n), i = a === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let V = u.move("![");
  return V += u.move(
    n.safe(e.alt, { before: V, after: "]", ...u.current() })
  ), V += u.move("]("), o(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), V += u.move("<"), V += u.move(
    n.safe(e.url, { before: V, after: ">", ...u.current() })
  ), V += u.move(">")) : (o = n.enter("destinationRaw"), V += u.move(
    n.safe(e.url, {
      before: V,
      after: e.title ? " " : ")",
      ...u.current()
    })
  )), o(), e.title && (o = n.enter(`title${i}`), V += u.move(" " + a), V += u.move(
    n.safe(e.title, {
      before: V,
      after: a,
      ...u.current()
    })
  ), V += u.move(a), o()), V += u.move(")"), s(), V;
}
function SB() {
  return "!";
}
NA.peek = xB;
function NA(e, t, n, r) {
  const a = e.referenceType, i = n.enter("imageReference");
  let s = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("![");
  const V = n.safe(e.alt, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(V + "]["), s();
  const c = n.stack;
  n.stack = [], s = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: u,
    after: "]",
    ...o.current()
  });
  return s(), n.stack = c, i(), a === "full" || !V || V !== f ? u += o.move(f + "]") : a === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function xB() {
  return "!";
}
kA.peek = OB;
function kA(e, t, n) {
  let r = e.value || "", a = "`", i = -1;
  for (; new RegExp("(^|[^`])" + a + "([^`]|$)").test(r); )
    a += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length; ) {
    const s = n.unsafe[i], o = n.compilePattern(s);
    let u;
    if (s.atBreak)
      for (; u = o.exec(r); ) {
        let V = u.index;
        r.charCodeAt(V) === 10 && r.charCodeAt(V - 1) === 13 && V--, r = r.slice(0, V) + " " + r.slice(u.index + 1);
      }
  }
  return a + r + a;
}
function OB() {
  return "`";
}
function LA(e, t) {
  const n = OA(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
PA.peek = wB;
function PA(e, t, n, r) {
  const a = rd(n), i = a === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let o, u;
  if (LA(e, n)) {
    const c = n.stack;
    n.stack = [], o = n.enter("autolink");
    let f = s.move("<");
    return f += s.move(
      n.containerPhrasing(e, {
        before: f,
        after: ">",
        ...s.current()
      })
    ), f += s.move(">"), o(), n.stack = c, f;
  }
  o = n.enter("link"), u = n.enter("label");
  let V = s.move("[");
  return V += s.move(
    n.containerPhrasing(e, {
      before: V,
      after: "](",
      ...s.current()
    })
  ), V += s.move("]("), u(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), V += s.move("<"), V += s.move(
    n.safe(e.url, { before: V, after: ">", ...s.current() })
  ), V += s.move(">")) : (u = n.enter("destinationRaw"), V += s.move(
    n.safe(e.url, {
      before: V,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), u(), e.title && (u = n.enter(`title${i}`), V += s.move(" " + a), V += s.move(
    n.safe(e.title, {
      before: V,
      after: a,
      ...s.current()
    })
  ), V += s.move(a), u()), V += s.move(")"), o(), V;
}
function wB(e, t, n) {
  return LA(e, n) ? "<" : "[";
}
DA.peek = IB;
function DA(e, t, n, r) {
  const a = e.referenceType, i = n.enter("linkReference");
  let s = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("[");
  const V = n.containerPhrasing(e, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(V + "]["), s();
  const c = n.stack;
  n.stack = [], s = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: u,
    after: "]",
    ...o.current()
  });
  return s(), n.stack = c, i(), a === "full" || !V || V !== f ? u += o.move(f + "]") : a === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function IB() {
  return "[";
}
function ad(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function RB(e) {
  const t = ad(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function NB(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function MA(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function kB(e, t, n, r) {
  const a = n.enter("list"), i = n.bulletCurrent;
  let s = e.ordered ? NB(n) : ad(n);
  const o = e.ordered ? s === "." ? ")" : "." : RB(n);
  let u = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const c = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      c && (!c.children || !c.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), MA(n) === s && c
    ) {
      let f = -1;
      for (; ++f < e.children.length; ) {
        const p = e.children[f];
        if (p && p.type === "listItem" && p.children && p.children[0] && p.children[0].type === "thematicBreak") {
          u = !0;
          break;
        }
      }
    }
  }
  u && (s = o), n.bulletCurrent = s;
  const V = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = i, a(), V;
}
function LB(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function PB(e, t, n, r) {
  const a = LB(n);
  let i = n.bulletCurrent || ad(n);
  t && t.type === "list" && t.ordered && (i = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + i);
  let s = i.length + 1;
  (a === "tab" || a === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const o = n.createTracker(r);
  o.move(i + " ".repeat(s - i.length)), o.shift(s);
  const u = n.enter("listItem"), V = n.indentLines(
    n.containerFlow(e, o.current()),
    c
  );
  return u(), V;
  function c(f, p, h) {
    return p ? (h ? "" : " ".repeat(s)) + f : (h ? i : i + " ".repeat(s - i.length)) + f;
  }
}
function DB(e, t, n, r) {
  const a = n.enter("paragraph"), i = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return i(), a(), s;
}
const MB = (
  /** @type {(node?: unknown) => node is PhrasingContent} */
  Uu([
    "break",
    "delete",
    "emphasis",
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    "link",
    "linkReference",
    "strong",
    "text"
  ])
);
function FB(e, t, n, r) {
  return (e.children.some(function(s) {
    return MB(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function BB(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
FA.peek = $B;
function FA(e, t, n, r) {
  const a = BB(n), i = n.enter("strong"), s = n.createTracker(r);
  let o = s.move(a + a);
  return o += s.move(
    n.containerPhrasing(e, {
      before: o,
      after: a,
      ...s.current()
    })
  ), o += s.move(a + a), i(), o;
}
function $B(e, t, n) {
  return n.options.strong || "*";
}
function UB(e, t, n, r) {
  return n.safe(e.value, r);
}
function HB(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function jB(e, t, n) {
  const r = (MA(n) + (n.options.ruleSpaces ? " " : "")).repeat(HB(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const BA = {
  blockquote: lB,
  break: bp,
  code: pB,
  definition: bB,
  emphasis: xA,
  hardBreak: bp,
  heading: _B,
  html: IA,
  image: RA,
  imageReference: NA,
  inlineCode: kA,
  link: PA,
  linkReference: DA,
  list: kB,
  listItem: PB,
  paragraph: DB,
  root: FB,
  strong: FA,
  text: UB,
  thematicBreak: jB
};
function zB() {
  return {
    enter: {
      table: GB,
      tableData: Ep,
      tableHeader: Ep,
      tableRow: WB
    },
    exit: {
      codeText: qB,
      table: YB,
      tableData: KV,
      tableHeader: KV,
      tableRow: KV
    }
  };
}
function GB(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function YB(e) {
  this.exit(e), this.data.inTable = void 0;
}
function WB(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function KV(e) {
  this.exit(e);
}
function Ep(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function qB(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, XB));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function XB(e, t) {
  return t === "|" ? t : e;
}
function KB(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, a = t.stringLength, i = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: p,
      table: s,
      tableCell: u,
      tableRow: o
    }
  };
  function s(h, g, b, v) {
    return V(c(h, b, v), h.align);
  }
  function o(h, g, b, v) {
    const x = f(h, b, v), E = V([x]);
    return E.slice(0, E.indexOf(`
`));
  }
  function u(h, g, b, v) {
    const x = b.enter("tableCell"), E = b.enter("phrasing"), S = b.containerPhrasing(h, {
      ...v,
      before: i,
      after: i
    });
    return E(), x(), S;
  }
  function V(h, g) {
    return oB(h, {
      align: g,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: a
    });
  }
  function c(h, g, b) {
    const v = h.children;
    let x = -1;
    const E = [], S = g.enter("table");
    for (; ++x < v.length; )
      E[x] = f(v[x], g, b);
    return S(), E;
  }
  function f(h, g, b) {
    const v = h.children;
    let x = -1;
    const E = [], S = g.enter("tableRow");
    for (; ++x < v.length; )
      E[x] = u(v[x], h, g, b);
    return S(), E;
  }
  function p(h, g, b) {
    let v = BA.inlineCode(h, g, b);
    return b.stack.includes("tableCell") && (v = v.replace(/\|/g, "\\$&")), v;
  }
}
function ZB() {
  return {
    exit: {
      taskListCheckValueChecked: vp,
      taskListCheckValueUnchecked: vp,
      paragraph: JB
    }
  };
}
function QB() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: e$ }
  };
}
function vp(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function JB(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const a = t.children;
      let i = -1, s;
      for (; ++i < a.length; ) {
        const o = a[i];
        if (o.type === "paragraph") {
          s = o;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function e$(e, t, n, r) {
  const a = e.children[0], i = typeof e.checked == "boolean" && a && a.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  i && o.move(s);
  let u = BA.listItem(e, t, n, {
    ...r,
    ...o.current()
  });
  return i && (u = u.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, V)), u;
  function V(c) {
    return c + s;
  }
}
function t$() {
  return [
    IF(),
    HF(),
    nB(),
    zB(),
    ZB()
  ];
}
function n$(e) {
  return {
    extensions: [
      RF(),
      jF(),
      rB(),
      KB(e),
      QB()
    ]
  };
}
const r$ = {
  tokenize: V$,
  partial: !0
}, $A = {
  tokenize: l$,
  partial: !0
}, UA = {
  tokenize: c$,
  partial: !0
}, HA = {
  tokenize: f$,
  partial: !0
}, a$ = {
  tokenize: d$,
  partial: !0
}, jA = {
  tokenize: o$,
  previous: GA
}, zA = {
  tokenize: u$,
  previous: YA
}, ta = {
  tokenize: s$,
  previous: WA
}, Mr = {};
function i$() {
  return {
    text: Mr
  };
}
let ka = 48;
for (; ka < 123; )
  Mr[ka] = ta, ka++, ka === 58 ? ka = 65 : ka === 91 && (ka = 97);
Mr[43] = ta;
Mr[45] = ta;
Mr[46] = ta;
Mr[95] = ta;
Mr[72] = [ta, zA];
Mr[104] = [ta, zA];
Mr[87] = [ta, jA];
Mr[119] = [ta, jA];
function s$(e, t, n) {
  const r = this;
  let a, i;
  return s;
  function s(f) {
    return !zc(f) || !WA.call(r, r.previous) || id(r.events) ? n(f) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(f));
  }
  function o(f) {
    return zc(f) ? (e.consume(f), o) : f === 64 ? (e.consume(f), u) : n(f);
  }
  function u(f) {
    return f === 46 ? e.check(
      a$,
      c,
      V
    )(f) : f === 45 || f === 95 || hn(f) ? (i = !0, e.consume(f), u) : c(f);
  }
  function V(f) {
    return e.consume(f), a = !0, u;
  }
  function c(f) {
    return i && a && xn(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(f)) : n(f);
  }
}
function o$(e, t, n) {
  const r = this;
  return a;
  function a(s) {
    return s !== 87 && s !== 119 || !GA.call(r, r.previous) || id(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(
      r$,
      e.attempt($A, e.attempt(UA, i), n),
      n
    )(s));
  }
  function i(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function u$(e, t, n) {
  const r = this;
  let a = "", i = !1;
  return s;
  function s(f) {
    return (f === 72 || f === 104) && YA.call(r, r.previous) && !id(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), a += String.fromCodePoint(f), e.consume(f), o) : n(f);
  }
  function o(f) {
    if (xn(f) && a.length < 5)
      return a += String.fromCodePoint(f), e.consume(f), o;
    if (f === 58) {
      const p = a.toLowerCase();
      if (p === "http" || p === "https")
        return e.consume(f), u;
    }
    return n(f);
  }
  function u(f) {
    return f === 47 ? (e.consume(f), i ? V : (i = !0, u)) : n(f);
  }
  function V(f) {
    return f === null || fu(f) || yt(f) || ei(f) || zu(f) ? n(f) : e.attempt($A, e.attempt(UA, c), n)(f);
  }
  function c(f) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(f);
  }
}
function V$(e, t, n) {
  let r = 0;
  return a;
  function a(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), a) : s === 46 && r === 3 ? (e.consume(s), i) : n(s);
  }
  function i(s) {
    return s === null ? n(s) : t(s);
  }
}
function l$(e, t, n) {
  let r, a, i;
  return s;
  function s(V) {
    return V === 46 || V === 95 ? e.check(HA, u, o)(V) : V === null || yt(V) || ei(V) || V !== 45 && zu(V) ? u(V) : (i = !0, e.consume(V), s);
  }
  function o(V) {
    return V === 95 ? r = !0 : (a = r, r = void 0), e.consume(V), s;
  }
  function u(V) {
    return a || r || !i ? n(V) : t(V);
  }
}
function c$(e, t) {
  let n = 0, r = 0;
  return a;
  function a(s) {
    return s === 40 ? (n++, e.consume(s), a) : s === 41 && r < n ? i(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(HA, t, i)(s) : s === null || yt(s) || ei(s) ? t(s) : (e.consume(s), a);
  }
  function i(s) {
    return s === 41 && r++, e.consume(s), a;
  }
}
function f$(e, t, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), r) : o === 38 ? (e.consume(o), i) : o === 93 ? (e.consume(o), a) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || yt(o) || ei(o) ? t(o) : n(o)
    );
  }
  function a(o) {
    return o === null || o === 40 || o === 91 || yt(o) || ei(o) ? t(o) : r(o);
  }
  function i(o) {
    return xn(o) ? s(o) : n(o);
  }
  function s(o) {
    return o === 59 ? (e.consume(o), r) : xn(o) ? (e.consume(o), s) : n(o);
  }
}
function d$(e, t, n) {
  return r;
  function r(i) {
    return e.consume(i), a;
  }
  function a(i) {
    return hn(i) ? n(i) : t(i);
  }
}
function GA(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || yt(e);
}
function YA(e) {
  return !xn(e);
}
function WA(e) {
  return !(e === 47 || zc(e));
}
function zc(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || hn(e);
}
function id(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const h$ = {
  tokenize: T$,
  partial: !0
};
function m$() {
  return {
    document: {
      91: {
        tokenize: A$,
        continuation: {
          tokenize: E$
        },
        exit: v$
      }
    },
    text: {
      91: {
        tokenize: b$
      },
      93: {
        add: "after",
        tokenize: p$,
        resolveTo: g$
      }
    }
  };
}
function p$(e, t, n) {
  const r = this;
  let a = r.events.length;
  const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; a--; ) {
    const u = r.events[a][1];
    if (u.type === "labelImage") {
      s = u;
      break;
    }
    if (u.type === "gfmFootnoteCall" || u.type === "labelLink" || u.type === "label" || u.type === "image" || u.type === "link")
      break;
  }
  return o;
  function o(u) {
    if (!s || !s._balanced)
      return n(u);
    const V = Er(
      r.sliceSerialize({
        start: s.end,
        end: r.now()
      })
    );
    return V.codePointAt(0) !== 94 || !i.includes(V.slice(1)) ? n(u) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(u), e.exit("gfmFootnoteCallLabelMarker"), t(u));
  }
}
function g$(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, a = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  a.end.column++, a.end.offset++, a.end._bufferIndex++;
  const i = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, a.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, i.start),
    end: Object.assign({}, i.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", a, t],
    ["exit", a, t],
    // Everything in between.
    ["enter", i, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", i, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...o), e;
}
function b$(e, t, n) {
  const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i = 0, s;
  return o;
  function o(f) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), u;
  }
  function u(f) {
    return f !== 94 ? n(f) : (e.enter("gfmFootnoteCallMarker"), e.consume(f), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", V);
  }
  function V(f) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      f === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || yt(f)
    )
      return n(f);
    if (f === 93) {
      e.exit("chunkString");
      const p = e.exit("gfmFootnoteCallString");
      return a.includes(Er(r.sliceSerialize(p))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(f);
    }
    return yt(f) || (s = !0), i++, e.consume(f), f === 92 ? c : V;
  }
  function c(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), i++, V) : V(f);
  }
}
function A$(e, t, n) {
  const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i, s = 0, o;
  return u;
  function u(g) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(g), e.exit("gfmFootnoteDefinitionLabelMarker"), V;
  }
  function V(g) {
    return g === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(g), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", c) : n(g);
  }
  function c(g) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      g === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      g === null || g === 91 || yt(g)
    )
      return n(g);
    if (g === 93) {
      e.exit("chunkString");
      const b = e.exit("gfmFootnoteDefinitionLabelString");
      return i = Er(r.sliceSerialize(b)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(g), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), p;
    }
    return yt(g) || (o = !0), s++, e.consume(g), g === 92 ? f : c;
  }
  function f(g) {
    return g === 91 || g === 92 || g === 93 ? (e.consume(g), s++, c) : c(g);
  }
  function p(g) {
    return g === 58 ? (e.enter("definitionMarker"), e.consume(g), e.exit("definitionMarker"), a.includes(i) || a.push(i), ut(
      e,
      h,
      "gfmFootnoteDefinitionWhitespace"
    )) : n(g);
  }
  function h(g) {
    return t(g);
  }
}
function E$(e, t, n) {
  return e.check(so, t, e.attempt(h$, t, n));
}
function v$(e) {
  e.exit("gfmFootnoteDefinition");
}
function T$(e, t, n) {
  const r = this;
  return ut(
    e,
    a,
    "gfmFootnoteDefinitionIndent",
    5
  );
  function a(i) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(i) : n(i);
  }
}
function y$(e) {
  let n = (e || {}).singleTilde;
  const r = {
    tokenize: i,
    resolveAll: a
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function a(s, o) {
    let u = -1;
    for (; ++u < s.length; )
      if (s[u][0] === "enter" && s[u][1].type === "strikethroughSequenceTemporary" && s[u][1]._close) {
        let V = u;
        for (; V--; )
          if (s[V][0] === "exit" && s[V][1].type === "strikethroughSequenceTemporary" && s[V][1]._open && // If the sizes are the same:
          s[u][1].end.offset - s[u][1].start.offset === s[V][1].end.offset - s[V][1].start.offset) {
            s[u][1].type = "strikethroughSequence", s[V][1].type = "strikethroughSequence";
            const c = {
              type: "strikethrough",
              start: Object.assign({}, s[V][1].start),
              end: Object.assign({}, s[u][1].end)
            }, f = {
              type: "strikethroughText",
              start: Object.assign({}, s[V][1].end),
              end: Object.assign({}, s[u][1].start)
            }, p = [
              ["enter", c, o],
              ["enter", s[V][1], o],
              ["exit", s[V][1], o],
              ["enter", f, o]
            ], h = o.parser.constructs.insideSpan.null;
            h && zn(
              p,
              p.length,
              0,
              Gu(h, s.slice(V + 1, u), o)
            ), zn(p, p.length, 0, [
              ["exit", f, o],
              ["enter", s[u][1], o],
              ["exit", s[u][1], o],
              ["exit", c, o]
            ]), zn(s, V - 1, u - V + 3, p), u = V + p.length - 2;
            break;
          }
      }
    for (u = -1; ++u < s.length; )
      s[u][1].type === "strikethroughSequenceTemporary" && (s[u][1].type = "data");
    return s;
  }
  function i(s, o, u) {
    const V = this.previous, c = this.events;
    let f = 0;
    return p;
    function p(g) {
      return V === 126 && c[c.length - 1][1].type !== "characterEscape" ? u(g) : (s.enter("strikethroughSequenceTemporary"), h(g));
    }
    function h(g) {
      const b = du(V);
      if (g === 126)
        return f > 1 ? u(g) : (s.consume(g), f++, h);
      if (f < 2 && !n)
        return u(g);
      const v = s.exit("strikethroughSequenceTemporary"), x = du(g);
      return v._open = !x || x === 2 && !!b, v._close = !b || b === 2 && !!x, o(g);
    }
  }
}
class _$ {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    C$(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(i, s) {
      return i[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(
        t.slice(this.map[n][0] + this.map[n][1]),
        this.map[n][2]
      ), t.length = this.map[n][0];
    r.push([...t]), t.length = 0;
    let a = r.pop();
    for (; a; )
      t.push(...a), a = r.pop();
    this.map.length = 0;
  }
}
function C$(e, t, n, r) {
  let a = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; a < e.map.length; ) {
      if (e.map[a][0] === t) {
        e.map[a][1] += n, e.map[a][2].push(...r);
        return;
      }
      a += 1;
    }
    e.map.push([t, n, r]);
  }
}
function S$(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const a = e[t];
    if (n) {
      if (a[0] === "enter")
        a[1].type === "tableContent" && r.push(
          e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
        );
      else if (a[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const i = r.length - 1;
          r[i] = r[i] === "left" ? "center" : "right";
        }
      } else if (a[1].type === "tableDelimiterRow")
        break;
    } else
      a[0] === "enter" && a[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function x$() {
  return {
    flow: {
      null: {
        tokenize: O$,
        resolveAll: w$
      }
    }
  };
}
function O$(e, t, n) {
  const r = this;
  let a = 0, i = 0, s;
  return o;
  function o(I) {
    let ie = r.events.length - 1;
    for (; ie > -1; ) {
      const P = r.events[ie][1].type;
      if (P === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      P === "linePrefix")
        ie--;
      else
        break;
    }
    const z = ie > -1 ? r.events[ie][1].type : null, H = z === "tableHead" || z === "tableRow" ? y : u;
    return H === y && r.parser.lazy[r.now().line] ? n(I) : H(I);
  }
  function u(I) {
    return e.enter("tableHead"), e.enter("tableRow"), V(I);
  }
  function V(I) {
    return I === 124 || (s = !0, i += 1), c(I);
  }
  function c(I) {
    return I === null ? n(I) : Ne(I) ? i > 1 ? (i = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(I), e.exit("lineEnding"), h) : n(I) : et(I) ? ut(e, c, "whitespace")(I) : (i += 1, s && (s = !1, a += 1), I === 124 ? (e.enter("tableCellDivider"), e.consume(I), e.exit("tableCellDivider"), s = !0, c) : (e.enter("data"), f(I)));
  }
  function f(I) {
    return I === null || I === 124 || yt(I) ? (e.exit("data"), c(I)) : (e.consume(I), I === 92 ? p : f);
  }
  function p(I) {
    return I === 92 || I === 124 ? (e.consume(I), f) : f(I);
  }
  function h(I) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(I) : (e.enter("tableDelimiterRow"), s = !1, et(I) ? ut(
      e,
      g,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(I) : g(I));
  }
  function g(I) {
    return I === 45 || I === 58 ? v(I) : I === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(I), e.exit("tableCellDivider"), b) : U(I);
  }
  function b(I) {
    return et(I) ? ut(e, v, "whitespace")(I) : v(I);
  }
  function v(I) {
    return I === 58 ? (i += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(I), e.exit("tableDelimiterMarker"), x) : I === 45 ? (i += 1, x(I)) : I === null || Ne(I) ? $(I) : U(I);
  }
  function x(I) {
    return I === 45 ? (e.enter("tableDelimiterFiller"), E(I)) : U(I);
  }
  function E(I) {
    return I === 45 ? (e.consume(I), E) : I === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(I), e.exit("tableDelimiterMarker"), S) : (e.exit("tableDelimiterFiller"), S(I));
  }
  function S(I) {
    return et(I) ? ut(e, $, "whitespace")(I) : $(I);
  }
  function $(I) {
    return I === 124 ? g(I) : I === null || Ne(I) ? !s || a !== i ? U(I) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(I)) : U(I);
  }
  function U(I) {
    return n(I);
  }
  function y(I) {
    return e.enter("tableRow"), j(I);
  }
  function j(I) {
    return I === 124 ? (e.enter("tableCellDivider"), e.consume(I), e.exit("tableCellDivider"), j) : I === null || Ne(I) ? (e.exit("tableRow"), t(I)) : et(I) ? ut(e, j, "whitespace")(I) : (e.enter("data"), q(I));
  }
  function q(I) {
    return I === null || I === 124 || yt(I) ? (e.exit("data"), j(I)) : (e.consume(I), I === 92 ? Q : q);
  }
  function Q(I) {
    return I === 92 || I === 124 ? (e.consume(I), q) : q(I);
  }
}
function w$(e, t) {
  let n = -1, r = !0, a = 0, i = [0, 0, 0, 0], s = [0, 0, 0, 0], o = !1, u = 0, V, c, f;
  const p = new _$();
  for (; ++n < e.length; ) {
    const h = e[n], g = h[1];
    h[0] === "enter" ? g.type === "tableHead" ? (o = !1, u !== 0 && (Tp(p, t, u, V, c), c = void 0, u = 0), V = {
      type: "table",
      start: Object.assign({}, g.start),
      // Note: correct end is set later.
      end: Object.assign({}, g.end)
    }, p.add(n, 0, [["enter", V, t]])) : g.type === "tableRow" || g.type === "tableDelimiterRow" ? (r = !0, f = void 0, i = [0, 0, 0, 0], s = [0, n + 1, 0, 0], o && (o = !1, c = {
      type: "tableBody",
      start: Object.assign({}, g.start),
      // Note: correct end is set later.
      end: Object.assign({}, g.end)
    }, p.add(n, 0, [["enter", c, t]])), a = g.type === "tableDelimiterRow" ? 2 : c ? 3 : 1) : a && (g.type === "data" || g.type === "tableDelimiterMarker" || g.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (i[1] !== 0 && (s[0] = s[1], f = So(
      p,
      t,
      i,
      a,
      void 0,
      f
    ), i = [0, 0, 0, 0]), s[2] = n)) : g.type === "tableCellDivider" && (r ? r = !1 : (i[1] !== 0 && (s[0] = s[1], f = So(
      p,
      t,
      i,
      a,
      void 0,
      f
    )), i = s, s = [i[1], n, 0, 0])) : g.type === "tableHead" ? (o = !0, u = n) : g.type === "tableRow" || g.type === "tableDelimiterRow" ? (u = n, i[1] !== 0 ? (s[0] = s[1], f = So(
      p,
      t,
      i,
      a,
      n,
      f
    )) : s[1] !== 0 && (f = So(p, t, s, a, n, f)), a = 0) : a && (g.type === "data" || g.type === "tableDelimiterMarker" || g.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (u !== 0 && Tp(p, t, u, V, c), p.consume(t.events), n = -1; ++n < t.events.length; ) {
    const h = t.events[n];
    h[0] === "enter" && h[1].type === "table" && (h[1]._align = S$(t.events, n));
  }
  return e;
}
function So(e, t, n, r, a, i) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (i.end = Object.assign({}, _i(t.events, n[0])), e.add(n[0], 0, [["exit", i, t]]));
  const u = _i(t.events, n[1]);
  if (i = {
    type: s,
    start: Object.assign({}, u),
    // Note: correct end is set later.
    end: Object.assign({}, u)
  }, e.add(n[1], 0, [["enter", i, t]]), n[2] !== 0) {
    const V = _i(t.events, n[2]), c = _i(t.events, n[3]), f = {
      type: o,
      start: Object.assign({}, V),
      end: Object.assign({}, c)
    };
    if (e.add(n[2], 0, [["enter", f, t]]), r !== 2) {
      const p = t.events[n[2]], h = t.events[n[3]];
      if (p[1].end = Object.assign({}, h[1].end), p[1].type = "chunkText", p[1].contentType = "text", n[3] > n[2] + 1) {
        const g = n[2] + 1, b = n[3] - n[2] - 1;
        e.add(g, b, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", f, t]]);
  }
  return a !== void 0 && (i.end = Object.assign({}, _i(t.events, a)), e.add(a, 0, [["exit", i, t]]), i = void 0), i;
}
function Tp(e, t, n, r, a) {
  const i = [], s = _i(t.events, n);
  a && (a.end = Object.assign({}, s), i.push(["exit", a, t])), r.end = Object.assign({}, s), i.push(["exit", r, t]), e.add(n + 1, 0, i);
}
function _i(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const I$ = {
  tokenize: N$
};
function R$() {
  return {
    text: {
      91: I$
    }
  };
}
function N$(e, t, n) {
  const r = this;
  return a;
  function a(u) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(u) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(u), e.exit("taskListCheckMarker"), i)
    );
  }
  function i(u) {
    return yt(u) ? (e.enter("taskListCheckValueUnchecked"), e.consume(u), e.exit("taskListCheckValueUnchecked"), s) : u === 88 || u === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(u), e.exit("taskListCheckValueChecked"), s) : n(u);
  }
  function s(u) {
    return u === 93 ? (e.enter("taskListCheckMarker"), e.consume(u), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(u);
  }
  function o(u) {
    return Ne(u) ? t(u) : et(u) ? e.check(
      {
        tokenize: k$
      },
      t,
      n
    )(u) : n(u);
  }
}
function k$(e, t, n) {
  return ut(e, r, "whitespace");
  function r(a) {
    return a === null ? n(a) : t(a);
  }
}
function L$(e) {
  return eA([
    i$(),
    m$(),
    y$(e),
    x$(),
    R$()
  ]);
}
const P$ = {};
function D$(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || P$, r = t.data(), a = r.micromarkExtensions || (r.micromarkExtensions = []), i = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  a.push(L$(n)), i.push(t$()), s.push(n$(n));
}
const yp = ["controls", "src", "type", "autoPlay", "loop", "muted", "playsInline", "poster"], M$ = {
  ...Ma,
  attributes: {
    ...Ma.attributes,
    video: yp,
    audio: yp,
    "*": [...Ma.attributes["*"], "style"]
  },
  protocols: {
    ...Ma.protocols,
    href: ["https", "http", "mailto", "tel", "sms", "geo"],
    poster: ["https"]
  },
  tagNames: [...Ma.tagNames, "video", "audio"]
}, F$ = /^(https?|ircs?|mailto|xmpp|tel|sms|geo)$/i;
function B$(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), a = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    a > -1 && t > a || n > -1 && t > n || r > -1 && t > r || // It is a protocol, it should be allowed.
    F$.test(e.slice(0, t)) ? e : ""
  );
}
const qA = Te(lF, {
  blockquote: {
    marginLeft: 0,
    paddingLeft: "$4",
    borderLeft: "3px solid $medGrey"
  },
  code: {
    color: "#e83e8c",
    whiteSpace: "pre-wrap"
  },
  p: {
    marginTop: 0,
    whiteSpace: "pre-wrap"
  },
  "img,video": {
    maxWidth: "100%",
    borderRadius: "$2",
    marginBottom: "$4"
  },
  "ol,ul": {
    paddingInlineStart: "$5"
  },
  "> *:first-child, blockquote>:first-child": {
    marginTop: 0
  },
  "> *:last-child, blockquote>:last-child": {
    marginBottom: 0
  }
});
qA.defaultProps = {
  urlTransform: B$,
  rehypePlugins: [Xb, [_F, M$]],
  remarkPlugins: [D$],
  components: {
    a: ({ node: e, href: t, children: n, ...r }) => /* @__PURE__ */ X.jsx("a", { href: t, target: "_blank", rel: "noopener noreferrer", ...r, children: n })
  },
  remarkRehypeOptions: {
    handlers: {
      break: () => [{ type: "text", value: `
` }]
    }
  }
};
class _p extends Uy {
  constructor() {
    super(...arguments), this.state = {
      hasError: !1
    };
  }
  static getDerivedStateFromError() {
    return { hasError: !0 };
  }
  componentDidUpdate(t) {
    t.children !== this.props.children && this.setState({ hasError: !1 });
  }
  componentDidCatch(t, n) {
    console.error(t, n);
  }
  render() {
    return this.state.hasError ? /* @__PURE__ */ X.jsx(X.Fragment, { children: "Couldn't render markdown." }) : /* @__PURE__ */ X.jsx(qA, { ...this.props });
  }
}
const $$ = ({ text: e }) => {
  var r;
  const t = dn.useContext(_r), n = typeof e == "string" ? e : $5(e);
  return (r = t == null ? void 0 : t.config) != null && r.allowDangerousHTML ? /* @__PURE__ */ X.jsx(Qr, { from: "system", children: /* @__PURE__ */ X.jsx(_p, { rehypePlugins: [Xb], children: n }) }) : /* @__PURE__ */ X.jsx(Qr, { from: "system", children: /* @__PURE__ */ X.jsx(_p, { children: n }) });
}, U$ = dn.memo($$), Yu = _t(vt.FEEDBACK), H$ = Te(Yu("div"), {
  display: "inline-flex",
  alignItems: "center",
  boxSizing: "border-box",
  marginTop: "8.5px"
}), j$ = Te(Yu("div", "description"), {
  color: "$darkGrey",
  marginRight: 4,
  lineHeight: 17,
  typo: {
    size: 12
  }
}), z$ = Te(Yu("div", "buttons"), {
  display: "flex",
  gap: 4
}), Cp = Te(Yu("button", "button"), {
  display: "inline-flex",
  backgroundColor: "transparent",
  border: 0,
  borderRadius: "$round",
  width: 24,
  height: 24,
  padding: 0,
  margin: 0,
  cursor: "pointer",
  variants: {
    active: {
      false: {
        color: "rgb(115 115 118 / 85%)",
        "&:hover": {
          color: "rgb(115 115 118 / 100%)"
        }
      },
      true: {
        color: "$white",
        backgroundColor: "$primary"
      }
    },
    orientation: {
      positive: {
        transform: "none"
      },
      negative: {
        transform: "rotate(180deg)"
      }
    }
  },
  defaultVariants: {
    active: !1,
    orientation: "positive"
  }
}), G$ = ({ question: e = "Was this helpful?", onClick: t, ...n }) => {
  const [r, a] = dn.useState(null), i = (s) => {
    s !== r && (t(s), a(s));
  };
  return /* @__PURE__ */ X.jsxs(H$, { ...n, children: [
    /* @__PURE__ */ X.jsx(j$, { children: e }),
    /* @__PURE__ */ X.jsxs(z$, { children: [
      /* @__PURE__ */ X.jsx(
        Cp,
        {
          orientation: "positive",
          active: r === gs.POSITIVE,
          onClick: () => i(gs.POSITIVE),
          children: /* @__PURE__ */ X.jsx(nl, { width: "24px", height: "24px" })
        }
      ),
      /* @__PURE__ */ X.jsx(
        Cp,
        {
          orientation: "negative",
          active: r === gs.NEGATIVE,
          onClick: () => i(gs.NEGATIVE),
          children: /* @__PURE__ */ X.jsx(nl, { width: "24px", height: "24px" })
        }
      )
    ] })
  ] });
}, Y$ = ({ extension: e, trace: t }) => {
  const n = un(null);
  return Gn(() => {
    var r;
    try {
      const a = (r = e.render) == null ? void 0 : r.call(e, { trace: t, element: n.current });
      return a ? () => {
        try {
          a == null || a();
        } catch (i) {
          console.error(`Extension '${e.name}' threw an error while unmounting: ${i}`);
        }
      } : void 0;
    } catch (a) {
      console.error(`Extension '${e.name}' threw an error while mounting: ${a}`);
      return;
    }
  }, []), /* @__PURE__ */ X.jsx(Qr, { from: "system", className: `vfrc-message--extension-${e.name}`, children: /* @__PURE__ */ X.jsx("span", { ref: n }) });
}, W$ = () => {
  const e = Yn(_r);
  return Gn(() => {
    e.setStatus(pr.ENDED);
  }, []), null;
}, XA = ({ avatar: e, feedback: t, timestamp: n, message: r, withImage: a, children: i }) => {
  const s = un(null), o = un(null), { config: u } = Yn(_r);
  return !i && (r == null ? void 0 : r.type) === cn.END ? /* @__PURE__ */ X.jsx(W$, {}) : /* @__PURE__ */ X.jsxs(X.Fragment, { children: [
    /* @__PURE__ */ X.jsx(H1, { ref: o }),
    /* @__PURE__ */ X.jsxs(L5, { ref: s, withImage: a, scrollable: (r == null ? void 0 : r.type) === cn.CAROUSEL, children: [
      /* @__PURE__ */ X.jsx(ba, { avatar: e }),
      /* @__PURE__ */ X.jsxs(j1, { children: [
        i ?? Lu(r).with({ type: cn.TEXT }, ({ text: V }) => /* @__PURE__ */ X.jsx(U$, { text: V })).with({ type: cn.IMAGE }, ({ url: V }) => {
          var c;
          return /* @__PURE__ */ X.jsx(Qp, { image: V, mode: (c = u.render) == null ? void 0 : c.mode });
        }).with({ type: cn.CARD }, (V) => /* @__PURE__ */ X.jsx(Sf, { ...Do(V, ["type"]) })).with({ type: cn.CAROUSEL }, (V) => /* @__PURE__ */ X.jsx(vk, { ...Do(V, ["type"]), containerRef: s, controlsRef: o })).with({ type: cn.EXTENSION }, ({ payload: V }) => /* @__PURE__ */ X.jsx(Y$, { extension: V.extension, trace: V.trace })).otherwise(() => null),
        t && /* @__PURE__ */ X.jsx(G$, { ...t })
      ] }),
      /* @__PURE__ */ X.jsx(Qa, { value: n })
    ] })
  ] });
}, q$ = ({
  feedback: e,
  avatar: t,
  timestamp: n,
  messages: r,
  actions: a = [],
  isLast: i,
  Message: s = XA
}) => {
  const o = Yn(_r), { showIndicator: u, visibleMessages: V, complete: c } = _5({
    messages: r,
    isLast: i
  });
  return I1([u, c, V.length]), !r.length && !a.length ? null : /* @__PURE__ */ X.jsxs(X.Fragment, { children: [
    V.map((f, p) => /* @__PURE__ */ X.jsx(
      s,
      {
        message: f,
        withImage: !u && p === V.length - 1,
        feedback: c && !u && p === V.length - 1 ? e : void 0,
        avatar: t,
        timestamp: n
      },
      p
    )),
    i && c && !!a.length && /* @__PURE__ */ X.jsx(U1, { children: a.map(({ request: f, name: p }, h) => /* @__PURE__ */ X.jsx(tr, { variant: "secondary", onClick: () => o == null ? void 0 : o.interact(f, p), children: p }, h)) }),
    u && /* @__PURE__ */ X.jsx(z1, { avatar: t })
  ] });
}, hr = Object.assign(q$, {
  Message: cn,
  Container: Bf,
  Controls: H1,
  List: j1,
  Actions: U1,
  Indicator: z1,
  SystemMessage: XA
}), KA = _t(vt.TOOLTIP), ZA = Te(KA(tr.Reset, "button"), {
  height: "$md",
  border: "1px solid $medGrey",
  borderTopColor: "rgba(223,223,223,0.5)",
  borderRadius: "$1",
  borderTopLeftRadius: 0,
  borderTopRightRadius: 0,
  typo: { weight: "$2" },
  color: "$primary",
  backgroundColor: "#fbfbfb"
}), QA = Te(KA("div"), {
  display: "inline-flex",
  flexDirection: "column",
  variants: {
    withAction: {
      true: {
        boxShadow: "0 1px 2px $shadow2",
        [`& ${Qr.Debug.Container}`]: {
          boxShadow: "none",
          borderBottom: 0,
          borderBottomLeftRadius: 0,
          borderBottomRightRadius: 0
        }
      }
    }
  }
}), X$ = ({ label: e, onClick: t, children: n, ...r }) => /* @__PURE__ */ X.jsxs(QA, { withAction: !!e, children: [
  /* @__PURE__ */ X.jsx(Qr.Debug, { ...r, children: n }),
  e && /* @__PURE__ */ X.jsx(ZA, { onClick: t, children: e })
] }), JA = Object.assign(X$, {
  Button: ZA,
  Container: QA
}), sd = _t(vt.USER_RESPONSE), eE = Te(sd("aside", "debug"), {
  typo: { size: "12px", height: "17px" },
  color: "$darkGrey",
  marginTop: "$2"
}), tE = Te(sd("div"), {
  display: "flex",
  flexDirection: "column",
  flexShrink: 0,
  alignItems: "flex-end",
  [`& > ${JA.Container}`]: {
    marginTop: "$1"
  },
  variants: {
    mode: {
      overlay: {
        [`& ${Qr.Container}`]: {
          maxWidth: "248px"
        }
      },
      embedded: {
        [`& ${Qr.Container}`]: {
          maxWidth: "80%"
        }
      }
    }
  },
  defaultVariants: {
    mode: "overlay"
  }
}), nE = Te(sd("div", "row"), {
  display: "flex",
  width: "100%",
  alignItems: "center",
  [`& ${Qa.Container}`]: {
    flexGrow: 1,
    marginRight: 8,
    textAlign: "end",
    opacity: "0%",
    trans: ["opacity"]
  },
  [`&:hover ${Qa.Container}`]: {
    opacity: "100%"
  }
}), K$ = ({ message: e, timestamp: t, debug: n }) => {
  var a, i;
  I1();
  const { config: r } = Yn(_r);
  return /* @__PURE__ */ X.jsxs(tE, { mode: r.render.mode, children: [
    /* @__PURE__ */ X.jsxs(nE, { children: [
      /* @__PURE__ */ X.jsx(Qa, { value: t }),
      /* @__PURE__ */ X.jsx(Qr, { from: "user", children: e })
    ] }),
    n && /* @__PURE__ */ X.jsxs(X.Fragment, { children: [
      /* @__PURE__ */ X.jsx(eE, { children: n.message }),
      n.reason && /* @__PURE__ */ X.jsx(JA, { label: (a = n.action) == null ? void 0 : a.label, onClick: (i = n.action) == null ? void 0 : i.onClick, orientation: "right", children: n.reason })
    ] })
  ] });
}, da = Object.assign(K$, {
  Container: tE,
  Debug: eE,
  Row: nE
}), ZV = 10, Qi = _t(vt.CHAT), hu = Te(Qi("div", "overlay"), {
  position: "absolute",
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  backgroundColor: "$shadow12"
}), Gc = Te(Qi("article"), {
  position: "relative",
  display: "flex",
  overflow: "hidden",
  flexDirection: "column",
  backgroundColor: "$white",
  [`& > ${S1}`]: {
    margin: "auto"
  },
  [`& ${C1.Container}`]: {
    animation: `${Fp} 150ms ease forwards`
  },
  [`& ${T1.Container}`]: {
    ...tf({ duration: 300, delay: 300 })
  },
  [`& ${hu}`]: {
    opacity: 0,
    pointerEvents: "none",
    trans: ["opacity"]
  },
  [`& ${Ro.Container}`]: {
    position: "absolute",
    bottom: 0,
    width: "100%",
    boxSizing: "border-box",
    paddingBottom: `calc($3 + ${ZV}px)`,
    transition: `transform 320ms cubic-bezier(0.45, 1.29, 0.64, 1), ${Mp(["box-shadow"], 300)}`,
    transform: `translateY(calc(100% + ${ZV}px))`
  },
  variants: {
    withPrompt: {
      true: {
        [`& ${hu}`]: {
          opacity: 1,
          zIndex: 2,
          pointerEvents: "auto"
        },
        [`& ${Ro.Container}`]: {
          zIndex: 3,
          transform: `translateY(${ZV}px)`
        }
      },
      false: {
        [`& ${Ro.Container}`]: {
          boxShadow: "none"
        }
      }
    }
  }
}), rE = {
  display: "flex",
  justifyContent: "center",
  typo: { size: 12 },
  color: "$darkGrey"
}, od = Te(Qi("div", "status"), {
  ...rE
}), Z$ = Te(Qi("span", "session-time"), {
  ...rE,
  paddingBottom: "$3"
}), aE = Te(Qi("main", "dialog"), {
  display: "flex",
  flexDirection: "column",
  height: "100%",
  overflowY: "scroll",
  overflowX: "hidden",
  paddingBottom: "$3",
  [`
    & ${da.Container},
    & ${hr.List},
    & ${hr.Actions},
    & ${jp.Container}
  `]: {
    ...tf({ duration: 150, delay: 0 })
  },
  [`
    & > ${da.Container},
    & > ${hr.Container}
  `]: {
    padding: "0 $5"
  },
  [`& > ${hr.Actions}`]: {
    padding: "0 $5 0 54px"
  },
  [`& ${hr.Container}`]: {
    marginBottom: "$1",
    "&:last-of-type": {
      marginBottom: 0
    }
  },
  [`& ${da.Container} + ${da.Container}`]: {
    marginTop: "$1"
  },
  [`
    & ${hr.Container} + ${da.Container},
    & ${hr.Actions} + ${da.Container},
    & ${da.Container} + ${hr.Controls} + ${hr.Container}
  `]: {
    marginTop: "$5"
  },
  [`& ${Qa.Container}`]: { width: 50 },
  [`& ${od}`]: {
    marginTop: "$3",
    marginBottom: 8
  }
}), iE = Te(Qi("div", "spacer"), {
  flexGrow: 1
}), Q$ = ({
  hasEnded: e = !1,
  title: t,
  image: n,
  avatar: r,
  description: a,
  startTime: i,
  isLoading: s,
  withWatermark: o,
  onMinimize: u,
  onEnd: V,
  onStart: c,
  onSend: f,
  children: p,
  audioInterface: h
}) => {
  const g = A5(i), b = un(null), [v, x] = Jt(!1), { config: E, toggleAudioOutput: S } = Yn(_r), $ = Yn(Iu), U = (q) => {
    e ? V == null || V(q) : x(!0);
  }, y = () => x(!1), j = Jr(() => {
    var Q;
    const q = [{ svg: "close", onClick: U }];
    return ((Q = E.render) == null ? void 0 : Q.mode) === ku.OVERLAY && q.unshift({ svg: "minus", onClick: u }), h && q.unshift({
      svg: $.audioOutput ? "sound" : "soundOff",
      onClick: S
    }), q;
  }, [E.render, U, u, $.audioOutput, h]);
  return s ? /* @__PURE__ */ X.jsx(Gc, { children: /* @__PURE__ */ X.jsx(S1, {}) }) : /* @__PURE__ */ X.jsxs(Gc, { withPrompt: v, children: [
    /* @__PURE__ */ X.jsx(C1, { title: t, image: n, actions: j }),
    /* @__PURE__ */ X.jsx(aE, { ref: b, children: /* @__PURE__ */ X.jsxs(d_, { target: b, children: [
      /* @__PURE__ */ X.jsx(jp, { title: t, avatar: r, description: a }),
      /* @__PURE__ */ X.jsx(iE, {}),
      !!g && !!$.session.turns.length && /* @__PURE__ */ X.jsx(Z$, { children: g }),
      p,
      e && !!$.session.turns.length && /* @__PURE__ */ X.jsx(od, { children: "The chat has ended" })
    ] }) }),
    /* @__PURE__ */ X.jsx(
      T1,
      {
        withWatermark: o,
        hasEnded: e,
        onStart: c,
        onSend: f,
        disableSend: $.indicator,
        audioInterface: h,
        speechRecognition: E.speechRecognition
      }
    ),
    /* @__PURE__ */ X.jsx(hu, {}),
    /* @__PURE__ */ X.jsx(
      Ro,
      {
        accept: { label: "End Chat", type: "warn", onClick: wf(V, y) },
        cancel: { label: "Cancel", onClick: y }
      }
    )
  ] });
}, sE = Object.assign(Hy(Q$), {
  Container: Gc,
  Dialog: aE,
  Overlay: hu,
  Spacer: iE,
  Status: od
}), J$ = "data:image/svg+xml,%3csvg%20viewBox='0%200%2036%2036'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cpath%20d='M18.0000533,7%20C24.6266329,7%2030,11.4789312%2030,16.9976931%20C30,22.5163617%2024.6266329,26.9953062%2018.0000533,26.9953062%20C17.123351,26.9971724%2016.2483812,26.9169271%2015.386606,26.7553699%20C14.0404188,27.7431078%2012.5315125,28.4873102%2010.9284053,28.9541197%20C10.4583473,29.0903502%209.95341047,28.916663%209.66660965,28.5199682%20C9.37982216,28.1234068%209.37297168,27.5894152%209.64952342,27.1855224%20C10.1505552,26.5172998%2010.5515886,25.7796289%2010.840002,24.9957036%20C7.9365286,23.3624038%206.10015838,20.3278759%206,16.9976931%20C6,11.4789179%2011.3733271,7%2018.0000533,7%20Z%20M18.0000533,18.0020932%20L14.0000889,18.0020932%20L13.8644511,18.0112196%20C13.3765531,18.0774186%2013.0005042,18.4957012%2013.0005042,19.0018279%20C13.0005042,19.5539661%2013.4480335,20.0015625%2014.0000889,20.0015625%20L18.0000533,20.0015625%20L18.135691,19.9924361%20C18.623589,19.9262371%2018.9996379,19.5079545%2018.9996379,19.0018279%20C18.9996379,18.4496896%2018.5521087,18.0020932%2018.0000533,18.0020932%20Z%20M22.0001244,14.001515%20L14.0000889,14.001515%20L13.8644511,14.0106414%20C13.3765531,14.0768404%2013.0005042,14.495123%2013.0005042,15.0012497%20C13.0005042,15.5533879%2013.4480335,16.0009843%2014.0000889,16.0009843%20L22.0001244,16.0009843%20L22.1357621,15.9918579%20C22.6236601,15.9256589%2022.999709,15.5073764%2022.999709,15.0012497%20C22.999709,14.4491115%2022.5521797,14.001515%2022.0001244,14.001515%20Z'%20fill='%23ffffff'%3e%3c/path%3e%3c/g%3e%3c/svg%3e", eU = _t(vt.LAUNCHER), tU = Te(eU("button"), {
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "$round",
  backgroundColor: "$primary",
  trans: ["background-color", "box-shadow"],
  height: "$xl",
  width: "$xl",
  border: "1px solid $shadow4",
  boxShadow: "0 1px 6px $shadow6, 0 2px 24px $shadow8",
  "&:focus": {
    outline: 0
  },
  "&:hover": {
    cursor: "pointer",
    backgroundColor: "$darkPrimary"
  },
  "& > img": {
    width: "$sm",
    height: "$sm"
  },
  padding: 0,
  margin: 0
}), oE = ({ image: e, onClick: t }) => /* @__PURE__ */ X.jsx(tU, { onClick: t, children: /* @__PURE__ */ X.jsx("img", { src: e || J$, alt: "launch" }) }), nU = _t(vt.PROACTIVE_CLOSE), Yc = Te(nU("div"), {
  width: 32,
  height: 32,
  borderRadius: "$round",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: "#656D75",
  cursor: "pointer",
  background: "$white",
  boxShadow: "$surfaceZ1Light",
  [`& ${zt.Frame}`]: {
    width: 10,
    height: 10
  },
  "&:hover, &:active": {
    color: "#2B3239"
  }
}), uE = ({ ...e }) => /* @__PURE__ */ X.jsx(Yc, { ...e, children: /* @__PURE__ */ X.jsx(zt, { svg: "closeV2" }) }), rU = _t(vt.PROACTIVE_MESSAGE), ud = Te(rU("div"), {
  padding: "11px 16px 10px 16px",
  maxWidth: 256,
  color: "#1A1E23",
  boxShadow: "$surfaceZ1Light",
  borderRadius: "$2",
  background: "$white",
  typo: { size: 14 }
}), VE = _t(vt.PROACTIVE), lE = Te("div", {
  display: "flex",
  flexDirection: "column",
  gap: 8,
  margin: "$4 0",
  alignItems: "inherit",
  [`& ${ud}`]: {
    ...tf({ duration: 150, delay: 0 })
  }
}), cE = Te(VE("div"), {
  position: "absolute",
  bottom: "100%",
  width: 256,
  display: "flex",
  flexDirection: "column",
  [`& ${Yc}`]: {
    opacity: 0
  },
  "&:hover": {
    [`& ${Yc}`]: {
      opacity: 1
    }
  }
}), aU = ({ side: e, messages: t }) => {
  const [n, r] = dn.useState(!1), a = dn.useMemo(
    () => t.map(
      (i, s) => Lu(i).with({ type: Dn.TEXT }, ({ payload: o }) => /* @__PURE__ */ X.jsx(ud, { children: String(o.message) }, s)).otherwise(() => null)
    ),
    [t]
  );
  return dn.useEffect(() => {
    a.length && r(!1);
  }, [a]), n || !a.length ? null : /* @__PURE__ */ X.jsxs(cE, { style: { [e]: 0, alignItems: e === jn.ChatPosition.LEFT ? "start" : "end" }, children: [
    /* @__PURE__ */ X.jsx(uE, { onClick: () => r(!0) }),
    /* @__PURE__ */ X.jsx(lE, { children: a })
  ] });
}, fE = Object.assign(aU, {
  Message: ud,
  Close: uE
}), CU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProactiveContainer: cE,
  ProactiveMessageContainer: lE,
  default: fE,
  tag: VE
}, Symbol.toStringTag, { value: "Module" })), Sp = "https://cdn.voiceflow.com/assets/logo.png", SU = F.object({
  title: F.string().default("Voiceflow Assistant"),
  color: F.string().default(tl),
  image: F.string().default(Sp),
  avatar: F.string().default(Sp),
  launcher: F.string().optional(),
  watermark: F.boolean().default(!0),
  feedback: F.boolean().default(!1),
  stylesheet: F.union([F.string(), F.string().array()]).optional(),
  description: F.string().default(""),
  position: F.nativeEnum(jn.ChatPosition).default(jn.ChatPosition.RIGHT),
  persistence: F.nativeEnum(jn.ChatPersistence).default(jn.ChatPersistence.LOCAL_STORAGE),
  audioInterface: F.boolean().default(!1),
  defaultAudioOutput: F.boolean().optional(),
  spacing: F.object({
    side: F.number().default(30),
    bottom: F.number().default(30)
  }).default({}),
  extensions: JN.array().default([])
}).default({}), iU = "https://general-runtime.voiceflow.com", sU = (e) => {
  try {
    return decodeURIComponent(e);
  } catch {
    return e;
  }
}, oU = F.union([
  F.object({ projectID: F.string() }),
  F.object({ projectID: F.string(), versionID: F.string(), prototype: F.literal(!0) })
]), uU = F.object({
  event: F.object({ type: F.string() }).passthrough().transform((e) => e)
}).partial(), VU = F.object({
  name: F.string(),
  image: F.string()
}).partial(), xp = F.object({
  listening: F.boolean(),
  transcript: F.string(),
  processing: F.boolean(),
  initializing: F.boolean(),
  microphoneAvailable: F.boolean().describe("If false, the user has not given permission for their microphone.")
}), lU = F.object({
  overrideNative: F.boolean().optional().default(!1).describe(
    "If true, uses the custom speech recognition implementation even if the native (browsers) one is available."
  ),
  initialState: xp,
  onStateChange: F.function().args(F.function().args(xp).returns(F.void())).returns(F.function().returns(F.void())),
  stopListening: F.function().returns(F.void()),
  startListening: F.function().returns(F.void()).describe(
    `Starts listening for speech input.
      User has to give permission for their microphone to be used before listening can begin.
      If the user has not given permission, needs to update microphoneAvailable: false state.`
  ),
  resetTranscript: F.function().returns(F.void())
}), xU = F.object({
  autostart: F.boolean().optional(),
  // default to true during migration period, turn off later
  allowDangerousHTML: F.boolean().default(!0),
  url: F.string().default(iU),
  userID: F.union([F.number(), F.string()]).transform((e) => typeof e == "number" ? String(e) : sU(e)).optional(),
  versionID: F.string().optional(),
  verify: oU,
  user: VU.optional(),
  render: m5,
  launch: uU.optional(),
  speechRecognition: lU.optional()
}).transform((e) => ({
  ...e,
  // if not configured default to enabling autostart during overlay mode and disabling it otherwise
  autostart: e.autostart ?? e.render.mode === ku.OVERLAY
})), cU = async (e, t) => {
  const n = document.createElement("link"), r = new Promise((a, i) => {
    n.onload = a, n.onerror = i;
  });
  n.rel = "stylesheet", n.href = e, t.appendChild(n), await r;
}, dE = (e, t) => {
  const [n, r] = Jt(!1);
  return Gn(() => {
    if (!e || n)
      return;
    if (!e.stylesheet) {
      r(!0);
      return;
    }
    const a = Array.isArray(e.stylesheet) ? e.stylesheet[0] : e.stylesheet;
    (async () => (await cU(a, t ?? document.head).catch((i) => {
      console.error(`failed to load stylesheet: ${e.stylesheet}`), console.error(i);
    }), r(!0)))();
  }, [e]), n;
}, hE = Te("div", {
  height: "100%",
  [`& ${sE.Container}`]: {
    height: "100%"
  }
}), fU = ({ className: e }) => {
  const t = Yn(_r), n = Yn(Iu), { assistant: r, config: a } = t, i = qr(() => {
    t.setStatus(pr.ENDED), t.close();
  }, []), s = qr(
    (o) => {
      const u = n.session.turns[o - 1];
      return (u == null ? void 0 : u.type) === ja.USER ? u : null;
    },
    [n.session.turns]
  );
  return /* @__PURE__ */ X.jsx(hE, { className: e, children: /* @__PURE__ */ X.jsxs(
    sE,
    {
      title: r.title,
      description: r.description,
      image: r.image,
      avatar: r.avatar,
      withWatermark: r.watermark,
      startTime: n.session.startTime,
      hasEnded: t.isStatus(pr.ENDED),
      isLoading: t.isStatus(pr.IDLE) && n.session.turns.length === 0 && a.autostart,
      onStart: t.launch,
      onEnd: i,
      onSend: t.reply,
      onMinimize: t.close,
      audioInterface: r.audioInterface,
      children: [
        n.session.turns.map(
          (o, u) => Lu(o).with({ type: ja.USER }, ({ id: V, ...c }) => /* @__PURE__ */ qc(da, { ...Do(c, ["type"]), key: V })).with({ type: ja.SYSTEM }, ({ id: V, ...c }) => /* @__PURE__ */ X.jsx(
            hr,
            {
              ...Do(c, ["type"]),
              feedback: r.feedback ? {
                onClick: (f) => {
                  t.feedback(f, c.messages, s(u));
                }
              } : void 0,
              avatar: r.avatar,
              isLast: u === n.session.turns.length - 1
            },
            V
          )).exhaustive()
        ),
        n.indicator && /* @__PURE__ */ X.jsx(hr.Indicator, { avatar: r.avatar })
      ]
    }
  ) });
}, mE = Object.assign(fU, { Container: hE }), OU = ({ shadowRoot: e, chatAPI: t, ready: n }) => {
  const { assistant: r, interact: a, open: i } = Yn(_r), s = N1(r), o = dE(r, e);
  return R1(
    t,
    () => (console.info("Methods open, close, hide, show, proactive.clear, proactive.push have no effect in this mode."), { interact: a }),
    n
  ), Gn(() => {
    i();
  }, []), o ? /* @__PURE__ */ X.jsx(mE, { className: s }) : null;
}, dU = 380, hU = 800, Vd = _t(vt.WIDGET), Os = Te(Vd("div", "chat"), {
  width: dU,
  overflow: "hidden",
  borderRadius: "$2",
  boxShadow: "0 2px 48px rgba(19,33,68,0.16), 0 0 0 1px $shadow4",
  height: "90%",
  maxHeight: hU,
  "@mobile": {
    position: "fixed",
    height: "unset",
    maxHeight: "unset",
    width: "unset",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    borderRadius: 0,
    boxShadow: "none"
  }
}), ws = Te(Vd("div", "launcher"), {}), Op = {
  opacity: 1,
  pointerEvents: "auto",
  transform: "translateY(0%)",
  transition: "transform 300ms cubic-bezier(0, 0.95, 0.1, 1), opacity 150ms linear"
}, wp = {
  opacity: 0,
  pointerEvents: "none",
  transform: "translateY(100%)",
  transition: "transform 300ms cubic-bezier(0.85, 0, 0.6, 1), opacity 150ms linear"
}, pE = Te(Vd("div"), {
  position: "fixed",
  inset: 0,
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  pointerEvents: "none",
  zIndex: 1e4,
  [`
    & > ${ws},
    & > ${Os}
  `]: {
    position: "absolute"
  },
  variants: {
    withChat: {
      true: {
        [`& > ${Os}`]: {
          ...Op
        },
        [`& > ${ws}`]: {
          ...wp
        }
      },
      false: {
        [`& > ${Os}`]: {
          ...wp
        },
        [`& > ${ws}`]: {
          ...Op
        }
      }
    },
    isHidden: {
      true: {
        display: "none"
      }
    }
  }
}), mU = ({ shadowRoot: e, chatAPI: t, ready: n }) => {
  const { assistant: r, open: a, close: i, interact: s } = Yn(_r), { isOpen: o } = Yn(Iu), [u, V] = Jt(!1), [c, f] = Jt([]), p = Jr(() => window.matchMedia("(max-width: 768px)").matches, []), h = N1(r);
  R1(
    t,
    () => ({
      open: a,
      close: i,
      hide: () => V(!0),
      show: () => V(!1),
      interact: s,
      proactive: {
        clear: () => f([]),
        push: (...x) => f((E) => [...E, ...x])
      }
    }),
    n
  );
  const g = r.position, b = { bottom: r.spacing.bottom, [g]: r.spacing.side };
  return dE(r, e) ? /* @__PURE__ */ X.jsxs(pE, { withChat: o, isHidden: u, className: h, children: [
    /* @__PURE__ */ X.jsxs(ws, { style: b, children: [
      /* @__PURE__ */ X.jsx(fE, { side: g, messages: c }),
      /* @__PURE__ */ X.jsx(oE, { onClick: a, image: r.launcher })
    ] }),
    /* @__PURE__ */ X.jsx(Os, { style: p ? {} : b, children: /* @__PURE__ */ X.jsx(mE, {}) })
  ] }) : null;
}, wU = Object.assign(mU, {
  Launcher: oE,
  Container: pE,
  ChatContainer: Os,
  LauncherContainer: ws
});
export {
  JN as AnyExtension,
  jp as AssistantInfo,
  SU as AssistantOptions,
  TU as AutoScrollConsumer,
  of as AutoScrollContext,
  d_ as AutoScrollProvider,
  ba as Avatar,
  rl as Bubble,
  tr as Button,
  Sf as Card,
  vk as Carousel,
  sE as Chat,
  xU as ChatConfig,
  OU as ChatEmbed,
  r5 as ChatInput,
  lU as ChatSpeechRecognitionConfig,
  xp as ChatSpeechRecognitionState,
  wU as ChatWidget,
  mE as ChatWindow,
  Sp as DEFAULT_AVATAR,
  h5 as EMBEDDED_TARGET,
  ZN as EffectExtension,
  mf as ExtensionType,
  T1 as Footer,
  C1 as Header,
  zt as Icon,
  Qp as Image,
  o5 as Input,
  uU as LaunchOptions,
  oE as Launcher,
  S1 as Loader,
  _p as Markdown,
  Qr as Message,
  D2 as PALETTE,
  tl as PRIMARY,
  CU as Proactive,
  Ro as Prompt,
  iU as RUNTIME_URL,
  ku as RenderMode,
  m5 as RenderOptions,
  QN as ResponseExtension,
  yU as RuntimeProvider,
  _r as RuntimeStateAPIContext,
  Iu as RuntimeStateContext,
  Lp as SHADOWS,
  hr as SystemResponse,
  U$ as Text,
  Io as Textarea,
  Qa as Timestamp,
  JA as Tooltip,
  ja as TurnType,
  x5 as TypingIndicator,
  VU as UserOptions,
  da as UserResponse,
  oU as VerifyOptions,
  Ch as WARN,
  tf as animationStyles,
  wf as chain,
  H2 as createCustomTheme,
  Pp as createPrimaryColors,
  U2 as createTheme,
  Mp as createTransition,
  Fp as fadeIn,
  B2 as getDefaultTheme,
  Yy as isObject,
  mu as keyframes,
  _U as noop,
  j2 as pulse,
  z2 as rotate,
  G2 as shift,
  $2 as stitches,
  Te as styled,
  Bp as textOverflowStyles,
  vU as theme,
  I1 as useAutoScroll,
  R1 as useChatAPI,
  E5 as useDidUpdateEffect,
  KC as useStateRef,
  N1 as useTheme
};
